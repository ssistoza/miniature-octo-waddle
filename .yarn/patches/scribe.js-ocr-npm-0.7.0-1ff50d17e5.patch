diff --git a/js/canvasAdapter.js b/js/canvasAdapter.js
index 6b973d9c6669672e1a96f4be72eda62266f143ec..fc99829a04dc4b8e8c5c71421d864843c4f0a898 100644
--- a/js/canvasAdapter.js
+++ b/js/canvasAdapter.js
@@ -5,18 +5,7 @@ export class ca {
   static CanvasKit;
 
   static getCanvasKit = async () => {
-    if (typeof process === 'undefined') {
-      throw new Error('getCanvasKit is only available in Node.js');
-    } else {
-      if (!ca.CanvasKit) {
-        // This weirdness is required for types to work for some reason.
-        // https://stackoverflow.com/a/69694837
-        const canvasKitImport = await import('canvaskit-wasm');
-        const CanvasKitInit = canvasKitImport.default;
-        ca.CanvasKit = await CanvasKitInit();
-      }
-      return ca.CanvasKit;
-    }
+    throw new Error('getCanvasKit is only available in Node.js');
   };
 
   /**
@@ -25,11 +14,7 @@ export class ca {
    * @param {number} height
    */
   static createCanvas = async (width, height) => {
-    if (typeof process === 'undefined') {
-      return new OffscreenCanvas(width, height);
-    }
-    const canvasKit = await ca.getCanvasKit();
-    return canvasKit.MakeCanvas(width, height);
+    return new OffscreenCanvas(width, height);
   };
 
   /**
@@ -44,27 +29,11 @@ export class ca {
     if (img === null) throw new Error('Input is null');
 
     if (typeof img === 'string') {
-      if (typeof process === 'undefined') {
-        const imgBlob = imageStrToBlob(img);
-        const imgBit = await createImageBitmap(imgBlob);
-        return imgBit;
-      }
-
-      const imgData = new Uint8Array(atob(img.split(',')[1])
-        .split('')
-        .map((c) => c.charCodeAt(0)));
-
-      const canvasKit = await ca.getCanvasKit();
-
-      const imgBit = await canvasKit.MakeImageFromEncoded(imgData);
+      const imgBlob = imageStrToBlob(img);
+      const imgBit = await createImageBitmap(imgBlob);
       return imgBit;
     }
 
-    // In Node.js the input is assumed to be already compatible with the `canvas.drawImage` method.
-    // Additionally, `ImageBitmap` does not exist within the Node canvas package.
-    // Second condition exists for type detection purposes.
-    if (!(typeof process === 'undefined') && (typeof img !== 'string') && (typeof img !== 'number')) return img;
-
     return img;
   };
 
@@ -75,19 +44,6 @@ export class ca {
    * @param {FontContainerFont} fontObj
    */
   static registerFontObj = async (fontObj) => {
-    if (typeof process === 'undefined') {
-      throw new Error('registerFontObj is only available in Node.js');
-    } else {
-      const dummyCanvas = await ca.dummyCanvasPromise;
-
-      const fs = await import('fs');
-      const fontBuffer = typeof fontObj.src === 'string' ? fs.readFileSync(fontObj.src) : fontObj.src;
-
-      dummyCanvas.loadFont(fontBuffer, {
-        family: fontObj.fontFaceName,
-        style: fontObj.fontFaceStyle,
-        weight: fontObj.fontFaceWeight,
-      });
-    }
+    throw new Error('registerFontObj is only available in Node.js');
   };
 }
diff --git a/js/containers/fontContainer.js b/js/containers/fontContainer.js
index 61e36a19c3b4122c1ae08206ec7f0bdf49419930..707449f39fe0cafab093ce9f28bf1997d498eb75 100644
--- a/js/containers/fontContainer.js
+++ b/js/containers/fontContainer.js
@@ -8,17 +8,6 @@ import opentype from '../../lib/opentype.module.js';
 import { determineSansSerif } from '../utils/miscUtils.js';
 import { ca } from '../canvasAdapter.js';
 
-if (typeof process === 'object') {
-  // @ts-ignore
-  globalThis.self = globalThis;
-  // @ts-ignore
-  const { createRequire } = await import('module');
-  globalThis.require = createRequire(import.meta.url);
-  const { fileURLToPath } = await import('url');
-  const { dirname } = await import('path');
-  globalThis.__dirname = dirname(fileURLToPath(import.meta.url));
-}
-
 /**
  * Checks whether `multiFontMode` should be enabled or disabled.
  * @param {Object.<string, FontMetricsFamily>} fontMetricsObj
@@ -32,9 +21,15 @@ if (typeof process === 'object') {
 export function checkMultiFontMode(fontMetricsObj) {
   let defaultFontObs = 0;
   let namedFontObs = 0;
-  if (fontMetricsObj.Default?.obs) { defaultFontObs += (fontMetricsObj.Default?.obs || 0); }
-  if (fontMetricsObj.SerifDefault?.obs) { namedFontObs += (fontMetricsObj.SerifDefault?.obs || 0); }
-  if (fontMetricsObj.SansDefault?.obs) { namedFontObs += (fontMetricsObj.SansDefault?.obs || 0); }
+  if (fontMetricsObj.Default?.obs) {
+    defaultFontObs += fontMetricsObj.Default?.obs || 0;
+  }
+  if (fontMetricsObj.SerifDefault?.obs) {
+    namedFontObs += fontMetricsObj.SerifDefault?.obs || 0;
+  }
+  if (fontMetricsObj.SansDefault?.obs) {
+    namedFontObs += fontMetricsObj.SansDefault?.obs || 0;
+  }
 
   return namedFontObs > defaultFontObs;
 }
@@ -44,7 +39,10 @@ export function checkMultiFontMode(fontMetricsObj) {
  * @param {?Object.<string, number>} [kerningPairs=null]
  */
 export async function loadOpentype(src, kerningPairs = null) {
-  const font = typeof (src) === 'string' ? await opentype.load(src) : await opentype.parse(src, { lowMemory: false });
+  const font =
+    typeof src === 'string'
+      ? await opentype.load(src)
+      : await opentype.parse(src, { lowMemory: false });
   font.tables.gsub = null;
   // Re-apply kerningPairs object so when toArrayBuffer is called on this font later (when making a pdf) kerning data will be included
   if (kerningPairs) font.kerningPairs = kerningPairs;
@@ -64,27 +62,35 @@ const fontFaceObj = {};
  * @param {string|ArrayBuffer} src - Font source
  */
 export function loadFontFace(fontFamily, fontStyle, fontWeight, src) {
-  const src1 = typeof (src) === 'string' ? `url(${src})` : src;
+  const src1 = typeof src === 'string' ? `url(${src})` : src;
 
-  const fontFace = new FontFace(fontFamily, src1, { style: fontStyle, weight: fontWeight });
+  const fontFace = new FontFace(fontFamily, src1, {
+    style: fontStyle,
+    weight: fontWeight,
+  });
 
-  if (fontFace.status === 'error') throw new Error(`FontFace failed to load: ${fontFamily} ${fontStyle} ${fontWeight}`);
+  if (fontFace.status === 'error')
+    throw new Error(
+      `FontFace failed to load: ${fontFamily} ${fontStyle} ${fontWeight}`
+    );
 
   // Fonts are stored in `document.fonts` for the main thread and `WorkerGlobalScope.fonts` for workers
-  const fontSet = globalThis.document ? globalThis.document.fonts : globalThis.fonts;
+  const fontSet = globalThis.document
+    ? globalThis.document.fonts
+    : globalThis.fonts;
 
   // As FontFace objects are added to the document fonts as a side effect,
   // they need to be kept track of and manually deleted to correctly replace.
-  if (typeof (fontFaceObj[fontFamily]) === 'undefined') {
+  if (typeof fontFaceObj[fontFamily] === 'undefined') {
     fontFaceObj[fontFamily] = {};
   }
 
-  if (typeof (fontFaceObj[fontFamily][fontStyle]) === 'undefined') {
+  if (typeof fontFaceObj[fontFamily][fontStyle] === 'undefined') {
     fontFaceObj[fontFamily][fontStyle] = {};
   }
 
   // Delete font if it already exists
-  if (typeof (fontFaceObj[fontFamily][fontStyle][fontWeight]) !== 'undefined') {
+  if (typeof fontFaceObj[fontFamily][fontStyle][fontWeight] !== 'undefined') {
     fontSet.delete(fontFaceObj[fontFamily][fontStyle][fontWeight]);
   }
 
@@ -158,7 +164,8 @@ export function FontContainerFont(family, style, src, opt, opentypeObj) {
   /** @type {('normal'|'bold')} */
   this.fontFaceWeight = this.style === 'bold' ? 'bold' : 'normal';
   /** @type {("sans"|"serif")} */
-  this.type = determineSansSerif(this.family) === 'SansDefault' ? 'sans' : 'serif';
+  this.type =
+    determineSansSerif(this.family) === 'SansDefault' ? 'sans' : 'serif';
   this.smallCapsMult = 0.75;
   /**
    * @type {boolean} - Disable font. This is used to prevent a flawed font extracted from a PDF from being used.
@@ -166,7 +173,12 @@ export function FontContainerFont(family, style, src, opt, opentypeObj) {
   this.disable = false;
 
   if (typeof FontFace !== 'undefined') {
-    loadFontFace(this.fontFaceName, this.fontFaceStyle, this.fontFaceWeight, this.src);
+    loadFontFace(
+      this.fontFaceName,
+      this.fontFaceStyle,
+      this.fontFaceWeight,
+      this.src
+    );
   } else {
     ca.registerFontObj(this);
   }
@@ -192,20 +204,25 @@ export async function loadFontContainerFamily(family, src, opt = false) {
    * @param {('normal'|'bold'|'italic')} type
    * @returns
    */
-  const loadType = (type) => new Promise((resolve) => {
-    const srcType = (src[type]);
-    if (!srcType) {
-      resolve(false);
-      return;
-    }
-    // const scrNormal = typeof srcType === 'string' ? getFontAbsPath(srcType) : srcType;
-    loadOpentype(srcType).then((font) => {
-      res[type] = new FontContainerFont(family, type, srcType, opt, font);
-      resolve(true);
+  const loadType = (type) =>
+    new Promise((resolve) => {
+      const srcType = src[type];
+      if (!srcType) {
+        resolve(false);
+        return;
+      }
+      // const scrNormal = typeof srcType === 'string' ? getFontAbsPath(srcType) : srcType;
+      loadOpentype(srcType).then((font) => {
+        res[type] = new FontContainerFont(family, type, srcType, opt, font);
+        resolve(true);
+      });
     });
-  });
 
-  Promise.allSettled([loadType('normal'), loadType('italic'), loadType('bold')]);
+  Promise.allSettled([
+    loadType('normal'),
+    loadType('italic'),
+    loadType('bold'),
+  ]);
 
   return res;
 }
@@ -310,11 +327,19 @@ export class FontCont {
     // mupdf makes changes to font names, so we need to do the same.
     // Font names in the form `MEDJCO+CenturySchoolbook` are changed to `CenturySchoolbook`.
     // Spaces are replaced with underscores.
-    const fontName = fontNameEmbedded.replace(/[^+]+\+/g, '').replace(/\s/g, '_');
+    const fontName = fontNameEmbedded
+      .replace(/[^+]+\+/g, '')
+      .replace(/\s/g, '_');
 
     if (!FontCont.doc?.[fontName]?.[fontStyle]) {
       try {
-        const fontContainer = new FontContainerFont(fontName, fontStyle, fontData, false, fontObj);
+        const fontContainer = new FontContainerFont(
+          fontName,
+          fontStyle,
+          fontData,
+          false,
+          fontObj
+        );
 
         if (!FontCont.doc) {
           FontCont.doc = {};
@@ -344,20 +369,29 @@ export class FontCont {
     const opt = FontCont.opt?.[family]?.normal;
     if (opt && FontCont.forceOpt) {
       return true;
-    // If optimized fonts are enabled (but not forced), the optimized version of a font will be used if:
-    // (1) The optimized version exists
-    // (2) The optimized version has a better metric (so quality should improve).
-    // (3) The optimized version of the default sans/serif font also has a better metric.
-    // This last condition avoids font optimization being enabled in the UI when it only improves an unused font.
-    } if (opt && FontCont.enableOpt) {
-      const defaultFamily = raw.type === 'serif' ? FontCont.serifDefaultName : FontCont.sansDefaultName;
+      // If optimized fonts are enabled (but not forced), the optimized version of a font will be used if:
+      // (1) The optimized version exists
+      // (2) The optimized version has a better metric (so quality should improve).
+      // (3) The optimized version of the default sans/serif font also has a better metric.
+      // This last condition avoids font optimization being enabled in the UI when it only improves an unused font.
+    }
+    if (opt && FontCont.enableOpt) {
+      const defaultFamily =
+        raw.type === 'serif'
+          ? FontCont.serifDefaultName
+          : FontCont.sansDefaultName;
 
       const rawMetricDefault = FontCont.rawMetrics?.[defaultFamily];
       const optMetricDefault = FontCont.optMetrics?.[defaultFamily];
 
       const rawMetric = FontCont.rawMetrics?.[family];
       const optMetric = FontCont.optMetrics?.[family];
-      if (rawMetric && optMetric && optMetric < rawMetric && optMetricDefault < rawMetricDefault) {
+      if (
+        rawMetric &&
+        optMetric &&
+        optMetric < rawMetric &&
+        optMetricDefault < rawMetricDefault
+      ) {
         return true;
       }
     }
@@ -365,21 +399,25 @@ export class FontCont {
   };
 
   /**
-     * Gets a font object.  Unlike accessing the font containers directly,
-     * this method allows for special values 'Default', 'SansDefault', and 'SerifDefault' to be used.
-     *
-     * @param {('Default'|'SansDefault'|'SerifDefault'|string)} family - Font family name.
-     * @param {('normal'|'italic'|'bold'|string)} [style='normal']
-     * @param {string} [lang='eng']
-     * @returns {FontContainerFont}
-     */
+   * Gets a font object.  Unlike accessing the font containers directly,
+   * this method allows for special values 'Default', 'SansDefault', and 'SerifDefault' to be used.
+   *
+   * @param {('Default'|'SansDefault'|'SerifDefault'|string)} family - Font family name.
+   * @param {('normal'|'italic'|'bold'|string)} [style='normal']
+   * @param {string} [lang='eng']
+   * @returns {FontContainerFont}
+   */
   static getFont = (family, style = 'normal', lang = 'eng') => {
-    if (FontCont.doc?.[family]?.[style] && !FontCont.doc?.[family]?.[style]?.disable) {
+    if (
+      FontCont.doc?.[family]?.[style] &&
+      !FontCont.doc?.[family]?.[style]?.disable
+    ) {
       return FontCont.doc[family][style];
     }
 
     if (lang === 'chi_sim') {
-      if (!FontCont.supp.chi_sim) throw new Error('chi_sim font does not exist.');
+      if (!FontCont.supp.chi_sim)
+        throw new Error('chi_sim font does not exist.');
       return FontCont.supp.chi_sim;
     }
 
@@ -422,7 +460,8 @@ export class FontCont {
 
     /** @type {FontContainerFont} */
     let fontRes = FontCont.raw?.[family]?.[style];
-    if (!fontRes) throw new Error(`Font container does not contain ${family} (${style}).`);
+    if (!fontRes)
+      throw new Error(`Font container does not contain ${family} (${style}).`);
 
     const opt = FontCont.opt?.[family]?.[style];
     const useOpt = FontCont.useOptFamily(family);
diff --git a/js/containers/imageContainer.js b/js/containers/imageContainer.js
index e3644950623c50ccbe51e287f9047975685cc183..160b659b39a0609b732d5f8b50db9c3a3de4ffae 100644
--- a/js/containers/imageContainer.js
+++ b/js/containers/imageContainer.js
@@ -1,16 +1,10 @@
-import {
-  PageMetrics,
-} from '../objects/pageMetricsObjects.js';
+import { PageMetrics } from '../objects/pageMetricsObjects.js';
 
 import { initMuPDFWorker } from '../../mupdf/mupdf-async.js';
 
 import { updateFontContWorkerMain } from '../fontContainerMain.js';
 import { pageMetricsArr } from './dataContainer.js';
-import {
-  FontCont,
-  FontContainerFont,
-  loadOpentype,
-} from './fontContainer.js';
+import { FontCont, FontContainerFont, loadOpentype } from './fontContainer.js';
 
 import { gs } from '../generalWorkerMain.js';
 import { imageUtils } from '../objects/imageObjects.js';
@@ -28,17 +22,18 @@ export class MuPDFScheduler {
      * @param {Parameters<typeof import('../../mupdf/mupdf-worker.js').mupdf.pageText>[1]} args
      * @returns {Promise<ReturnType<typeof import('../../mupdf/mupdf-worker.js').mupdf.pageText>>}
      */
-    this.pageText = (args) => (this.scheduler.addJob('pageText', args));
+    this.pageText = (args) => this.scheduler.addJob('pageText', args);
     /**
      * @param {Parameters<typeof import('../../mupdf/mupdf-worker.js').mupdf.extractAllFonts>[1]} args
      * @returns {Promise<ReturnType<typeof import('../../mupdf/mupdf-worker.js').mupdf.extractAllFonts>>}
      */
-    this.extractAllFonts = (args) => (this.scheduler.addJob('extractAllFonts', args));
+    this.extractAllFonts = (args) =>
+      this.scheduler.addJob('extractAllFonts', args);
     /**
      * @param {Parameters<typeof import('../../mupdf/mupdf-worker.js').mupdf.drawPageAsPNG>[1]} args
      * @returns {Promise<ReturnType<typeof import('../../mupdf/mupdf-worker.js').mupdf.drawPageAsPNG>>}
      */
-    this.drawPageAsPNG = (args) => (this.scheduler.addJob('drawPageAsPNG', args));
+    this.drawPageAsPNG = (args) => this.scheduler.addJob('drawPageAsPNG', args);
   }
 }
 
@@ -57,7 +52,8 @@ export class ImageWrapper {
     this.n = n;
     this.src = imageStr;
     const format0 = imageStr.match(/^data:image\/(png|jpeg)/)?.[1];
-    if (!format0 || !['png', 'jpeg'].includes(format0)) throw new Error(`Invalid image format: ${format0}`);
+    if (!format0 || !['png', 'jpeg'].includes(format0))
+      throw new Error(`Invalid image format: ${format0}`);
     this.format = format0;
     this._dims = null;
     this.rotated = rotated;
@@ -122,7 +118,9 @@ export class ImageCache {
     /** @type {"binary" | "color" | "gray"} */
     let colorMode = 'binary';
     if (!binary) {
-      const color = props?.colorMode === 'color' || !props?.colorMode && opt.colorMode === 'color';
+      const color =
+        props?.colorMode === 'color' ||
+        (!props?.colorMode && opt.colorMode === 'color');
       colorMode = color ? 'color' : 'gray';
     }
 
@@ -140,7 +138,10 @@ export class ImageCache {
     const isUpscaled = upscaleArg || inputImage.upscaled;
 
     return {
-      rotated: isRotated, upscaled: isUpscaled, colorMode, n,
+      rotated: isRotated,
+      upscaled: isUpscaled,
+      colorMode,
+      n,
     };
   };
 
@@ -172,7 +173,9 @@ export class ImageCache {
    * @returns
    */
   static #initMuPDFScheduler = async (numWorkers = 3) => {
-    const Tesseract = typeof process === 'undefined' ? (await import('../../tess/tesseract.esm.min.js')).default : await import('@scribe.js/tesseract.js');
+    const Tesseract = true
+      ? (await import('../../tess/tesseract.esm.min.js')).default
+      : await import('@scribe.js/tesseract.js');
     const scheduler = await Tesseract.createScheduler();
     const workersPromiseArr = range(1, numWorkers).map(async () => {
       const w = await initMuPDFWorker();
@@ -194,17 +197,19 @@ export class ImageCache {
   static #loadFileMuPDFScheduler = async (fileData) => {
     const scheduler = await ImageCache.getMuPDFScheduler();
 
-    const workersPromiseArr = range(0, scheduler.workers.length - 1).map(async (x) => {
-      const w = scheduler.workers[x];
+    const workersPromiseArr = range(0, scheduler.workers.length - 1).map(
+      async (x) => {
+        const w = scheduler.workers[x];
 
-      if (w.pdfDoc) await w.freeDocument(w.pdfDoc);
+        if (w.pdfDoc) await w.freeDocument(w.pdfDoc);
 
-      // The ArrayBuffer is transferred to the worker, so a new one must be created for each worker.
-      // const fileData = await file.arrayBuffer();
-      const fileDataCopy = fileData.slice(0);
-      const pdfDoc = await w.openDocument(fileDataCopy, 'document.pdf');
-      w.pdfDoc = pdfDoc;
-    });
+        // The ArrayBuffer is transferred to the worker, so a new one must be created for each worker.
+        // const fileData = await file.arrayBuffer();
+        const fileDataCopy = fileData.slice(0);
+        const pdfDoc = await w.openDocument(fileDataCopy, 'document.pdf');
+        w.pdfDoc = pdfDoc;
+      }
+    );
 
     await Promise.all(workersPromiseArr);
   };
@@ -212,14 +217,20 @@ export class ImageCache {
   static #renderImage = async (n, color = false) => {
     if (ImageCache.inputModes.image) {
       return ImageCache.nativeSrc[n];
-    } if (ImageCache.inputModes.pdf) {
+    }
+    if (ImageCache.inputModes.pdf) {
       const pageMetrics = pageMetricsArr[n];
       const targetWidth = pageMetrics.dims.width;
       const dpi = 300 * (targetWidth / ImageCache.pdfDims300[n].width);
       const muPDFScheduler = await ImageCache.getMuPDFScheduler();
-      return muPDFScheduler.drawPageAsPNG({
-        page: n + 1, dpi, color, skipText: skipTextMode,
-      }).then((res) => new ImageWrapper(n, res, color ? 'color' : 'gray'));
+      return muPDFScheduler
+        .drawPageAsPNG({
+          page: n + 1,
+          dpi,
+          color,
+          skipText: skipTextMode,
+        })
+        .then((res) => new ImageWrapper(n, res, color ? 'color' : 'gray'));
     }
     throw new Error('Attempted to render image without image input provided.');
   };
@@ -231,7 +242,12 @@ export class ImageCache {
    *  Image properties should only be defined if needed, as they can require the image to be re-rendered.
    * @param {boolean} [saveNativeImage=true] - Whether the native image should be saved.
    */
-  static transformImage = async (inputImage, n, props, saveNativeImage = true) => {
+  static transformImage = async (
+    inputImage,
+    n,
+    props,
+    saveNativeImage = true
+  ) => {
     let pageAngle = pageMetricsArr[n].angle || 0;
     if (Math.abs(pageAngle) < 0.05) pageAngle = 0;
 
@@ -245,13 +261,19 @@ export class ImageCache {
     await gs.getGeneralScheduler();
 
     const resPromise = (async () => {
-    // Wait for non-rotated version before replacing with promise
-      if (typeof process === 'undefined') await gs.initTesseract({ anyOk: true });
+      // Wait for non-rotated version before replacing with promise
+      if (true) await gs.initTesseract({ anyOk: true });
       return gs.recognize({
         image: inputImage.src,
         options: { rotateRadians: angleArg, upscale: upscaleArg },
         output: {
-          imageBinary: true, imageColor: saveNativeImage, debug: true, text: false, hocr: false, tsv: false, blocks: false,
+          imageBinary: true,
+          imageColor: saveNativeImage,
+          debug: true,
+          text: false,
+          hocr: false,
+          tsv: false,
+          blocks: false,
         },
       });
     })();
@@ -261,10 +283,28 @@ export class ImageCache {
     /** @type {?Promise<ImageWrapper>} */
     let native = null;
     if (saveNativeImage) {
-      native = resPromise.then(async (res) => new ImageWrapper(n, /** @type {string} */(/** @type {unknown} */(res.imageColor)), inputImage.colorMode, isRotated, upscaleArg));
+      native = resPromise.then(
+        async (res) =>
+          new ImageWrapper(
+            n,
+            /** @type {string} */ (/** @type {unknown} */ (res.imageColor)),
+            inputImage.colorMode,
+            isRotated,
+            upscaleArg
+          )
+      );
     }
 
-    const binary = resPromise.then(async (res) => new ImageWrapper(n, /** @type {string} */(/** @type {unknown} */(res.imageBinary)), 'binary', isRotated, upscaleArg));
+    const binary = resPromise.then(
+      async (res) =>
+        new ImageWrapper(
+          n,
+          /** @type {string} */ (/** @type {unknown} */ (res.imageBinary)),
+          'binary',
+          isRotated,
+          upscaleArg
+        )
+    );
 
     return { native, binary };
   };
@@ -278,17 +318,39 @@ export class ImageCache {
   static getImages = (n, props, nativeOnly = true) => {
     const significantRotation = Math.abs(pageMetricsArr[n].angle || 0) > 0.05;
 
-    const newNative = !ImageCache.native[n] || !imageUtils.compatible(ImageCache.nativeProps[n], props, significantRotation);
-    const newBinary = !nativeOnly && (!ImageCache.binary[n] || !imageUtils.compatible(ImageCache.binaryProps[n], props, significantRotation));
+    const newNative =
+      !ImageCache.native[n] ||
+      !imageUtils.compatible(
+        ImageCache.nativeProps[n],
+        props,
+        significantRotation
+      );
+    const newBinary =
+      !nativeOnly &&
+      (!ImageCache.binary[n] ||
+        !imageUtils.compatible(
+          ImageCache.binaryProps[n],
+          props,
+          significantRotation
+        ));
 
     if (newNative || newBinary) {
-      const renderRaw = !ImageCache.native[n] || imageUtils.requiresUndo(ImageCache.nativeProps[n], props);
+      const renderRaw =
+        !ImageCache.native[n] ||
+        imageUtils.requiresUndo(ImageCache.nativeProps[n], props);
       const propsRaw = {
-        colorMode: opt.colorMode, rotated: false, upscaled: false, n,
+        colorMode: opt.colorMode,
+        rotated: false,
+        upscaled: false,
+        n,
       };
-      const renderTransform = newBinary || !imageUtils.compatible(propsRaw, props, significantRotation);
+      const renderTransform =
+        newBinary ||
+        !imageUtils.compatible(propsRaw, props, significantRotation);
 
-      const propsNew = renderRaw ? propsRaw : JSON.parse(JSON.stringify(ImageCache.nativeProps[n]));
+      const propsNew = renderRaw
+        ? propsRaw
+        : JSON.parse(JSON.stringify(ImageCache.nativeProps[n]));
       propsNew.colorMode = props?.colorMode || propsNew.colorMode;
       propsNew.rotated = props?.rotated ?? propsNew.rotated;
       propsNew.upscaled = props?.upscaled ?? propsNew.upscaled;
@@ -302,7 +364,9 @@ export class ImageCache {
         /** @type {?ImageWrapper} */
         let img1;
         if (renderRaw) {
-          const color = props?.colorMode === 'color' || !props?.colorMode && opt.colorMode === 'color';
+          const color =
+            props?.colorMode === 'color' ||
+            (!props?.colorMode && opt.colorMode === 'color');
           img1 = await ImageCache.#renderImage(n, color);
         } else {
           img1 = await inputNative;
@@ -324,13 +388,15 @@ export class ImageCache {
    * @param {number} n
    * @param {ImagePropertiesRequest} [props]
    */
-  static getNative = async (n, props) => ImageCache.getImages(n, props, true).native;
+  static getNative = async (n, props) =>
+    ImageCache.getImages(n, props, true).native;
 
   /**
    * @param {number} n
    * @param {ImagePropertiesRequest} [props]
    */
-  static getBinary = async (n, props) => ImageCache.getImages(n, props, false).binary;
+  static getBinary = async (n, props) =>
+    ImageCache.getImages(n, props, false).binary;
 
   /**
    * Pre-render a range of pages.
@@ -345,13 +411,21 @@ export class ImageCache {
   static preRenderRange = async (min, max, binary, props) => {
     const pagesArr = range(min, max);
     if (binary) {
-      await Promise.all(pagesArr.map((n) => ImageCache.getBinary(n, props).then(() => {
-        opt.progressHandler({ n, type: 'render', info: { } });
-      })));
+      await Promise.all(
+        pagesArr.map((n) =>
+          ImageCache.getBinary(n, props).then(() => {
+            opt.progressHandler({ n, type: 'render', info: {} });
+          })
+        )
+      );
     } else {
-      await Promise.all(pagesArr.map((n) => ImageCache.getNative(n, props).then(() => {
-        opt.progressHandler({ n, type: 'render', info: { } });
-      })));
+      await Promise.all(
+        pagesArr.map((n) =>
+          ImageCache.getNative(n, props).then(() => {
+            opt.progressHandler({ n, type: 'render', info: {} });
+          })
+        )
+      );
     }
   };
 
@@ -418,10 +492,15 @@ export class ImageCache {
 
     // For reasons that are unclear, a small number of pages have been rendered into massive files
     // so a hard-cap on resolution must be imposed.
-    const pageDPI = ImageCache.pdfDims300.map((x) => 300 * Math.min(x.width, 3500) / x.width);
+    const pageDPI = ImageCache.pdfDims300.map(
+      (x) => (300 * Math.min(x.width, 3500)) / x.width
+    );
 
     ImageCache.pdfDims300.forEach((x, i) => {
-      const pageDims = { width: Math.round(x.width * pageDPI[i] / 300), height: Math.round(x.height * pageDPI[i] / 300) };
+      const pageDims = {
+        width: Math.round((x.width * pageDPI[i]) / 300),
+        height: Math.round((x.height * pageDPI[i]) / 300),
+      };
       pageMetricsArr[i] = new PageMetrics(pageDims);
     });
 
diff --git a/js/fontContainerMain.js b/js/fontContainerMain.js
index e25eb8e8e6d7ffebe73c73d7bf5652e4ff09a3ae..f885b1bede0814ce12858ab94da3b4c4aff1dadc 100644
--- a/js/fontContainerMain.js
+++ b/js/fontContainerMain.js
@@ -15,118 +15,214 @@ import { gs } from './generalWorkerMain.js';
  */
 export async function loadBuiltInFontsRaw(glyphSet = 'latin') {
   // Return early if the font set is already loaded, or a superset of the requested set is loaded.
-  if (FontCont.glyphSet === glyphSet || FontCont.glyphSet === 'all' && glyphSet === 'latin') return;
+  if (
+    FontCont.glyphSet === glyphSet ||
+    (FontCont.glyphSet === 'all' && glyphSet === 'latin')
+  )
+    return;
 
   FontCont.glyphSet = glyphSet;
 
   // Note: this function is intentionally verbose, and should not be refactored to generate the paths dynamically.
   // Build systems will not be able to resolve the paths if they are generated dynamically.
-  let /** @type {Promise<ArrayBuffer>} */carlitoNormal;
-  let /** @type {Promise<ArrayBuffer>} */carlitoItalic;
-  let /** @type {Promise<ArrayBuffer>} */carlitoBold;
-  let /** @type {Promise<ArrayBuffer>} */centuryNormal;
-  let /** @type {Promise<ArrayBuffer>} */centuryItalic;
-  let /** @type {Promise<ArrayBuffer>} */centuryBold;
-  let /** @type {Promise<ArrayBuffer>} */garamondNormal;
-  let /** @type {Promise<ArrayBuffer>} */garamondItalic;
-  let /** @type {Promise<ArrayBuffer>} */garamondBold;
-  let /** @type {Promise<ArrayBuffer>} */palatinoNormal;
-  let /** @type {Promise<ArrayBuffer>} */palatinoItalic;
-  let /** @type {Promise<ArrayBuffer>} */palatinoBold;
-  let /** @type {Promise<ArrayBuffer>} */nimbusRomNo9LNormal;
-  let /** @type {Promise<ArrayBuffer>} */nimbusRomNo9LItalic;
-  let /** @type {Promise<ArrayBuffer>} */nimbusRomNo9LBold;
-  let /** @type {Promise<ArrayBuffer>} */nimbusSansNormal;
-  let /** @type {Promise<ArrayBuffer>} */nimbusSansItalic;
-  let /** @type {Promise<ArrayBuffer>} */nimbusSansBold;
-  let /** @type {Promise<ArrayBuffer>} */nimbusMonoNormal;
-  let /** @type {Promise<ArrayBuffer>} */nimbusMonoItalic;
-  let /** @type {Promise<ArrayBuffer>} */nimbusMonoBold;
-  if (typeof process === 'undefined') {
-    if (glyphSet === 'latin') {
-      carlitoNormal = fetch(new URL('../fonts/latin/Carlito-Regular.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      carlitoItalic = fetch(new URL('../fonts/latin/Carlito-Italic.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      carlitoBold = fetch(new URL('../fonts/latin/Carlito-Bold.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      centuryNormal = fetch(new URL('../fonts/latin/C059-Roman.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      centuryItalic = fetch(new URL('../fonts/latin/C059-Italic.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      centuryBold = fetch(new URL('../fonts/latin/C059-Bold.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      garamondNormal = fetch(new URL('../fonts/latin/EBGaramond-Regular.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      garamondItalic = fetch(new URL('../fonts/latin/EBGaramond-Italic.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      garamondBold = fetch(new URL('../fonts/latin/EBGaramond-Bold.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      palatinoNormal = fetch(new URL('../fonts/latin/P052-Roman.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      palatinoItalic = fetch(new URL('../fonts/latin/P052-Italic.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      palatinoBold = fetch(new URL('../fonts/latin/P052-Bold.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      nimbusRomNo9LNormal = fetch(new URL('../fonts/latin/NimbusRoman-Regular.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      nimbusRomNo9LItalic = fetch(new URL('../fonts/latin/NimbusRoman-Italic.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      nimbusRomNo9LBold = fetch(new URL('../fonts/latin/NimbusRoman-Bold.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      nimbusSansNormal = fetch(new URL('../fonts/latin/NimbusSans-Regular.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      nimbusSansItalic = fetch(new URL('../fonts/latin/NimbusSans-Italic.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      nimbusSansBold = fetch(new URL('../fonts/latin/NimbusSans-Bold.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      nimbusMonoNormal = fetch(new URL('../fonts/latin/NimbusMonoPS-Regular.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      nimbusMonoItalic = fetch(new URL('../fonts/latin/NimbusMonoPS-Italic.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      nimbusMonoBold = fetch(new URL('../fonts/latin/NimbusMonoPS-Bold.woff', import.meta.url)).then((res) => res.arrayBuffer());
-    } else {
-      carlitoNormal = fetch(new URL('../fonts/all/Carlito-Regular.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      carlitoItalic = fetch(new URL('../fonts/all/Carlito-Italic.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      carlitoBold = fetch(new URL('../fonts/all/Carlito-Bold.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      centuryNormal = fetch(new URL('../fonts/all/C059-Roman.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      centuryItalic = fetch(new URL('../fonts/all/C059-Italic.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      centuryBold = fetch(new URL('../fonts/all/C059-Bold.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      garamondNormal = fetch(new URL('../fonts/all/EBGaramond-Regular.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      garamondItalic = fetch(new URL('../fonts/all/EBGaramond-Italic.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      garamondBold = fetch(new URL('../fonts/all/EBGaramond-Bold.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      palatinoNormal = fetch(new URL('../fonts/all/P052-Roman.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      palatinoItalic = fetch(new URL('../fonts/all/P052-Italic.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      palatinoBold = fetch(new URL('../fonts/all/P052-Bold.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      nimbusRomNo9LNormal = fetch(new URL('../fonts/all/NimbusRoman-Regular.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      nimbusRomNo9LItalic = fetch(new URL('../fonts/all/NimbusRoman-Italic.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      nimbusRomNo9LBold = fetch(new URL('../fonts/all/NimbusRoman-Bold.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      nimbusSansNormal = fetch(new URL('../fonts/all/NimbusSans-Regular.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      nimbusSansItalic = fetch(new URL('../fonts/all/NimbusSans-Italic.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      nimbusSansBold = fetch(new URL('../fonts/all/NimbusSans-Bold.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      nimbusMonoNormal = fetch(new URL('../fonts/all/NimbusMonoPS-Regular.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      nimbusMonoItalic = fetch(new URL('../fonts/all/NimbusMonoPS-Italic.woff', import.meta.url)).then((res) => res.arrayBuffer());
-      nimbusMonoBold = fetch(new URL('../fonts/all/NimbusMonoPS-Bold.woff', import.meta.url)).then((res) => res.arrayBuffer());
-    }
+  let /** @type {Promise<ArrayBuffer>} */ carlitoNormal;
+  let /** @type {Promise<ArrayBuffer>} */ carlitoItalic;
+  let /** @type {Promise<ArrayBuffer>} */ carlitoBold;
+  let /** @type {Promise<ArrayBuffer>} */ centuryNormal;
+  let /** @type {Promise<ArrayBuffer>} */ centuryItalic;
+  let /** @type {Promise<ArrayBuffer>} */ centuryBold;
+  let /** @type {Promise<ArrayBuffer>} */ garamondNormal;
+  let /** @type {Promise<ArrayBuffer>} */ garamondItalic;
+  let /** @type {Promise<ArrayBuffer>} */ garamondBold;
+  let /** @type {Promise<ArrayBuffer>} */ palatinoNormal;
+  let /** @type {Promise<ArrayBuffer>} */ palatinoItalic;
+  let /** @type {Promise<ArrayBuffer>} */ palatinoBold;
+  let /** @type {Promise<ArrayBuffer>} */ nimbusRomNo9LNormal;
+  let /** @type {Promise<ArrayBuffer>} */ nimbusRomNo9LItalic;
+  let /** @type {Promise<ArrayBuffer>} */ nimbusRomNo9LBold;
+  let /** @type {Promise<ArrayBuffer>} */ nimbusSansNormal;
+  let /** @type {Promise<ArrayBuffer>} */ nimbusSansItalic;
+  let /** @type {Promise<ArrayBuffer>} */ nimbusSansBold;
+  let /** @type {Promise<ArrayBuffer>} */ nimbusMonoNormal;
+  let /** @type {Promise<ArrayBuffer>} */ nimbusMonoItalic;
+  let /** @type {Promise<ArrayBuffer>} */ nimbusMonoBold;
+  if (glyphSet === 'latin') {
+    carlitoNormal = fetch(
+      new URL('../fonts/latin/Carlito-Regular.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    carlitoItalic = fetch(
+      new URL('../fonts/latin/Carlito-Italic.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    carlitoBold = fetch(
+      new URL('../fonts/latin/Carlito-Bold.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    centuryNormal = fetch(
+      new URL('../fonts/latin/C059-Roman.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    centuryItalic = fetch(
+      new URL('../fonts/latin/C059-Italic.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    centuryBold = fetch(
+      new URL('../fonts/latin/C059-Bold.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    garamondNormal = fetch(
+      new URL('../fonts/latin/EBGaramond-Regular.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    garamondItalic = fetch(
+      new URL('../fonts/latin/EBGaramond-Italic.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    garamondBold = fetch(
+      new URL('../fonts/latin/EBGaramond-Bold.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    palatinoNormal = fetch(
+      new URL('../fonts/latin/P052-Roman.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    palatinoItalic = fetch(
+      new URL('../fonts/latin/P052-Italic.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    palatinoBold = fetch(
+      new URL('../fonts/latin/P052-Bold.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    nimbusRomNo9LNormal = fetch(
+      new URL('../fonts/latin/NimbusRoman-Regular.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    nimbusRomNo9LItalic = fetch(
+      new URL('../fonts/latin/NimbusRoman-Italic.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    nimbusRomNo9LBold = fetch(
+      new URL('../fonts/latin/NimbusRoman-Bold.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    nimbusSansNormal = fetch(
+      new URL('../fonts/latin/NimbusSans-Regular.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    nimbusSansItalic = fetch(
+      new URL('../fonts/latin/NimbusSans-Italic.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    nimbusSansBold = fetch(
+      new URL('../fonts/latin/NimbusSans-Bold.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    nimbusMonoNormal = fetch(
+      new URL('../fonts/latin/NimbusMonoPS-Regular.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    nimbusMonoItalic = fetch(
+      new URL('../fonts/latin/NimbusMonoPS-Italic.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    nimbusMonoBold = fetch(
+      new URL('../fonts/latin/NimbusMonoPS-Bold.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
   } else {
-    const { readFile } = await import('fs/promises');
-    carlitoNormal = readFile(new URL('../fonts/all_ttf/Carlito-Regular.ttf', import.meta.url)).then((res) => res.buffer);
-    carlitoItalic = readFile(new URL('../fonts/all_ttf/Carlito-Italic.ttf', import.meta.url)).then((res) => res.buffer);
-    carlitoBold = readFile(new URL('../fonts/all_ttf/Carlito-Bold.ttf', import.meta.url)).then((res) => res.buffer);
-    centuryNormal = readFile(new URL('../fonts/all_ttf/C059-Roman.ttf', import.meta.url)).then((res) => res.buffer);
-    centuryItalic = readFile(new URL('../fonts/all_ttf/C059-Italic.ttf', import.meta.url)).then((res) => res.buffer);
-    centuryBold = readFile(new URL('../fonts/all_ttf/C059-Bold.ttf', import.meta.url)).then((res) => res.buffer);
-    garamondNormal = readFile(new URL('../fonts/all_ttf/EBGaramond-Regular.ttf', import.meta.url)).then((res) => res.buffer);
-    garamondItalic = readFile(new URL('../fonts/all_ttf/EBGaramond-Italic.ttf', import.meta.url)).then((res) => res.buffer);
-    garamondBold = readFile(new URL('../fonts/all_ttf/EBGaramond-Bold.ttf', import.meta.url)).then((res) => res.buffer);
-    palatinoNormal = readFile(new URL('../fonts/all_ttf/P052-Roman.ttf', import.meta.url)).then((res) => res.buffer);
-    palatinoItalic = readFile(new URL('../fonts/all_ttf/P052-Italic.ttf', import.meta.url)).then((res) => res.buffer);
-    palatinoBold = readFile(new URL('../fonts/all_ttf/P052-Bold.ttf', import.meta.url)).then((res) => res.buffer);
-    nimbusRomNo9LNormal = readFile(new URL('../fonts/all_ttf/NimbusRoman-Regular.ttf', import.meta.url)).then((res) => res.buffer);
-    nimbusRomNo9LItalic = readFile(new URL('../fonts/all_ttf/NimbusRoman-Italic.ttf', import.meta.url)).then((res) => res.buffer);
-    nimbusRomNo9LBold = readFile(new URL('../fonts/all_ttf/NimbusRoman-Bold.ttf', import.meta.url)).then((res) => res.buffer);
-    nimbusSansNormal = readFile(new URL('../fonts/all_ttf/NimbusSans-Regular.ttf', import.meta.url)).then((res) => res.buffer);
-    nimbusSansItalic = readFile(new URL('../fonts/all_ttf/NimbusSans-Italic.ttf', import.meta.url)).then((res) => res.buffer);
-    nimbusSansBold = readFile(new URL('../fonts/all_ttf/NimbusSans-Bold.ttf', import.meta.url)).then((res) => res.buffer);
-    nimbusMonoNormal = readFile(new URL('../fonts/all_ttf/NimbusMonoPS-Regular.ttf', import.meta.url)).then((res) => res.buffer);
-    nimbusMonoItalic = readFile(new URL('../fonts/all_ttf/NimbusMonoPS-Italic.ttf', import.meta.url)).then((res) => res.buffer);
-    nimbusMonoBold = readFile(new URL('../fonts/all_ttf/NimbusMonoPS-Bold.ttf', import.meta.url)).then((res) => res.buffer);
+    carlitoNormal = fetch(
+      new URL('../fonts/all/Carlito-Regular.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    carlitoItalic = fetch(
+      new URL('../fonts/all/Carlito-Italic.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    carlitoBold = fetch(
+      new URL('../fonts/all/Carlito-Bold.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    centuryNormal = fetch(
+      new URL('../fonts/all/C059-Roman.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    centuryItalic = fetch(
+      new URL('../fonts/all/C059-Italic.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    centuryBold = fetch(
+      new URL('../fonts/all/C059-Bold.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    garamondNormal = fetch(
+      new URL('../fonts/all/EBGaramond-Regular.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    garamondItalic = fetch(
+      new URL('../fonts/all/EBGaramond-Italic.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    garamondBold = fetch(
+      new URL('../fonts/all/EBGaramond-Bold.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    palatinoNormal = fetch(
+      new URL('../fonts/all/P052-Roman.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    palatinoItalic = fetch(
+      new URL('../fonts/all/P052-Italic.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    palatinoBold = fetch(
+      new URL('../fonts/all/P052-Bold.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    nimbusRomNo9LNormal = fetch(
+      new URL('../fonts/all/NimbusRoman-Regular.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    nimbusRomNo9LItalic = fetch(
+      new URL('../fonts/all/NimbusRoman-Italic.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    nimbusRomNo9LBold = fetch(
+      new URL('../fonts/all/NimbusRoman-Bold.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    nimbusSansNormal = fetch(
+      new URL('../fonts/all/NimbusSans-Regular.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    nimbusSansItalic = fetch(
+      new URL('../fonts/all/NimbusSans-Italic.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    nimbusSansBold = fetch(
+      new URL('../fonts/all/NimbusSans-Bold.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    nimbusMonoNormal = fetch(
+      new URL('../fonts/all/NimbusMonoPS-Regular.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    nimbusMonoItalic = fetch(
+      new URL('../fonts/all/NimbusMonoPS-Italic.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
+    nimbusMonoBold = fetch(
+      new URL('../fonts/all/NimbusMonoPS-Bold.woff', import.meta.url)
+    ).then((res) => res.arrayBuffer());
   }
 
   const srcObj = {
-    Carlito: { normal: await carlitoNormal, italic: await carlitoItalic, bold: await carlitoBold },
-    Century: { normal: await centuryNormal, italic: await centuryItalic, bold: await centuryBold },
-    Garamond: { normal: await garamondNormal, italic: await garamondItalic, bold: await garamondBold },
-    Palatino: { normal: await palatinoNormal, italic: await palatinoItalic, bold: await palatinoBold },
-    NimbusRomNo9L: { normal: await nimbusRomNo9LNormal, italic: await nimbusRomNo9LItalic, bold: await nimbusRomNo9LBold },
-    NimbusSans: { normal: await nimbusSansNormal, italic: await nimbusSansItalic, bold: await nimbusSansBold },
-    NimbusMono: { normal: await nimbusMonoNormal, italic: await nimbusMonoItalic, bold: await nimbusMonoBold },
+    Carlito: {
+      normal: await carlitoNormal,
+      italic: await carlitoItalic,
+      bold: await carlitoBold,
+    },
+    Century: {
+      normal: await centuryNormal,
+      italic: await centuryItalic,
+      bold: await centuryBold,
+    },
+    Garamond: {
+      normal: await garamondNormal,
+      italic: await garamondItalic,
+      bold: await garamondBold,
+    },
+    Palatino: {
+      normal: await palatinoNormal,
+      italic: await palatinoItalic,
+      bold: await palatinoBold,
+    },
+    NimbusRomNo9L: {
+      normal: await nimbusRomNo9LNormal,
+      italic: await nimbusRomNo9LItalic,
+      bold: await nimbusRomNo9LBold,
+    },
+    NimbusSans: {
+      normal: await nimbusSansNormal,
+      italic: await nimbusSansItalic,
+      bold: await nimbusSansBold,
+    },
+    NimbusMono: {
+      normal: await nimbusMonoNormal,
+      italic: await nimbusMonoItalic,
+      bold: await nimbusMonoBold,
+    },
   };
 
-  FontCont.raw = await /** @type {FontContainer} */(/** @type {any} */(loadFontsFromSource(srcObj)));
+  FontCont.raw = await /** @type {FontContainer} */ (
+    /** @type {any} */ (loadFontsFromSource(srcObj))
+  );
 
   // This assumes that the scheduler `init` method has at least started.
-  if (gs.schedulerReady === null) console.warn('Failed to load fonts to workers as workers have not been initialized yet.');
+  if (gs.schedulerReady === null)
+    console.warn(
+      'Failed to load fonts to workers as workers have not been initialized yet.'
+    );
   await gs.schedulerReady;
   // If this is running, presumably a new glyphset is being loaded, so the fonts should be forced to be updated.
   await updateFontContWorkerMain({ loadRaw: true });
@@ -147,15 +243,18 @@ export async function loadChiSimFont() {
     chiReadyRes = resolve;
   });
 
-  let /** @type {Promise<ArrayBuffer>} */chiSimSrc;
-  if (typeof process === 'undefined') {
-    chiSimSrc = fetch(new URL('../fonts/NotoSansSC-Regular.ttf', import.meta.url)).then((res) => res.arrayBuffer());
-  } else {
-    const { readFile } = await import('fs/promises');
-    chiSimSrc = readFile(new URL('../fonts/NotoSansSC-Regular.ttf', import.meta.url)).then((res) => res.buffer);
-  }
+  let /** @type {Promise<ArrayBuffer>} */ chiSimSrc;
+  chiSimSrc = fetch(
+    new URL('../fonts/NotoSansSC-Regular.ttf', import.meta.url)
+  ).then((res) => res.arrayBuffer());
 
-  FontCont.supp.chi_sim = await loadFont('NotoSansSC', 'normal', 'sans', await chiSimSrc, false);
+  FontCont.supp.chi_sim = await loadFont(
+    'NotoSansSC',
+    'normal',
+    'sans',
+    await chiSimSrc,
+    false
+  );
 
   chiReadyRes();
 
@@ -197,14 +296,30 @@ export async function enableFontOpt(enableOpt, forceOpt) {
  * @param {boolean} [params.updateProps]
  */
 export async function updateFontContWorkerMain(params = {}) {
-  const loadRaw = params.loadRaw === true || (params.loadRaw !== false && FontCont.raw && !gs.loadedBuiltInFontsRawWorker);
-  const loadOpt = params.loadOpt === true || (params.loadOpt !== false && FontCont.opt && !gs.loadedBuiltInFontsOptWorker);
-  const loadDoc = params.loadDoc === true || (params.loadDoc !== false && FontCont.doc && !gs.loadedBuiltInFontsDocWorker);
+  const loadRaw =
+    params.loadRaw === true ||
+    (params.loadRaw !== false &&
+      FontCont.raw &&
+      !gs.loadedBuiltInFontsRawWorker);
+  const loadOpt =
+    params.loadOpt === true ||
+    (params.loadOpt !== false &&
+      FontCont.opt &&
+      !gs.loadedBuiltInFontsOptWorker);
+  const loadDoc =
+    params.loadDoc === true ||
+    (params.loadDoc !== false &&
+      FontCont.doc &&
+      !gs.loadedBuiltInFontsDocWorker);
 
   // If the active font data is not already loaded, load it now.
   // This assumes that only one version of the raw/optimized fonts ever exist--
   // it does not check whether the current optimized font changed since it was last loaded.
-  for (const [type, load] of [['raw', loadRaw], ['opt', loadOpt], ['doc', loadDoc]]) {
+  for (const [type, load] of [
+    ['raw', loadRaw],
+    ['opt', loadOpt],
+    ['doc', loadDoc],
+  ]) {
     if (!load) continue;
 
     const resArr = [];
@@ -265,9 +380,21 @@ export async function setUploadFontsWorker(scheduler) {
   /** @type {Object<string, fontSrcBuiltIn|fontSrcUpload>} */
   const fontsUpload = {};
   for (const [key, value] of Object.entries(FontCont.active)) {
-    if (!['Carlito', 'Century', 'Garamond', 'Palatino', 'NimbusRomNo9L', 'NimbusSans', 'NimbusMono'].includes(key)) {
+    if (
+      ![
+        'Carlito',
+        'Century',
+        'Garamond',
+        'Palatino',
+        'NimbusRomNo9L',
+        'NimbusSans',
+        'NimbusMono',
+      ].includes(key)
+    ) {
       fontsUpload[key] = {
-        normal: value?.normal?.src, italic: value?.italic?.src, bold: value?.bold?.src,
+        normal: value?.normal?.src,
+        italic: value?.italic?.src,
+        bold: value?.bold?.src,
       };
     }
   }
@@ -287,7 +414,9 @@ export async function setUploadFontsWorker(scheduler) {
 
   // Set the active font in the workers to match the active font in `fontAll`
   const resArr = [];
-  const opt = FontCont.active.Carlito.normal.opt || FontCont.active.NimbusRomNo9L.normal.opt;
+  const opt =
+    FontCont.active.Carlito.normal.opt ||
+    FontCont.active.NimbusRomNo9L.normal.opt;
   for (let i = 0; i < scheduler.workers.length; i++) {
     const worker = scheduler.workers[i];
     const res = worker.updateFontContWorker({
@@ -315,7 +444,10 @@ export function setDefaultFontAuto(fontMetricsObj) {
   if (!multiFontMode) return;
 
   // Change default font to whatever named font appears more
-  if ((fontMetricsObj.SerifDefault?.obs || 0) > (fontMetricsObj.SansDefault?.obs || 0)) {
+  if (
+    (fontMetricsObj.SerifDefault?.obs || 0) >
+    (fontMetricsObj.SansDefault?.obs || 0)
+  ) {
     FontCont.defaultFontName = 'SerifDefault';
   } else {
     FontCont.defaultFontName = 'SansDefault';
@@ -324,7 +456,9 @@ export function setDefaultFontAuto(fontMetricsObj) {
   if (gs.schedulerInner) {
     for (let i = 0; i < gs.schedulerInner.workers.length; i++) {
       const worker = gs.schedulerInner.workers[i];
-      worker.updateFontContWorker({ defaultFontName: FontCont.defaultFontName });
+      worker.updateFontContWorker({
+        defaultFontName: FontCont.defaultFontName,
+      });
     }
   }
 }
@@ -349,31 +483,61 @@ export async function optimizeFontContainerFamily(fontFamily, fontMetricsObj) {
 
   // If there are no statistics to use for optimization, create "optimized" font by simply copying the raw font without modification.
   // This should only occur when `multiFontMode` is true, but a document contains no sans words or no serif words.
-  if (!fontMetricsObj[fontMetricsType] || !fontMetricsObj[fontMetricsType][fontFamily.normal.style] || fontMetricsObj[fontMetricsType][fontFamily.normal.style].obs < 200) {
+  if (
+    !fontMetricsObj[fontMetricsType] ||
+    !fontMetricsObj[fontMetricsType][fontFamily.normal.style] ||
+    fontMetricsObj[fontMetricsType][fontFamily.normal.style].obs < 200
+  ) {
     return null;
   }
 
-  const metricsNormal = fontMetricsObj[fontMetricsType][fontFamily.normal.style];
-  const normalOptFont = gs.optimizeFont({ fontData: fontFamily.normal.src, fontMetricsObj: metricsNormal, style: fontFamily.normal.style })
+  const metricsNormal =
+    fontMetricsObj[fontMetricsType][fontFamily.normal.style];
+  const normalOptFont = gs
+    .optimizeFont({
+      fontData: fontFamily.normal.src,
+      fontMetricsObj: metricsNormal,
+      style: fontFamily.normal.style,
+    })
     .then(async (x) => {
       const font = await loadOpentype(x.fontData, x.kerningPairs);
-      return new FontContainerFont(fontFamily.normal.family, fontFamily.normal.style, x.fontData, true, font);
+      return new FontContainerFont(
+        fontFamily.normal.family,
+        fontFamily.normal.style,
+        x.fontData,
+        true,
+        font
+      );
     });
 
-  const metricsItalic = fontMetricsObj[fontMetricsType][fontFamily.italic.style];
+  const metricsItalic =
+    fontMetricsObj[fontMetricsType][fontFamily.italic.style];
   /** @type {?FontContainerFont|Promise<FontContainerFont>} */
   let italicOptFont = null;
   if (metricsItalic && metricsItalic.obs >= 200) {
-    italicOptFont = gs.optimizeFont({ fontData: fontFamily.italic.src, fontMetricsObj: metricsItalic, style: fontFamily.italic.style })
+    italicOptFont = gs
+      .optimizeFont({
+        fontData: fontFamily.italic.src,
+        fontMetricsObj: metricsItalic,
+        style: fontFamily.italic.style,
+      })
       .then(async (x) => {
         const font = await loadOpentype(x.fontData, x.kerningPairs);
-        return new FontContainerFont(fontFamily.italic.family, fontFamily.italic.style, x.fontData, true, font);
+        return new FontContainerFont(
+          fontFamily.italic.family,
+          fontFamily.italic.style,
+          x.fontData,
+          true,
+          font
+        );
       });
   }
 
   // Bold fonts are not optimized, as we currently have no accurate way to determine if characters are bold within OCR, so do not have bold metrics.
   return {
-    normal: await normalOptFont, italic: await italicOptFont, bold: null,
+    normal: await normalOptFont,
+    italic: await italicOptFont,
+    bold: null,
   };
 }
 
@@ -384,15 +548,44 @@ export async function optimizeFontContainerFamily(fontFamily, fontMetricsObj) {
  * @param {Object.<string, FontMetricsFamily>} fontMetricsObj
  */
 export async function optimizeFontContainerAll(fontPrivate, fontMetricsObj) {
-  const carlitoPromise = optimizeFontContainerFamily(fontPrivate.Carlito, fontMetricsObj);
-  const centuryPromise = optimizeFontContainerFamily(fontPrivate.Century, fontMetricsObj);
-  const garamondPromise = optimizeFontContainerFamily(fontPrivate.Garamond, fontMetricsObj);
-  const palatinoPromise = optimizeFontContainerFamily(fontPrivate.Palatino, fontMetricsObj);
-  const nimbusRomNo9LPromise = optimizeFontContainerFamily(fontPrivate.NimbusRomNo9L, fontMetricsObj);
-  const nimbusSansPromise = optimizeFontContainerFamily(fontPrivate.NimbusSans, fontMetricsObj);
-  const nimbusMonoPromise = optimizeFontContainerFamily(fontPrivate.NimbusMono, fontMetricsObj);
-
-  const results = await Promise.all([carlitoPromise, centuryPromise, garamondPromise, palatinoPromise, nimbusRomNo9LPromise, nimbusSansPromise, nimbusMonoPromise]);
+  const carlitoPromise = optimizeFontContainerFamily(
+    fontPrivate.Carlito,
+    fontMetricsObj
+  );
+  const centuryPromise = optimizeFontContainerFamily(
+    fontPrivate.Century,
+    fontMetricsObj
+  );
+  const garamondPromise = optimizeFontContainerFamily(
+    fontPrivate.Garamond,
+    fontMetricsObj
+  );
+  const palatinoPromise = optimizeFontContainerFamily(
+    fontPrivate.Palatino,
+    fontMetricsObj
+  );
+  const nimbusRomNo9LPromise = optimizeFontContainerFamily(
+    fontPrivate.NimbusRomNo9L,
+    fontMetricsObj
+  );
+  const nimbusSansPromise = optimizeFontContainerFamily(
+    fontPrivate.NimbusSans,
+    fontMetricsObj
+  );
+  const nimbusMonoPromise = optimizeFontContainerFamily(
+    fontPrivate.NimbusMono,
+    fontMetricsObj
+  );
+
+  const results = await Promise.all([
+    carlitoPromise,
+    centuryPromise,
+    garamondPromise,
+    palatinoPromise,
+    nimbusRomNo9LPromise,
+    nimbusSansPromise,
+    nimbusMonoPromise,
+  ]);
 
   if (results.every((x) => x === null)) return null;
 
diff --git a/js/generalWorkerMain.js b/js/generalWorkerMain.js
index 111244795bb4fdc6c21db3775d02cf74d1d18de1..12fd630c1b81addc2a6c9b4ac887365c9e8d0625 100644
--- a/js/generalWorkerMain.js
+++ b/js/generalWorkerMain.js
@@ -9,31 +9,26 @@ export async function initGeneralWorker() {
   // Do not change without confirming compatibility with all three.
   const obj = {};
   let worker;
-  if (typeof process === 'undefined') {
-    worker = new Worker(new URL('./worker/generalWorker.js', import.meta.url), { type: 'module' });
-  } else {
-    const WorkerNode = (await import('worker_threads')).Worker;
-    worker = new WorkerNode(new URL('./worker/generalWorker.js', import.meta.url));
-  }
+  worker = new Worker(new URL('./worker/generalWorker.js', import.meta.url), {
+    type: 'module',
+  });
 
   return new Promise((resolve, reject) => {
     const errorHandler = (err) => {
       console.error(err);
     };
 
-    if (typeof process === 'undefined') {
-      // @ts-ignore
-      worker.onerror = errorHandler;
-    } else {
-      // @ts-ignore
-      worker.on('error', errorHandler);
-    }
+    worker.onerror = errorHandler;
 
     const workerPromises = {};
     let promiseId = 0;
 
     const ready = new Promise((innerResolve, innerReject) => {
-      workerPromises['0'] = { resolve: innerResolve, reject: innerReject, func: 'ready' };
+      workerPromises['0'] = {
+        resolve: innerResolve,
+        reject: innerReject,
+        func: 'ready',
+      };
     });
 
     const messageHandler = async (data) => {
@@ -48,43 +43,49 @@ export async function initGeneralWorker() {
       }
     };
 
-    if (typeof process === 'undefined') {
-      // @ts-ignore
-      worker.onmessage = (event) => messageHandler(event.data);
-    } else {
-      // @ts-ignore
-      worker.on('message', messageHandler);
-    }
+    worker.onmessage = (event) => messageHandler(event.data);
 
     /**
-       * Wraps a function to be called via worker messages.
-       * @param {string} func The function name to call.
-       * @returns {Function} A function that returns a promise resolving to the worker's response.
-       */
+     * Wraps a function to be called via worker messages.
+     * @param {string} func The function name to call.
+     * @returns {Function} A function that returns a promise resolving to the worker's response.
+     */
     function wrap(func) {
       return function (...args) {
         return new Promise((innerResolve, innerReject) => {
           const id = promiseId++;
-          workerPromises[id] = { resolve: innerResolve, reject: innerReject, func };
+          workerPromises[id] = {
+            resolve: innerResolve,
+            reject: innerReject,
+            func,
+          };
           worker.postMessage([func, args[0], id]);
         });
       };
     }
 
     /**
-       * Similar to wrap, but handles two promises.
-       * @param {string} func The function name to call.
-       * @returns {Array} Returns two promises in an array.
-       */
+     * Similar to wrap, but handles two promises.
+     * @param {string} func The function name to call.
+     * @returns {Array} Returns two promises in an array.
+     */
     function wrap2(func) {
       return function (...args) {
         const id = promiseId++;
         const promiseB = new Promise((innerResolve, innerReject) => {
-          workerPromises[`${id}b`] = { resolve: innerResolve, reject: innerReject, func };
+          workerPromises[`${id}b`] = {
+            resolve: innerResolve,
+            reject: innerReject,
+            func,
+          };
         });
 
         const promiseA = new Promise((innerResolve, innerReject) => {
-          workerPromises[id] = { resolve: innerResolve, reject: innerReject, func };
+          workerPromises[id] = {
+            resolve: innerResolve,
+            reject: innerReject,
+            func,
+          };
           worker.postMessage([func, args[0], id]);
         });
 
@@ -160,91 +161,103 @@ export class gs {
    * @param {Parameters<typeof import('./worker/compareOCRModule.js').compareOCRPageImp>[0]} args
    * @returns {ReturnType<typeof import('./worker/compareOCRModule.js').compareOCRPageImp>}
    */
-  static compareOCRPageImp = async (args) => await gs.schedulerInner.addJob('compareOCRPageImp', args);
+  static compareOCRPageImp = async (args) =>
+    await gs.schedulerInner.addJob('compareOCRPageImp', args);
 
   /**
    * @param {Parameters<typeof import('./import/convertPageHocr.js').convertPageHocr>[0]} args
    * @returns {ReturnType<typeof import('./import/convertPageHocr.js').convertPageHocr>}
    */
-  static convertPageHocr = async (args) => (await gs.schedulerInner.addJob('convertPageHocr', args));
+  static convertPageHocr = async (args) =>
+    await gs.schedulerInner.addJob('convertPageHocr', args);
 
   /**
    * @param {Parameters<typeof import('./import/convertPageAbbyy.js').convertPageAbbyy>[0]} args
    * @returns {ReturnType<typeof import('./import/convertPageAbbyy.js').convertPageAbbyy>}
    */
-  static convertPageAbbyy = async (args) => (await gs.schedulerInner.addJob('convertPageAbbyy', args));
+  static convertPageAbbyy = async (args) =>
+    await gs.schedulerInner.addJob('convertPageAbbyy', args);
 
   /**
    * @param {Parameters<typeof import('./import/convertPageStext.js').convertPageStext>[0]} args
    * @returns {ReturnType<typeof import('./import/convertPageStext.js').convertPageStext>}
    */
-  static convertPageStext = async (args) => (await gs.schedulerInner.addJob('convertPageStext', args));
+  static convertPageStext = async (args) =>
+    await gs.schedulerInner.addJob('convertPageStext', args);
 
   /**
    * @param {Parameters<typeof import('./worker/optimizeFontModule.js').optimizeFont>[0]} args
    * @returns {ReturnType<typeof import('./worker/optimizeFontModule.js').optimizeFont>}
    */
-  static optimizeFont = async (args) => (await gs.schedulerInner.addJob('optimizeFont', args));
+  static optimizeFont = async (args) =>
+    await gs.schedulerInner.addJob('optimizeFont', args);
 
   /**
-  * @template {Partial<Tesseract.OutputFormats>} TO
-  * @param {Object} args
-  * @param {Parameters<Tesseract.Worker['recognize']>[0]} args.image
-  * @param {Parameters<Tesseract.Worker['recognize']>[1]} args.options
-  * @param {TO} args.output
-  * @returns {Promise<Tesseract.Page<TO>>}
-  * Exported for type inference purposes, should not be imported anywhere.
-  */
-  static recognize = async (args) => (await gs.schedulerInner.addJob('recognize', args));
+   * @template {Partial<Tesseract.OutputFormats>} TO
+   * @param {Object} args
+   * @param {Parameters<Tesseract.Worker['recognize']>[0]} args.image
+   * @param {Parameters<Tesseract.Worker['recognize']>[1]} args.options
+   * @param {TO} args.output
+   * @returns {Promise<Tesseract.Page<TO>>}
+   * Exported for type inference purposes, should not be imported anywhere.
+   */
+  static recognize = async (args) =>
+    await gs.schedulerInner.addJob('recognize', args);
 
   /**
    * @param {Parameters<typeof import('./worker/generalWorker.js').recognizeAndConvert>[0]} args
    * @returns {ReturnType<typeof import('./worker/generalWorker.js').recognizeAndConvert>}
    */
-  static recognizeAndConvert = async (args) => (await gs.schedulerInner.addJob('recognizeAndConvert', args));
+  static recognizeAndConvert = async (args) =>
+    await gs.schedulerInner.addJob('recognizeAndConvert', args);
 
   /**
    * @param {Parameters<typeof import('./worker/generalWorker.js').recognizeAndConvert2>[0]} args
    * @returns {Promise<[ReturnType<typeof import('./worker/generalWorker.js').recognizeAndConvert>, ReturnType<typeof import('./worker/generalWorker.js').recognizeAndConvert>]>}
    */
-  static recognizeAndConvert2 = async (args) => (await gs.schedulerInner.addJob('recognizeAndConvert2', args));
+  static recognizeAndConvert2 = async (args) =>
+    await gs.schedulerInner.addJob('recognizeAndConvert2', args);
 
   /**
    * @param {Parameters<typeof import('./worker/compareOCRModule.js').evalPageBase>[0]} args
    * @returns {ReturnType<typeof import('./worker/compareOCRModule.js').evalPageBase>}
    */
-  static evalPageBase = async (args) => await gs.schedulerInner.addJob('evalPageBase', args);
+  static evalPageBase = async (args) =>
+    await gs.schedulerInner.addJob('evalPageBase', args);
 
   /**
    * @param {Parameters<typeof import('./worker/compareOCRModule.js').evalWords>[0]} args
    * @returns {ReturnType<typeof import('./worker/compareOCRModule.js').evalWords>}
    */
-  static evalWords = async (args) => (await gs.schedulerInner.addJob('evalWords', args));
+  static evalWords = async (args) =>
+    await gs.schedulerInner.addJob('evalWords', args);
 
   /**
    * @param {Parameters<typeof import('./worker/compareOCRModule.js').evalPageFont>[0]} args
    * @returns {ReturnType<typeof import('./worker/compareOCRModule.js').evalPageFont>}
    */
-  static evalPageFont = async (args) => await gs.schedulerInner.addJob('evalPageFont', args);
+  static evalPageFont = async (args) =>
+    await gs.schedulerInner.addJob('evalPageFont', args);
 
   /**
    * @param {Parameters<typeof import('./worker/compareOCRModule.js').renderPageStaticImp>[0]} args
    * @returns {ReturnType<typeof import('./worker/compareOCRModule.js').renderPageStaticImp>}
    */
-  static renderPageStaticImp = async (args) => (await gs.schedulerInner.addJob('renderPageStaticImp', args));
+  static renderPageStaticImp = async (args) =>
+    await gs.schedulerInner.addJob('renderPageStaticImp', args);
 
   static init = async () => {
     let workerN;
     if (opt.workerN) {
       workerN = opt.workerN;
-    } else if (typeof process === 'undefined') {
-      workerN = Math.min(Math.round((globalThis.navigator.hardwareConcurrency || 8) / 2), 6);
     } else {
-      const cpuN = Math.floor((await import('os')).cpus().length / 2);
-      workerN = Math.min(cpuN - 1, 8);
+      workerN = Math.min(
+        Math.round((globalThis.navigator.hardwareConcurrency || 8) / 2),
+        6
+      );
     }
 
-    const Tesseract = typeof process === 'undefined' ? (await import('../tess/tesseract.esm.min.js')).default : await import('@scribe.js/tesseract.js');
+    const Tesseract = (await import('../tess/tesseract.esm.min.js')).default;
 
     gs.schedulerInner = await Tesseract.createScheduler();
     gs.schedulerInner.workers = new Array(workerN);
@@ -261,7 +274,9 @@ export class gs {
     // data will be loaded over network from all workers (rather than downloading once and caching).
     await addGeneralWorker(0);
 
-    const resArr = Array.from({ length: workerN }, (v, k) => k).slice(1).map((i) => addGeneralWorker(i));
+    const resArr = Array.from({ length: workerN }, (v, k) => k)
+      .slice(1)
+      .map((i) => addGeneralWorker(i));
 
     await Promise.all(resArr);
 
@@ -280,7 +295,10 @@ export class gs {
    * @returns
    */
   static initTesseract = async ({
-    anyOk = true, vanillaMode = false, langs = ['eng'], config = {},
+    anyOk = true,
+    vanillaMode = false,
+    langs = ['eng'],
+    config = {},
   }) => {
     await gs.schedulerReady;
 
@@ -299,7 +317,9 @@ export class gs {
     await worker0.reinitialize({ langs, vanillaMode, config });
 
     if (gs.schedulerInner.workers.length > 0) {
-      const resArr = gs.schedulerInner.workers.slice(1).map((x) => x.reinitialize({ langs, vanillaMode, config }));
+      const resArr = gs.schedulerInner.workers
+        .slice(1)
+        .map((x) => x.reinitialize({ langs, vanillaMode, config }));
       await Promise.allSettled(resArr);
     }
     // @ts-ignore
diff --git a/js/import/import.js b/js/import/import.js
index decd81adb7da4822946160f7029d9910a96697e2..e88bbcce61e9705b78399239b2d8ec18d1a45d3f 100644
--- a/js/import/import.js
+++ b/js/import/import.js
@@ -15,7 +15,8 @@ import { extractInternalPDFText } from '../extractPDFText.js';
 import {
   enableFontOpt,
   loadBuiltInFontsRaw,
-  optimizeFontContainerAll, setDefaultFontAuto,
+  optimizeFontContainerAll,
+  setDefaultFontAuto,
 } from '../fontContainerMain.js';
 import { runFontOptimization } from '../fontEval.js';
 import { calcFontMetricsFromPages } from '../fontStatistics.js';
@@ -34,9 +35,10 @@ import { importOCRFiles } from './importOCR.js';
  * @returns {('jpeg'|'png')}
  */
 const detectImageFormat = (image) => {
-  if (image[0] === 0xFF && image[1] === 0xD8) {
+  if (image[0] === 0xff && image[1] === 0xd8) {
     return 'jpeg';
-  } if (image[0] === 0x89 && image[1] === 0x50) {
+  }
+  if (image[0] === 0x89 && image[1] === 0x50) {
     return 'png';
   }
   throw new Error('Unsupported image type');
@@ -47,41 +49,34 @@ const detectImageFormat = (image) => {
  * @param {File|FileNode|ArrayBuffer} file
  * @returns {Promise<string>}
  */
-const importImageFile = async (file) => new Promise((resolve, reject) => {
-  if (file instanceof ArrayBuffer) {
-    const imageUint8 = new Uint8Array(file);
-    const format = detectImageFormat(imageUint8);
-    const binary = String.fromCharCode(...imageUint8);
-    resolve(`data:image/${format};base64,${btoa(binary)}`);
-    return;
-  }
-
-  // The `typeof process` condition is necessary to avoid error in Node.js versions <20, where `File` is not defined.
-  if (typeof process === 'undefined' && file instanceof File) {
-    const reader = new FileReader();
+const importImageFile = async (file) =>
+  new Promise((resolve, reject) => {
+    if (file instanceof ArrayBuffer) {
+      const imageUint8 = new Uint8Array(file);
+      const format = detectImageFormat(imageUint8);
+      const binary = String.fromCharCode(...imageUint8);
+      resolve(`data:image/${format};base64,${btoa(binary)}`);
+      return;
+    }
 
-    reader.onloadend = async () => {
-      resolve(/** @type {string} */(reader.result));
-    };
+    // The `typeof process` condition is necessary to avoid error in Node.js versions <20, where `File` is not defined.
+    if (file instanceof File) {
+      const reader = new FileReader();
 
-    reader.onerror = (error) => {
-      reject(error);
-    };
+      reader.onloadend = async () => {
+        resolve(/** @type {string} */ (reader.result));
+      };
 
-    reader.readAsDataURL(file);
-    return;
-  }
+      reader.onerror = (error) => {
+        reject(error);
+      };
 
-  if (typeof process !== 'undefined') {
-    if (!file?.name) reject(new Error('Invalid input. Must be a FileNode or ArrayBuffer.'));
-    const format = file.name.match(/jpe?g$/i) ? 'jpeg' : 'png';
-    // @ts-ignore
-    resolve(`data:image/${format};base64,${file.fileData.toString('base64')}`);
-    return;
-  }
+      reader.readAsDataURL(file);
+      return;
+    }
 
-  reject(new Error('Invalid input. Must be a File or ArrayBuffer.'));
-});
+    reject(new Error('Invalid input. Must be a File or ArrayBuffer.'));
+  });
 
 /**
  * Standardize file-like inputs between platforms.
@@ -93,19 +88,16 @@ const importImageFile = async (file) => new Promise((resolve, reject) => {
  */
 export async function standardizeFiles(files) {
   if (typeof files[0] === 'string') {
-    if (typeof process !== 'undefined') {
-      const { wrapFilesNode } = await import('./nodeAdapter.js');
-      return wrapFilesNode(/** @type {Array<string>} */(files));
-    }
-
     // Fetch all URLs and convert the responses to Blobs
-    const blobPromises = files.map((url) => fetch(url).then((response) => {
-      if (!response.ok) {
-        console.log(response);
-        throw new Error(`Failed to fetch ${url}: ${response.statusText}`);
-      }
-      return response.blob().then((blob) => ({ blob, url }));
-    }));
+    const blobPromises = files.map((url) =>
+      fetch(url).then((response) => {
+        if (!response.ok) {
+          console.log(response);
+          throw new Error(`Failed to fetch ${url}: ${response.statusText}`);
+        }
+        return response.blob().then((blob) => ({ blob, url }));
+      })
+    );
 
     // Wait for all fetches to complete
     const blobsAndUrls = await Promise.all(blobPromises);
@@ -114,7 +106,8 @@ export async function standardizeFiles(files) {
     return blobsAndUrls.map(({ blob, url }) => {
       const fileName = url.split('/').pop();
       // A valid filename is necessary, as the import function uses the filename.
-      if (!fileName) throw new Error(`Failed to extract file name from URL: ${url}`);
+      if (!fileName)
+        throw new Error(`Failed to extract file name from URL: ${url}`);
       return new File([blob], fileName, { type: blob.type });
     });
   }
@@ -165,14 +158,22 @@ export function sortInputFiles(files) {
   }
 
   if (unsupportedFilesAll.length > 0) {
-    const errorText = `Import includes unsupported file types: ${Object.keys(unsupportedExt).join(', ')}`;
+    const errorText = `Import includes unsupported file types: ${Object.keys(
+      unsupportedExt
+    ).join(', ')}`;
     opt.warningHandler(errorText);
   }
 
-  imageFilesAll.sort((a, b) => ((a.name > b.name) ? 1 : ((b.name > a.name) ? -1 : 0)));
-  ocrFilesAll.sort((a, b) => ((a.name > b.name) ? 1 : ((b.name > a.name) ? -1 : 0)));
+  imageFilesAll.sort((a, b) =>
+    a.name > b.name ? 1 : b.name > a.name ? -1 : 0
+  );
+  ocrFilesAll.sort((a, b) => (a.name > b.name ? 1 : b.name > a.name ? -1 : 0));
 
-  return { pdfFiles: pdfFilesAll, imageFiles: imageFilesAll, ocrFiles: ocrFilesAll };
+  return {
+    pdfFiles: pdfFilesAll,
+    imageFiles: imageFilesAll,
+    ocrFiles: ocrFilesAll,
+  };
 }
 
 /**
@@ -232,21 +233,29 @@ export async function importFiles(files) {
   } else {
     // @ts-ignore
     const filesStand = await standardizeFiles(files);
-    if (files[0] instanceof ArrayBuffer) throw new Error('ArrayBuffer inputs must be sorted by file type.');
+    if (files[0] instanceof ArrayBuffer)
+      throw new Error('ArrayBuffer inputs must be sorted by file type.');
     ({ pdfFiles, imageFiles, ocrFiles } = sortInputFiles(filesStand));
   }
 
-  if (pdfFiles.length === 0 && imageFiles.length === 0 && ocrFiles.length === 0) {
+  if (
+    pdfFiles.length === 0 &&
+    imageFiles.length === 0 &&
+    ocrFiles.length === 0
+  ) {
     const errorText = 'No supported files found.';
     opt.errorHandler(errorText);
     return;
-  } if (pdfFiles.length > 0 && imageFiles.length > 0) {
-    const errorText = 'PDF and image files cannot be imported together. Only first PDF file will be imported.';
+  }
+  if (pdfFiles.length > 0 && imageFiles.length > 0) {
+    const errorText =
+      'PDF and image files cannot be imported together. Only first PDF file will be imported.';
     opt.warningHandler(errorText);
     pdfFiles.length = 1;
     imageFiles.length = 0;
   } else if (pdfFiles.length > 1) {
-    const errorText = 'Multiple PDF files are not supported. Only first PDF file will be imported.';
+    const errorText =
+      'Multiple PDF files are not supported. Only first PDF file will be imported.';
     opt.warningHandler(errorText);
     pdfFiles.length = 1;
     imageFiles.length = 0;
@@ -261,11 +270,20 @@ export async function importFiles(files) {
 
   // Set default download name
   if (pdfFiles.length > 0 && 'name' in pdfFiles[0]) {
-    inputData.defaultDownloadFileName = `${pdfFiles[0].name.replace(/\.\w{1,4}$/, '')}.pdf`;
+    inputData.defaultDownloadFileName = `${pdfFiles[0].name.replace(
+      /\.\w{1,4}$/,
+      ''
+    )}.pdf`;
   } else if (imageFiles.length > 0 && 'name' in imageFiles[0]) {
-    inputData.defaultDownloadFileName = `${imageFiles[0].name.replace(/\.\w{1,4}$/, '')}.pdf`;
+    inputData.defaultDownloadFileName = `${imageFiles[0].name.replace(
+      /\.\w{1,4}$/,
+      ''
+    )}.pdf`;
   } else if (ocrFiles.length > 0 && 'name' in ocrFiles[0]) {
-    inputData.defaultDownloadFileName = `${ocrFiles[0].name.replace(/\.\w{1,4}$/, '')}.pdf`;
+    inputData.defaultDownloadFileName = `${ocrFiles[0].name.replace(
+      /\.\w{1,4}$/,
+      ''
+    )}.pdf`;
   }
 
   inputData.pdfMode = pdfFiles.length === 1;
@@ -285,7 +303,8 @@ export async function importFiles(files) {
     // Start loading mupdf workers as soon as possible, without waiting for `pdfFile.arrayBuffer` (which can take a while).
     ImageCache.getMuPDFScheduler();
 
-    ImageCache.pdfData = pdfFile instanceof ArrayBuffer ? pdfFile : await pdfFile.arrayBuffer();
+    ImageCache.pdfData =
+      pdfFile instanceof ArrayBuffer ? pdfFile : await pdfFile.arrayBuffer();
 
     // If no XML data is provided, page sizes are calculated using muPDF alone
     await ImageCache.openMainPDF(ImageCache.pdfData, opt.omitNativeText);
@@ -313,12 +332,17 @@ export async function importFiles(files) {
     // While this should be rare, it appears to be fairly common with Archive.org documents.
     // TODO: Add warning message displayed to user for this.
     if (pageCountImage && ocrAllRaw.active.length > pageCountImage) {
-      console.log(`Identified ${ocrAllRaw.active.length} pages of OCR data but ${pageCountImage} pages of image/pdf data. Only first ${pageCountImage} pages will be used.`);
+      console.log(
+        `Identified ${ocrAllRaw.active.length} pages of OCR data but ${pageCountImage} pages of image/pdf data. Only first ${pageCountImage} pages will be used.`
+      );
       ocrAllRaw.active = ocrAllRaw.active.slice(0, pageCountImage);
     }
 
     // Restore font metrics and optimize font from previous session (if applicable)
-    if (ocrData.fontMetricsObj && Object.keys(ocrData.fontMetricsObj).length > 0) {
+    if (
+      ocrData.fontMetricsObj &&
+      Object.keys(ocrData.fontMetricsObj).length > 0
+    ) {
       const fontPromise = loadBuiltInFontsRaw();
 
       existingOpt = true;
@@ -336,7 +360,10 @@ export async function importFiles(files) {
       } else {
         await fontPromise;
         if (!FontCont.raw) throw new Error('Raw font data not found.');
-        FontCont.opt = await optimizeFontContainerAll(FontCont.raw, fontMetricsObj);
+        FontCont.opt = await optimizeFontContainerAll(
+          FontCont.raw,
+          fontMetricsObj
+        );
         FontCont.enableOpt = true;
         await enableFontOpt(true);
       }
@@ -405,20 +432,28 @@ export async function importFiles(files) {
 
   // Render first page for PDF only
   if (inputData.pdfMode && !xmlModeImport) {
-    opt.progressHandler({ n: 0, type: 'importPDF', info: { } });
+    opt.progressHandler({ n: 0, type: 'importPDF', info: {} });
   }
 
   if (inputData.imageMode) {
     ImageCache.pageCount = inputData.pageCount;
     for (let i = 0; i < inputData.pageCount; i++) {
-      ImageCache.nativeSrc[i] = await importImageFile(imageFiles[i]).then(async (imgStr) => {
-        const imgWrapper = new ImageWrapper(i, imgStr, 'native', false, false);
-        const imageDims = await imageUtils.getDims(imgWrapper);
-        pageMetricsArr[i] = new PageMetrics(imageDims);
-        return imgWrapper;
-      });
+      ImageCache.nativeSrc[i] = await importImageFile(imageFiles[i]).then(
+        async (imgStr) => {
+          const imgWrapper = new ImageWrapper(
+            i,
+            imgStr,
+            'native',
+            false,
+            false
+          );
+          const imageDims = await imageUtils.getDims(imgWrapper);
+          pageMetricsArr[i] = new PageMetrics(imageDims);
+          return imgWrapper;
+        }
+      );
       ImageCache.loadCount++;
-      opt.progressHandler({ n: i, type: 'importImage', info: { } });
+      opt.progressHandler({ n: i, type: 'importImage', info: {} });
     }
   }
 
@@ -429,17 +464,28 @@ export async function importFiles(files) {
     if (stextMode) format = 'stext';
 
     // Process HOCR using web worker, reading from file first if that has not been done already
-    await convertOCR(ocrAllRaw.active, true, format, oemName, scribeMode).then(async () => {
-      // Skip this step if optimization info was already restored from a previous session, or if using stext (which is character-level but not visually accurate).
-      if (!existingOpt && !stextMode) {
-        await checkCharWarn(convertPageWarn);
-        calcFontMetricsFromPages(ocrAll.active);
-        await runFontOptimization(ocrAll.active);
+    await convertOCR(ocrAllRaw.active, true, format, oemName, scribeMode).then(
+      async () => {
+        // Skip this step if optimization info was already restored from a previous session, or if using stext (which is character-level but not visually accurate).
+        if (!existingOpt && !stextMode) {
+          await checkCharWarn(convertPageWarn);
+          calcFontMetricsFromPages(ocrAll.active);
+          await runFontOptimization(ocrAll.active);
+        }
       }
-    });
-  } else if (inputData.pdfMode && (opt.usePDFText.native.main || opt.usePDFText.native.supp || opt.usePDFText.ocr.main || opt.usePDFText.ocr.supp)) {
+    );
+  } else if (
+    inputData.pdfMode &&
+    (opt.usePDFText.native.main ||
+      opt.usePDFText.native.supp ||
+      opt.usePDFText.ocr.main ||
+      opt.usePDFText.ocr.supp)
+  ) {
     await extractInternalPDFText();
-    if (inputData.pdfType === 'text' && opt.usePDFText.native.main || inputData.pdfType === 'ocr' && opt.usePDFText.ocr.main) {
+    if (
+      (inputData.pdfType === 'text' && opt.usePDFText.native.main) ||
+      (inputData.pdfType === 'ocr' && opt.usePDFText.ocr.main)
+    ) {
       if (inputData.pdfType === 'text') FontCont.enableCleanToNimbusMono = true;
       if (opt.calcSuppFontInfo) await calcSuppFontInfo(ocrAll.pdf);
     }
@@ -463,7 +509,7 @@ export async function importFilesSupp(files, ocrName) {
   const ocrFilesAll = [];
   for (let i = 0; i < curFiles.length; i++) ocrFilesAll.push(curFiles[i]);
 
-  ocrFilesAll.sort((a, b) => ((a.name > b.name) ? 1 : ((b.name > a.name) ? -1 : 0)));
+  ocrFilesAll.sort((a, b) => (a.name > b.name ? 1 : b.name > a.name ? -1 : 0));
 
   const ocrData = await importOCRFiles(ocrFilesAll);
 
diff --git a/js/import/nodeAdapter.js b/js/import/nodeAdapter.js
deleted file mode 100644
index 22db36ad8103005fa5d36a9e628ba605184a607f..0000000000000000000000000000000000000000
--- a/js/import/nodeAdapter.js
+++ /dev/null
@@ -1,50 +0,0 @@
-import fs from 'fs';
-import path from 'path';
-
-// Note: Node.js 20 added a File class in the `buffer` module in Node.js 20.0.0,
-// so this class can eventually be replaced with that.
-
-/**
- * Class representing a simplified version of the File interface for Node.js.
- */
-export class FileNode {
-  /**
-     * Creates an instance of the File class.
-     * @param {string} filePath - The path to the file.
-     * @param {string} name - The name of the file.
-     * @param {Buffer} fileData - The file's data.
-     */
-  constructor(filePath, name, fileData) {
-    this.filePath = filePath;
-    this.name = name;
-    this.fileData = fileData;
-  }
-
-  /**
-     * Returns an ArrayBuffer with the file's contents.
-     * @returns {Promise<ArrayBuffer>} A promise that resolves with the file's contents as an ArrayBuffer.
-     */
-  async arrayBuffer() {
-    return this.fileData.buffer.slice(this.fileData.byteOffset, this.fileData.byteOffset + this.fileData.byteLength);
-  }
-}
-
-/**
- *
- * @param {Array<string>} filePaths
- * @returns
- */
-export const wrapFilesNode = (filePaths) => {
-  const filePromises = filePaths.map(async (filePath) => {
-    const isUrl = filePath.startsWith('http://') || filePath.startsWith('https://') || filePath.startsWith('moz-extension://')
-    || filePath.startsWith('chrome-extension://') || filePath.startsWith('file://');
-
-    const fileData = isUrl ? Buffer.from(await fetch(filePath).then((res) => res.arrayBuffer())) : fs.readFileSync(filePath);
-
-    const fileName = isUrl ? filePath.split('/').pop() : path.basename(filePath);
-
-    return new FileNode(filePath, fileName, fileData);
-  });
-
-  return Promise.all(filePromises);
-};
diff --git a/js/recognizeConvert.js b/js/recognizeConvert.js
index d7e98ad06b14df1ccbc5806de1911fa6f46a23f2..c54f38fc64f28d118435dd8a06831d811d789cf6 100644
--- a/js/recognizeConvert.js
+++ b/js/recognizeConvert.js
@@ -1,9 +1,12 @@
-import { ca } from './canvasAdapter.js';
+// import { ca } from './canvasAdapter.js';
 import { inputData, opt } from './containers/app.js';
 import {
   convertPageWarn,
   DebugData,
-  layoutDataTables, ocrAll, pageMetricsArr, visInstructions,
+  layoutDataTables,
+  ocrAll,
+  pageMetricsArr,
+  visInstructions,
 } from './containers/dataContainer.js';
 import { ImageCache, ImageWrapper } from './containers/imageContainer.js';
 import { loadBuiltInFontsRaw, loadChiSimFont } from './fontContainerMain.js';
@@ -32,13 +35,19 @@ export const compareOCRPage = async (pageA, pageB, options) => {
   const mode = options?.mode || 'stats';
   const evalConflicts = options?.evalConflicts ?? true;
   const supplementComp = options?.supplementComp ?? false;
-  const skipImage = (mode === 'stats' && !supplementComp) || (mode === 'comb' && !evalConflicts && !supplementComp);
+  const skipImage =
+    (mode === 'stats' && !supplementComp) ||
+    (mode === 'comb' && !evalConflicts && !supplementComp);
 
   const binaryImage = skipImage ? null : await ImageCache.getBinary(pageA.n);
 
   const pageMetricsObj = pageMetricsArr[pageA.n];
   return gs.compareOCRPageImp({
-    pageA, pageB, binaryImage, pageMetricsObj, options,
+    pageA,
+    pageB,
+    binaryImage,
+    pageMetricsObj,
+    options,
   });
 };
 
@@ -53,7 +62,11 @@ export const evalOCRPage = async (params) => {
   const binaryImage = await ImageCache.getBinary(n);
   const pageMetricsObj = pageMetricsArr[n];
   return gs.evalPageBase({
-    page: params.page, binaryImage, pageMetricsObj, func: params.func, view: params.view,
+    page: params.page,
+    binaryImage,
+    pageMetricsObj,
+    func: params.func,
+    view: params.view,
   });
 };
 
@@ -120,12 +133,15 @@ export const calcRecognizeRotateArgs = async (n, areaMode) => {
   const angle = pageMetricsArr[n]?.angle;
 
   // Whether the page angle is already known (or needs to be detected)
-  const angleKnown = typeof (angle) === 'number';
+  const angleKnown = typeof angle === 'number';
 
   const nativeN = await ImageCache.getNative(n);
 
   // Calculate additional rotation to apply to page.  Rotation should not be applied if page has already been rotated.
-  const rotateDegrees = rotate && angle && Math.abs(angle || 0) > 0.05 && !nativeN.rotated ? angle * -1 : 0;
+  const rotateDegrees =
+    rotate && angle && Math.abs(angle || 0) > 0.05 && !nativeN.rotated
+      ? angle * -1
+      : 0;
   const rotateRadians = rotateDegrees * (Math.PI / 180);
 
   let saveNativeImage = false;
@@ -135,8 +151,19 @@ export const calcRecognizeRotateArgs = async (n, areaMode) => {
   if (!areaMode) {
     const binaryN = await ImageCache.binary[n];
     // Images are saved if either (1) we do not have any such image at present or (2) the current version is not rotated but the user has the "auto rotate" option enabled.
-    if (autoRotate && !nativeN.rotated[n] && (!angleKnown || Math.abs(rotateRadians) > angleThresh)) saveNativeImage = true;
-    if (!binaryN || autoRotate && !binaryN.rotated && (!angleKnown || Math.abs(rotateRadians) > angleThresh)) saveBinaryImageArg = true;
+    if (
+      autoRotate &&
+      !nativeN.rotated[n] &&
+      (!angleKnown || Math.abs(rotateRadians) > angleThresh)
+    )
+      saveNativeImage = true;
+    if (
+      !binaryN ||
+      (autoRotate &&
+        !binaryN.rotated &&
+        (!angleKnown || Math.abs(rotateRadians) > angleThresh))
+    )
+      saveBinaryImageArg = true;
   }
 
   return {
@@ -160,9 +187,20 @@ export const calcRecognizeRotateArgs = async (n, areaMode) => {
  * @param {Object<string, string>} tessOptions - Options to pass to Tesseract.js.
  * @param {boolean} [debugVis=false] - Generate instructions for debugging visualizations.
  */
-export const recognizePageImp = async (n, legacy, lstm, areaMode, tessOptions = {}, debugVis = false) => {
+export const recognizePageImp = async (
+  n,
+  legacy,
+  lstm,
+  areaMode,
+  tessOptions = {},
+  debugVis = false
+) => {
   const {
-    angleThresh, angleKnown, rotateRadians, saveNativeImage, saveBinaryImageArg,
+    angleThresh,
+    angleKnown,
+    rotateRadians,
+    saveNativeImage,
+    saveBinaryImageArg,
   } = await calcRecognizeRotateArgs(n, areaMode);
 
   const nativeN = await ImageCache.getNative(n);
@@ -171,7 +209,10 @@ export const recognizePageImp = async (n, legacy, lstm, areaMode, tessOptions =
 
   const config = {
     ...{
-      rotateRadians, rotateAuto: !angleKnown, legacy, lstm,
+      rotateRadians,
+      rotateAuto: !angleKnown,
+      legacy,
+      lstm,
     },
     ...tessOptions,
   };
@@ -206,7 +247,7 @@ export const recognizePageImp = async (n, legacy, lstm, areaMode, tessOptions =
   const res0 = await resArr[0];
 
   // const printDebug = true;
-  // if (printDebug && typeof process === 'undefined') {
+  // if (printDebug && true) {
   //   if (legacy && lstm) {
   //     resArr[1].then((res1) => {
   //       console.log(res1.recognize.debug);
@@ -218,24 +259,52 @@ export const recognizePageImp = async (n, legacy, lstm, areaMode, tessOptions =
 
   // parseDebugInfo(res0.recognize.debug);
 
-  if (!angleKnown) pageMetricsArr[n].angle = (res0.recognize.rotateRadians || 0) * (180 / Math.PI) * -1;
+  if (!angleKnown)
+    pageMetricsArr[n].angle =
+      (res0.recognize.rotateRadians || 0) * (180 / Math.PI) * -1;
 
   // An image is rotated if either the source was rotated or rotation was applied by Tesseract.
-  const isRotated = Boolean(res0.recognize.rotateRadians || 0) || nativeN.rotated;
+  const isRotated =
+    Boolean(res0.recognize.rotateRadians || 0) || nativeN.rotated;
 
   // Images from Tesseract should not overwrite the existing images in the case where rotateAuto is true,
   // but no significant rotation was actually detected.
-  const significantRotation = Math.abs(res0.recognize.rotateRadians || 0) > angleThresh;
+  const significantRotation =
+    Math.abs(res0.recognize.rotateRadians || 0) > angleThresh;
 
   const upscale = res0.recognize.upscale || false;
-  if (saveBinaryImageArg && res0.recognize.imageBinary && (significantRotation || !ImageCache.binary[n])) {
-    ImageCache.binaryProps[n] = { rotated: isRotated, upscaled: upscale, colorMode: 'binary' };
-    ImageCache.binary[n] = new ImageWrapper(n, res0.recognize.imageBinary, 'binary', isRotated, upscale);
+  if (
+    saveBinaryImageArg &&
+    res0.recognize.imageBinary &&
+    (significantRotation || !ImageCache.binary[n])
+  ) {
+    ImageCache.binaryProps[n] = {
+      rotated: isRotated,
+      upscaled: upscale,
+      colorMode: 'binary',
+    };
+    ImageCache.binary[n] = new ImageWrapper(
+      n,
+      res0.recognize.imageBinary,
+      'binary',
+      isRotated,
+      upscale
+    );
   }
 
   if (saveNativeImage && res0.recognize.imageColor && significantRotation) {
-    ImageCache.nativeProps[n] = { rotated: isRotated, upscaled: upscale, colorMode: opt.colorMode };
-    ImageCache.native[n] = new ImageWrapper(n, res0.recognize.imageColor, 'native', isRotated, upscale);
+    ImageCache.nativeProps[n] = {
+      rotated: isRotated,
+      upscaled: upscale,
+      colorMode: opt.colorMode,
+    };
+    ImageCache.native[n] = new ImageWrapper(
+      n,
+      res0.recognize.imageColor,
+      'native',
+      isRotated,
+      upscale
+    );
   }
 
   return resArr;
@@ -257,25 +326,14 @@ export function checkCharWarn(warnArr) {
   // The UI warning/error messages cannot be thrown within this function,
   // as that would make this file break when imported into contexts that do not have the main UI.
   if (charGoodCt === 0 && charErrorCt > 0) {
-    if (typeof process === 'undefined') {
-      const errorHTML = `No character-level OCR data detected. Abbyy XML is only supported with character-level data. 
+    const errorHTML = `No character-level OCR data detected. Abbyy XML is only supported with character-level data. 
         <a href="https://docs.scribeocr.com/faq.html#is-character-level-ocr-data-required--why" target="_blank" class="alert-link">Learn more.</a>`;
-      opt.errorHandler(errorHTML);
-    } else {
-      const errorText = `No character-level OCR data detected. Abbyy XML is only supported with character-level data. 
-        See: https://docs.scribeocr.com/faq.html#is-character-level-ocr-data-required--why`;
-      opt.errorHandler(errorText);
-    }
-  } if (charGoodCt === 0 && charWarnCt > 0) {
-    if (typeof process === 'undefined') {
-      const warningHTML = `No character-level OCR data detected. Font optimization features will be disabled. 
+    opt.errorHandler(errorHTML);
+  }
+  if (charGoodCt === 0 && charWarnCt > 0) {
+    const warningHTML = `No character-level OCR data detected. Font optimization features will be disabled. 
         <a href="https://docs.scribeocr.com/faq.html#is-character-level-ocr-data-required--why" target="_blank" class="alert-link">Learn more.</a>`;
-      opt.warningHandler(warningHTML);
-    } else {
-      const errorText = `No character-level OCR data detected. Font optimization features will be disabled. 
-        See: https://docs.scribeocr.com/faq.html#is-character-level-ocr-data-required--why`;
-      opt.warningHandler(errorText);
-    }
+    opt.warningHandler(warningHTML);
   }
 }
 
@@ -292,7 +350,14 @@ export function checkCharWarn(warnArr) {
  * @param {string} engineName - Name of OCR engine.
  * @param {boolean} [scribeMode=false] - Whether this is HOCR data from this program.
  */
-export async function convertOCRPage(ocrRaw, n, mainData, format, engineName, scribeMode = false) {
+export async function convertOCRPage(
+  ocrRaw,
+  n,
+  mainData,
+  format,
+  engineName,
+  scribeMode = false
+) {
   await gs.getGeneralScheduler();
   let res;
   if (format === 'hocr') {
@@ -318,19 +383,26 @@ export async function convertOCRPage(ocrRaw, n, mainData, format, engineName, sc
  * @param {string} engineName - Name of OCR engine.
  * @returns
  */
-export async function convertPageCallback({
-  pageObj, dataTables, warn, langSet,
-}, n, mainData, engineName) {
+export async function convertPageCallback(
+  { pageObj, dataTables, warn, langSet },
+  n,
+  mainData,
+  engineName
+) {
   const fontPromiseArr = [];
   if (langSet && langSet.has('chi_sim')) fontPromiseArr.push(loadChiSimFont());
-  if (langSet && (langSet.has('rus') || langSet.has('ukr') || langSet.has('ell'))) {
+  if (
+    langSet &&
+    (langSet.has('rus') || langSet.has('ukr') || langSet.has('ell'))
+  ) {
     fontPromiseArr.push(loadBuiltInFontsRaw('all'));
   } else {
     fontPromiseArr.push(loadBuiltInFontsRaw());
   }
   await Promise.all(fontPromiseArr);
 
-  if (['Tesseract Legacy', 'Tesseract LSTM'].includes(engineName)) ocrAll['Tesseract Latest'][n] = pageObj;
+  if (['Tesseract Legacy', 'Tesseract LSTM'].includes(engineName))
+    ocrAll['Tesseract Latest'][n] = pageObj;
 
   if (engineName) ocrAll[engineName][n] = pageObj;
 
@@ -340,7 +412,8 @@ export async function convertPageCallback({
 
     // The main OCR data is always preferred for setting page metrics.
     // This matters when the user uploads their own data, as the images are expected to be rendered at the same resolution as the OCR data.
-    if (pageObj.dims.height && pageObj.dims.width) pageMetricsArr[n] = new PageMetrics(pageObj.dims);
+    if (pageObj.dims.height && pageObj.dims.width)
+      pageMetricsArr[n] = new PageMetrics(pageObj.dims);
 
     pageMetricsArr[n].angle = pageObj.angle;
   }
@@ -348,7 +421,8 @@ export async function convertPageCallback({
   inputData.xmlMode[n] = true;
 
   // Layout boxes are only overwritten if none exist yet for the page
-  if (Object.keys(layoutDataTables.pages[n].tables).length === 0) layoutDataTables.pages[n] = dataTables;
+  if (Object.keys(layoutDataTables.pages[n].tables).length === 0)
+    layoutDataTables.pages[n] = dataTables;
 
   opt.progressHandler({ n, type: 'convert', info: { engineName } });
 }
@@ -365,11 +439,19 @@ export async function convertPageCallback({
  * @param {string} engineName - Name of OCR engine.
  * @param {boolean} [scribeMode=false] - Whether this is HOCR data from this program.
  */
-export async function convertOCR(ocrRawArr, mainData, format, engineName, scribeMode) {
+export async function convertOCR(
+  ocrRawArr,
+  mainData,
+  format,
+  engineName,
+  scribeMode
+) {
   // For each page, process OCR using web worker
   const promiseArr = [];
   for (let n = 0; n < ocrRawArr.length; n++) {
-    promiseArr.push(convertOCRPage(ocrRawArr[n], n, mainData, format, engineName, scribeMode));
+    promiseArr.push(
+      convertOCRPage(ocrRawArr[n], n, mainData, format, engineName, scribeMode)
+    );
   }
   await Promise.all(promiseArr);
 }
@@ -383,10 +465,18 @@ export async function convertOCR(ocrRawArr, mainData, format, engineName, scribe
  * @param {boolean} [vanillaMode=false]
  * @param {Object<string, string>} [config={}]
  */
-export async function recognizeAllPages(legacy = true, lstm = true, mainData = false, langs = ['eng'], vanillaMode = false, config = {}) {
+export async function recognizeAllPages(
+  legacy = true,
+  lstm = true,
+  mainData = false,
+  langs = ['eng'],
+  vanillaMode = false,
+  config = {}
+) {
   // Render all PDF pages to PNG if needed
   // This step should not create binarized images as they will be created by Tesseract during recognition.
-  if (inputData.pdfMode) await ImageCache.preRenderRange(0, ImageCache.pageCount - 1, false);
+  if (inputData.pdfMode)
+    await ImageCache.preRenderRange(0, ImageCache.pageCount - 1, false);
 
   if (legacy) {
     const oemText = 'Tesseract Legacy';
@@ -410,7 +500,10 @@ export async function recognizeAllPages(legacy = true, lstm = true, mainData = f
   }
 
   await gs.initTesseract({
-    anyOk: false, vanillaMode, langs, config,
+    anyOk: false,
+    vanillaMode,
+    langs,
+    config,
   });
 
   // If Legacy and LSTM are both requested, LSTM completion is tracked by a second array of promises (`promisesB`).
@@ -425,12 +518,16 @@ export async function recognizeAllPages(legacy = true, lstm = true, mainData = f
   const resolvesB = [];
 
   for (let i = 0; i < inputPages.length; i++) {
-    promisesA.push(new Promise((resolve, reject) => {
-      resolvesA[i] = { resolve, reject };
-    }));
-    promisesB.push(new Promise((resolve, reject) => {
-      resolvesB[i] = { resolve, reject };
-    }));
+    promisesA.push(
+      new Promise((resolve, reject) => {
+        resolvesA[i] = { resolve, reject };
+      })
+    );
+    promisesB.push(
+      new Promise((resolve, reject) => {
+        resolvesB[i] = { resolve, reject };
+      })
+    );
   }
 
   // Upscaling is enabled only for image data, and only if the user has explicitly enabled it.
@@ -441,35 +538,54 @@ export async function recognizeAllPages(legacy = true, lstm = true, mainData = f
   const configPage = { upscale };
 
   for (const x of inputPages) {
-    recognizePageImp(x, legacy, lstm, false, configPage, opt.debugVis).then(async (resArr) => {
-      const res0 = await resArr[0];
-
-      if (res0.recognize.debugVis) {
-        const { ScrollView } = await import('../scrollview-web/scrollview/ScrollView.js');
-        const sv = new ScrollView({
-          lightTheme: true,
-          CanvasKit: ca.CanvasKit,
-        });
-        await sv.processVisStr(res0.recognize.debugVis);
-        visInstructions[x] = await sv.getAll(true);
-      }
-
-      if (legacy) {
-        await convertPageCallback(res0.convert.legacy, x, mainData, 'Tesseract Legacy');
-        resolvesA[x].resolve();
-      } else if (lstm) {
-        await convertPageCallback(res0.convert.lstm, x, false, 'Tesseract LSTM');
-        resolvesA[x].resolve();
-      }
+    recognizePageImp(x, legacy, lstm, false, configPage, opt.debugVis).then(
+      async (resArr) => {
+        const res0 = await resArr[0];
+
+        // if (res0.recognize.debugVis) {
+        //   const { ScrollView } = await import(
+        //     '../scrollview-web/scrollview/ScrollView.js'
+        //   );
+        //   const sv = new ScrollView({
+        //     lightTheme: true,
+        //     CanvasKit: ca.CanvasKit,
+        //   });
+        //   await sv.processVisStr(res0.recognize.debugVis);
+        //   visInstructions[x] = await sv.getAll(true);
+        // }
+
+        if (legacy) {
+          await convertPageCallback(
+            res0.convert.legacy,
+            x,
+            mainData,
+            'Tesseract Legacy'
+          );
+          resolvesA[x].resolve();
+        } else if (lstm) {
+          await convertPageCallback(
+            res0.convert.lstm,
+            x,
+            false,
+            'Tesseract LSTM'
+          );
+          resolvesA[x].resolve();
+        }
 
-      if (legacy && lstm) {
-        (async () => {
-          const res1 = await resArr[1];
-          await convertPageCallback(res1.convert.lstm, x, false, 'Tesseract LSTM');
-          resolvesB[x].resolve();
-        })();
+        if (legacy && lstm) {
+          (async () => {
+            const res1 = await resArr[1];
+            await convertPageCallback(
+              res1.convert.lstm,
+              x,
+              false,
+              'Tesseract LSTM'
+            );
+            resolvesB[x].resolve();
+          })();
+        }
       }
-    });
+    );
   }
 
   await Promise.all(promisesA);
@@ -503,12 +619,15 @@ export async function recognizeAllPages(legacy = true, lstm = true, mainData = f
  * @param {Object<string, string>} [options.config={}] - Config params to pass to to Tesseract.js.
  */
 export async function recognize(options = {}) {
-  if (!inputData.pdfMode && !inputData.imageMode) throw new Error('No PDF or image data found to recognize.');
+  if (!inputData.pdfMode && !inputData.imageMode)
+    throw new Error('No PDF or image data found to recognize.');
 
   await gs.getGeneralScheduler();
 
-  const combineMode = options && options.combineMode ? options.combineMode : 'data';
-  const vanillaMode = options && options.vanillaMode !== undefined ? options.vanillaMode : false;
+  const combineMode =
+    options && options.combineMode ? options.combineMode : 'data';
+  const vanillaMode =
+    options && options.vanillaMode !== undefined ? options.vanillaMode : false;
   const config = options && options.config ? options.config : {};
 
   const langs = options && options.langs ? options.langs : ['eng'];
@@ -523,14 +642,19 @@ export async function recognize(options = {}) {
   // Chinese requires loading a separate font.
   if (langs.includes('chi_sim')) fontPromiseArr.push(loadChiSimFont());
   // Greek and Cyrillic require loading a version of the base fonts that include these characters.
-  if (langs.includes('rus') || langs.includes('ukr') || langs.includes('ell')) fontPromiseArr.push(loadBuiltInFontsRaw('all'));
+  if (langs.includes('rus') || langs.includes('ukr') || langs.includes('ell'))
+    fontPromiseArr.push(loadBuiltInFontsRaw('all'));
   await Promise.all(fontPromiseArr);
 
   let forceMainData = false;
   let existingOCR;
   if (ocrAll['User Upload']) {
     existingOCR = ocrAll['User Upload'];
-  } else if (ocrAll.pdf && (inputData.pdfType === 'text' && opt.usePDFText.native.supp || inputData.pdfType === 'ocr' && opt.usePDFText.ocr.supp)) {
+  } else if (
+    ocrAll.pdf &&
+    ((inputData.pdfType === 'text' && opt.usePDFText.native.supp) ||
+      (inputData.pdfType === 'ocr' && opt.usePDFText.ocr.supp))
+  ) {
     existingOCR = ocrAll.pdf;
     // If the PDF text is not the active data, it is assumed to be for supplemental purposes only.
     forceMainData = ocrAll.pdf !== ocrAll.active;
@@ -540,7 +664,14 @@ export async function recognize(options = {}) {
   if (oemMode === 'legacy' || oemMode === 'lstm') {
     // Tesseract is used as the "main" data unless user-uploaded data exists and only the LSTM model is being run.
     // This is because Tesseract Legacy provides very strong metrics, and Abbyy often does not.
-    await recognizeAllPages(oemMode === 'legacy', oemMode === 'lstm', !existingOCR, langs, vanillaMode, config);
+    await recognizeAllPages(
+      oemMode === 'legacy',
+      oemMode === 'lstm',
+      !existingOCR,
+      langs,
+      vanillaMode,
+      config
+    );
 
     // Metrics from the LSTM model are so inaccurate they are not worth using.
     if (oemMode === 'legacy') {
@@ -548,7 +679,14 @@ export async function recognize(options = {}) {
       await runFontOptimization(ocrAll['Tesseract Legacy']);
     }
   } else if (oemMode === 'combined') {
-    await recognizeAllPages(true, true, !existingOCR, langs, vanillaMode, config);
+    await recognizeAllPages(
+      true,
+      true,
+      !existingOCR,
+      langs,
+      vanillaMode,
+      config
+    );
 
     if (opt.saveDebugImages) {
       DebugData.debugImg.Combined = new Array(ImageCache.pageCount);
@@ -563,7 +701,9 @@ export async function recognize(options = {}) {
       ocrAll.active = ocrAll[oemText];
 
       if (opt.saveDebugImages) {
-        DebugData.debugImg['Tesseract Combined'] = new Array(ImageCache.pageCount);
+        DebugData.debugImg['Tesseract Combined'] = new Array(
+          ImageCache.pageCount
+        );
         for (let i = 0; i < ImageCache.pageCount; i++) {
           DebugData.debugImg['Tesseract Combined'][i] = [];
         }
@@ -577,7 +717,8 @@ export async function recognize(options = {}) {
     // as low-confidence words are excluded when calculating overall character metrics.
     // For validation, this version is superior to both Legacy and LSTM, as it combines the more accurate bounding boxes/style data from Legacy
     // with the more accurate (on average) text data from LSTM.
-    if (!ocrAll['Tesseract Combined Temp']) ocrAll['Tesseract Combined Temp'] = Array(inputData.pageCount);
+    if (!ocrAll['Tesseract Combined Temp'])
+      ocrAll['Tesseract Combined Temp'] = Array(inputData.pageCount);
 
     {
       /** @type {Parameters<typeof compareOCR>[2]} */
@@ -587,7 +728,11 @@ export async function recognize(options = {}) {
         legacyLSTMComb: true,
       };
 
-      const res = await compareOCR(ocrAll['Tesseract Legacy'], ocrAll['Tesseract LSTM'], compOptions);
+      const res = await compareOCR(
+        ocrAll['Tesseract Legacy'],
+        ocrAll['Tesseract LSTM'],
+        compOptions
+      );
 
       replaceObjectProperties(ocrAll['Tesseract Combined Temp'], res.ocr);
     }
@@ -616,9 +761,14 @@ export async function recognize(options = {}) {
         legacyLSTMComb: true,
       };
 
-      const res = await compareOCR(ocrAll['Tesseract Legacy'], ocrAll['Tesseract LSTM'], compOptions);
+      const res = await compareOCR(
+        ocrAll['Tesseract Legacy'],
+        ocrAll['Tesseract LSTM'],
+        compOptions
+      );
 
-      if (DebugData.debugImg[tessCombinedLabel]) DebugData.debugImg[tessCombinedLabel] = res.debug;
+      if (DebugData.debugImg[tessCombinedLabel])
+        DebugData.debugImg[tessCombinedLabel] = res.debug;
 
       replaceObjectProperties(ocrAll[tessCombinedLabel], res.ocr);
     }
@@ -636,9 +786,14 @@ export async function recognize(options = {}) {
           editConf: true,
         };
 
-        const res = await compareOCR(existingOCR, ocrAll['Tesseract Combined'], compOptions);
+        const res = await compareOCR(
+          existingOCR,
+          ocrAll['Tesseract Combined'],
+          compOptions
+        );
 
-        if (DebugData.debugImg.Combined) DebugData.debugImg.Combined = res.debug;
+        if (DebugData.debugImg.Combined)
+          DebugData.debugImg.Combined = res.debug;
 
         replaceObjectProperties(ocrAll.Combined, res.ocr);
       } else if (combineMode === 'data') {
@@ -651,24 +806,38 @@ export async function recognize(options = {}) {
           confThreshHigh: opt.confThreshHigh,
           confThreshMed: opt.confThreshMed,
           // If the existing data was invisible OCR text extracted from a PDF, it is assumed to not have accurate bounding boxes.
-          useBboxB: !forceMainData && existingOCR === ocrAll.pdf && inputData.pdfMode && !!inputData.pdfType && ['image', 'ocr'].includes(inputData.pdfType),
+          useBboxB:
+            !forceMainData &&
+            existingOCR === ocrAll.pdf &&
+            inputData.pdfMode &&
+            !!inputData.pdfType &&
+            ['image', 'ocr'].includes(inputData.pdfType),
         };
 
         let res;
         if (forceMainData) {
-          res = await compareOCR(ocrAll['Tesseract Combined'], existingOCR, compOptions);
+          res = await compareOCR(
+            ocrAll['Tesseract Combined'],
+            existingOCR,
+            compOptions
+          );
         } else {
-          res = await compareOCR(existingOCR, ocrAll['Tesseract Combined'], compOptions);
+          res = await compareOCR(
+            existingOCR,
+            ocrAll['Tesseract Combined'],
+            compOptions
+          );
         }
 
-        if (DebugData.debugImg.Combined) DebugData.debugImg.Combined = res.debug;
+        if (DebugData.debugImg.Combined)
+          DebugData.debugImg.Combined = res.debug;
 
         replaceObjectProperties(ocrAll.Combined, res.ocr);
       }
     }
   }
 
-  return (ocrAll.active);
+  return ocrAll.active;
 }
 
 /**
diff --git a/js/utils/miscUtils.js b/js/utils/miscUtils.js
index 9c879cd7ffd22190100a1fb7af0a44a3656f7e10..eb3c0c7fcd0a33155364c343235a34f8273f656a 100644
--- a/js/utils/miscUtils.js
+++ b/js/utils/miscUtils.js
@@ -2,9 +2,63 @@
 // Various utility functions used in other files.
 
 // Includes all capital letters except for "J" and "Q"
-export const ascCharArr = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L', 'M', 'N', 'O', 'P', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
-  'b', 'd', 'h', 'k', 'l', 't', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
-export const xCharArr = ['a', 'c', 'e', 'm', 'n', 'o', 'r', 's', 'u', 'v', 'w', 'x', 'z'];
+export const ascCharArr = [
+  'A',
+  'B',
+  'C',
+  'D',
+  'E',
+  'F',
+  'G',
+  'H',
+  'I',
+  'K',
+  'L',
+  'M',
+  'N',
+  'O',
+  'P',
+  'R',
+  'S',
+  'T',
+  'U',
+  'V',
+  'W',
+  'X',
+  'Y',
+  'Z',
+  'b',
+  'd',
+  'h',
+  'k',
+  'l',
+  't',
+  '0',
+  '1',
+  '2',
+  '3',
+  '4',
+  '5',
+  '6',
+  '7',
+  '8',
+  '9',
+];
+export const xCharArr = [
+  'a',
+  'c',
+  'e',
+  'm',
+  'n',
+  'o',
+  'r',
+  's',
+  'u',
+  'v',
+  'w',
+  'x',
+  'z',
+];
 
 /**
  *
@@ -130,7 +184,7 @@ export const mean50 = (arr) => {
     return null;
   }
   const per25 = Math.floor(arr.length / 4) - 1;
-  const per75 = Math.ceil(arr.length * 3 / 4) - 1;
+  const per75 = Math.ceil((arr.length * 3) / 4) - 1;
   const nums = [...arr].sort((a, b) => a - b);
   const numsMiddle = nums.slice(per25, per75 + 1);
 
@@ -145,17 +199,20 @@ export const mean50 = (arr) => {
 export function unescapeXml(string) {
   const replaceFunc = (match, p1) => String.fromCharCode(parseInt(p1, 16));
 
-  return string.replace(/&amp;/g, '&')
-    .replace(/&quot;/g, '"')
-    .replace(/&apos;/g, "'")
-    .replace(/&lt;/g, '<')
-    .replace(/&gt;/g, '>')
-    .replace(/&gt;/g, '>')
-    .replace(/&#39;/g, "'")
-    .replace(/&#34;/g, '"')
-    // The prefix &#x indicates the character is encoded as hexidecimal.
-    .replace(/&#x([0-9a-f]+);/g, replaceFunc)
-    .replace(/\u00AD/g, '-'); // Replace soft hyphen with regular hyphen. This is unrelated to XML escaping, but should be done for all inputs.
+  return (
+    string
+      .replace(/&amp;/g, '&')
+      .replace(/&quot;/g, '"')
+      .replace(/&apos;/g, "'")
+      .replace(/&lt;/g, '<')
+      .replace(/&gt;/g, '>')
+      .replace(/&gt;/g, '>')
+      .replace(/&#39;/g, "'")
+      .replace(/&#34;/g, '"')
+      // The prefix &#x indicates the character is encoded as hexidecimal.
+      .replace(/&#x([0-9a-f]+);/g, replaceFunc)
+      .replace(/\u00AD/g, '-')
+  ); // Replace soft hyphen with regular hyphen. This is unrelated to XML escaping, but should be done for all inputs.
 }
 
 // TODO: There may be duplicated approaches between `calcLang` and `getTextScript`.
@@ -171,21 +228,25 @@ export function calcLang(str) {
 
     if (code >= 0 && code <= 127) continue;
 
-    if ((code >= 0x4E00 && code <= 0x9FFF) // CJK Unified Ideographs
-    || (code >= 0x3400 && code <= 0x4DBF) // CJK Unified Ideographs Extension A
-    || (code >= 0x20000 && code <= 0x2A6DF) // CJK Unified Ideographs Extension B
-    || (code >= 0x2A700 && code <= 0x2B73F) // CJK Unified Ideographs Extension C
-    || (code >= 0x2B740 && code <= 0x2B81F) // CJK Unified Ideographs Extension D
-    || (code >= 0x2B820 && code <= 0x2CEAF) // CJK Unified Ideographs Extension E
-    || (code >= 0xF900 && code <= 0xFAFF) // CJK Compatibility Ideographs
-    || (code >= 0x2F800 && code <= 0x2FA1F) // CJK Compatibility Ideographs Supplement
-    ) return ('chi_sim');
-
-    if ((code >= 0x0400 && code <= 0x04FF)
-    || (code >= 0x0500 && code <= 0x052F)
-    || code === 0x1C80
-    || code === 0x1C81
-    ) return ('rus');
+    if (
+      (code >= 0x4e00 && code <= 0x9fff) || // CJK Unified Ideographs
+      (code >= 0x3400 && code <= 0x4dbf) || // CJK Unified Ideographs Extension A
+      (code >= 0x20000 && code <= 0x2a6df) || // CJK Unified Ideographs Extension B
+      (code >= 0x2a700 && code <= 0x2b73f) || // CJK Unified Ideographs Extension C
+      (code >= 0x2b740 && code <= 0x2b81f) || // CJK Unified Ideographs Extension D
+      (code >= 0x2b820 && code <= 0x2ceaf) || // CJK Unified Ideographs Extension E
+      (code >= 0xf900 && code <= 0xfaff) || // CJK Compatibility Ideographs
+      (code >= 0x2f800 && code <= 0x2fa1f) // CJK Compatibility Ideographs Supplement
+    )
+      return 'chi_sim';
+
+    if (
+      (code >= 0x0400 && code <= 0x04ff) ||
+      (code >= 0x0500 && code <= 0x052f) ||
+      code === 0x1c80 ||
+      code === 0x1c81
+    )
+      return 'rus';
   }
 
   return 'eng';
@@ -209,18 +270,13 @@ export async function readOcrFile(file) {
   if (typeof file === 'string') return file;
 
   // The `typeof process` condition is necessary to avoid error in Node.js versions <20, where `File` is not defined.
-  if (typeof process === 'undefined' && file instanceof File) {
+  if (file instanceof File) {
     if (/\.gz$/i.test(file.name)) {
-      return (readTextFileGz(file));
+      return readTextFileGz(file);
     }
-    return (readTextFile(file));
+    return readTextFile(file);
   }
 
-  if (typeof process !== 'undefined') {
-    if (!file?.fileData?.toString) throw new Error('Invalid input. Must be a FileNode, ArrayBuffer, or string.');
-    // @ts-ignore
-    return file.fileData.toString();
-  }
   throw new Error('Invalid input. Must be a File, ArrayBuffer, or string.');
 }
 
@@ -259,7 +315,7 @@ export function readTextFile(file) {
 }
 
 export function round3(x) {
-  return (Math.round(x * 1e3) / 1e3);
+  return Math.round(x * 1e3) / 1e3;
 }
 
 /**
@@ -268,7 +324,7 @@ export function round3(x) {
  * @returns {number} The rounded number.
  */
 export function round6(x) {
-  return (Math.round(x * 1e6) / 1e6);
+  return Math.round(x * 1e6) / 1e6;
 }
 
 /** Function that count occurrences of a substring in a string;
@@ -280,10 +336,15 @@ export function round6(x) {
  * @see Unit Test https://jsfiddle.net/Victornpb/5axuh96u/
  * @see https://stackoverflow.com/a/7924240/938822
  */
-export function countSubstringOccurrences(string, subString, allowOverlapping, caseSensitive = false) {
+export function countSubstringOccurrences(
+  string,
+  subString,
+  allowOverlapping,
+  caseSensitive = false
+) {
   string += '';
   subString += '';
-  if (subString.length <= 0) return (string.length + 1);
+  if (subString.length <= 0) return string.length + 1;
 
   if (!caseSensitive) {
     string = string.toLowerCase();
@@ -313,12 +374,6 @@ export function countSubstringOccurrences(string, subString, allowOverlapping, c
  * @param {string} fileName - File name.
  */
 export const saveAs = async (content, fileName) => {
-  if (typeof process !== 'undefined') {
-    const { promises: fsPromises } = await import('fs');
-    await fsPromises.writeFile(fileName, content);
-    return;
-  }
-
   let blob;
   if (typeof Blob !== 'undefined' && content instanceof Blob) {
     blob = content;
@@ -329,11 +384,13 @@ export const saveAs = async (content, fileName) => {
   const a = document.createElement('a');
   a.download = fileName;
   a.href = globalThis.URL.createObjectURL(blob);
-  a.dispatchEvent(new MouseEvent('click', {
-    bubbles: true,
-    cancelable: true,
-    view: window,
-  }));
+  a.dispatchEvent(
+    new MouseEvent('click', {
+      bubbles: true,
+      cancelable: true,
+      view: window,
+    })
+  );
 };
 
 /**
@@ -342,23 +399,27 @@ export const saveAs = async (content, fileName) => {
  * @param {Array<EvalMetrics>} evalMetricsArr - Array of EvalMetrics objects.
  * @returns {EvalMetrics} A single EvalMetrics object with summed properties.
  */
-export const reduceEvalMetrics = (evalMetricsArr) => evalMetricsArr.reduce((acc, curr) => ({
-  total: acc.total + curr.total,
-  correct: acc.correct + curr.correct,
-  incorrect: acc.incorrect + curr.incorrect,
-  missed: acc.missed + curr.missed,
-  extra: acc.extra + curr.extra,
-  correctLowConf: acc.correctLowConf + curr.correctLowConf,
-  incorrectHighConf: acc.incorrectHighConf + curr.incorrectHighConf,
-}), {
-  total: 0,
-  correct: 0,
-  incorrect: 0,
-  missed: 0,
-  extra: 0,
-  correctLowConf: 0,
-  incorrectHighConf: 0,
-});
+export const reduceEvalMetrics = (evalMetricsArr) =>
+  evalMetricsArr.reduce(
+    (acc, curr) => ({
+      total: acc.total + curr.total,
+      correct: acc.correct + curr.correct,
+      incorrect: acc.incorrect + curr.incorrect,
+      missed: acc.missed + curr.missed,
+      extra: acc.extra + curr.extra,
+      correctLowConf: acc.correctLowConf + curr.correctLowConf,
+      incorrectHighConf: acc.incorrectHighConf + curr.incorrectHighConf,
+    }),
+    {
+      total: 0,
+      correct: 0,
+      incorrect: 0,
+      missed: 0,
+      extra: 0,
+      correctLowConf: 0,
+      incorrectHighConf: 0,
+    }
+  );
 
 /**
  * Delete all properties from `obj` and replace with properties from `obj2`.
@@ -378,13 +439,54 @@ export function replaceObjectProperties(obj, obj2 = {}) {
 // Sans/serif lookup for common font families. These should not include spaces or underscores--multi-word font names should be concatenated.
 // Fonts that should not be added (both Sans and Serif variants):
 // DejaVu
-const serifFonts = ['SerifDefault', 'Baskerville', 'Bookman', 'C059', 'Calibri', 'Cambria', 'Century', 'Courier', 'Garamond', 'Georgia',
-  'LucidaBright', 'Minion', 'NimbusMono', 'Optima', 'P052', 'Palatino', 'Times'];
-const sansFonts = ['SansDefault', 'Avenir', 'Arial', 'Calibri', 'Candara', 'Carlito', 'Comic', 'Franklin', 'Futura', 'Gotham',
-  'Helvetica', 'Impact', 'Interstate', 'Myriad', 'Tahoma', 'Trebuchet', 'Univers', 'Verdana'];
-
-const serifFontsRegex = new RegExp(serifFonts.reduce((x, y) => `${x}|${y}`), 'i');
-const sansFontsRegex = new RegExp(sansFonts.reduce((x, y) => `${x}|${y}`), 'i');
+const serifFonts = [
+  'SerifDefault',
+  'Baskerville',
+  'Bookman',
+  'C059',
+  'Calibri',
+  'Cambria',
+  'Century',
+  'Courier',
+  'Garamond',
+  'Georgia',
+  'LucidaBright',
+  'Minion',
+  'NimbusMono',
+  'Optima',
+  'P052',
+  'Palatino',
+  'Times',
+];
+const sansFonts = [
+  'SansDefault',
+  'Avenir',
+  'Arial',
+  'Calibri',
+  'Candara',
+  'Carlito',
+  'Comic',
+  'Franklin',
+  'Futura',
+  'Gotham',
+  'Helvetica',
+  'Impact',
+  'Interstate',
+  'Myriad',
+  'Tahoma',
+  'Trebuchet',
+  'Univers',
+  'Verdana',
+];
+
+const serifFontsRegex = new RegExp(
+  serifFonts.reduce((x, y) => `${x}|${y}`),
+  'i'
+);
+const sansFontsRegex = new RegExp(
+  sansFonts.reduce((x, y) => `${x}|${y}`),
+  'i'
+);
 
 const unidentifiedFonts = new Set();
 
@@ -410,15 +512,18 @@ export function determineSansSerif(fontName) {
   /** @type {('SansDefault'|'SerifDefault'|'Default')} */
   let fontFamily = 'Default';
   // Font support is currently limited to 1 font for Sans and 1 font for Serif.
-  if (fontName && !['Default', 'GlyphLessFont', 'HiddenHorzOCR'].includes(fontName)) {
+  if (
+    fontName &&
+    !['Default', 'GlyphLessFont', 'HiddenHorzOCR'].includes(fontName)
+  ) {
     // First, test to see if "sans" or "serif" is in the name of the font
     if (/(^|\W|_)sans($|\W|_)/i.test(fontName)) {
       fontFamily = 'SansDefault';
     } else if (/(^|\W|_)serif($|\W|_)/i.test(fontName)) {
       fontFamily = 'SerifDefault';
 
-    // If not, check against a list of known sans/serif fonts.
-    // This list is almost certainly incomplete, so should be added to when new fonts are encountered.
+      // If not, check against a list of known sans/serif fonts.
+      // This list is almost certainly incomplete, so should be added to when new fonts are encountered.
     } else if (serifFontsRegex.test(fontName)) {
       fontFamily = 'SerifDefault';
     } else if (sansFontsRegex.test(fontName)) {
@@ -428,8 +533,8 @@ export function determineSansSerif(fontName) {
         fontFamily = 'SerifDefault';
       } else if (/san/i.test(fontName)) {
         fontFamily = 'SansDefault';
-      // This comes after the hard-coded values, as the hard-coded values are considered more reliable.
-      // If recognition decides the font named "Arial" is a serif font, it's probably wrong.
+        // This comes after the hard-coded values, as the hard-coded values are considered more reliable.
+        // If recognition decides the font named "Arial" is a serif font, it's probably wrong.
       } else if (FontProps.sansFontsDoc.has(fontName)) {
         fontFamily = 'SansDefault';
       } else if (FontProps.serifFontsDoc.has(fontName)) {
@@ -463,7 +568,8 @@ export function getTextScript(text) {
 
 export const replaceSmartQuotes = (text) => {
   if (!/['"]/.test(text)) return text;
-  return text.replace(/(^|[-])'/, '$1')
+  return text
+    .replace(/(^|[-])'/, '$1')
     .replace(/(^|[-])"/, '$1')
     .replace(/'(?=$|[-])/, '')
     .replace(/"(?=$|[-])/, '')
@@ -487,6 +593,7 @@ export function range(min, max) {
 
 // Function that logs to stderr and then waits for the log to be flushed to the console.
 // This should only be used for debugging purposes.
-export const debugLog = (x) => new Promise((resolve) => {
-  process.stderr.write(`${String(x)}\n`, resolve);
-});
+export const debugLog = (x) =>
+  new Promise((resolve) => {
+    process.stderr.write(`${String(x)}\n`, resolve);
+  });
diff --git a/js/worker/compareOCRModule.js b/js/worker/compareOCRModule.js
index a3bb2b657ecd1973e2dccc038c1cff14a7374eea..5cf95248a3deec8ee56bfcde122385c52a1d6f2c 100644
--- a/js/worker/compareOCRModule.js
+++ b/js/worker/compareOCRModule.js
@@ -2,7 +2,11 @@
 /* eslint-disable no-await-in-loop */
 
 import ocr from '../objects/ocrObjects.js';
-import { calcLineFontSize, calcWordFontSize, calcWordMetrics } from '../utils/fontUtils.js';
+import {
+  calcLineFontSize,
+  calcWordFontSize,
+  calcWordMetrics,
+} from '../utils/fontUtils.js';
 
 import { FontCont } from '../containers/fontContainer.js';
 import { imageUtils } from '../objects/imageObjects.js';
@@ -15,7 +19,8 @@ import { ca } from '../canvasAdapter.js';
  * @param {number} angle
  */
 export async function drawWordActual(words, imageBinaryBit, angle) {
-  if (!FontCont.raw) throw new Error('Fonts must be defined before running this function.');
+  if (!FontCont.raw)
+    throw new Error('Fonts must be defined before running this function.');
 
   // The font/style from the first word is used for the purposes of font metrics
   const lineFontSize = calcLineFontSize(words[0].line);
@@ -49,9 +54,14 @@ export async function drawWordActual(words, imageBinaryBit, angle) {
   const { baseline } = words[0].line;
 
   const imageRotated = angle !== 0;
-  const angleAdjLine = imageRotated ? ocr.calcLineStartAngleAdj(lineObj) : { x: 0, y: 0 };
+  const angleAdjLine = imageRotated
+    ? ocr.calcLineStartAngleAdj(lineObj)
+    : { x: 0, y: 0 };
 
-  const start = linebox.left + angleAdjLine.x + (wordBoxUnion.left - linebox.left) / cosAngle;
+  const start =
+    linebox.left +
+    angleAdjLine.x +
+    (wordBoxUnion.left - linebox.left) / cosAngle;
 
   // We crop to the dimensions of the font (fontAsc and fontDesc) rather than the image bounding box.
   const height = Math.round(fontAsc - fontDesc);
@@ -61,9 +71,21 @@ export async function drawWordActual(words, imageBinaryBit, angle) {
   const cropYAdj = cropY + angleAdjLine.y;
 
   const canvas = await ca.createCanvas(width, height);
-  const ctx = /** @type {OffscreenCanvasRenderingContext2D} */ (canvas.getContext('2d'));
-
-  ctx.drawImage(imageBinaryBit, start - 1, cropYAdj, width, height, 0, 0, width, height);
+  const ctx = /** @type {OffscreenCanvasRenderingContext2D} */ (
+    canvas.getContext('2d')
+  );
+
+  ctx.drawImage(
+    imageBinaryBit,
+    start - 1,
+    cropYAdj,
+    width,
+    height,
+    0,
+    0,
+    width,
+    height
+  );
 
   return {
     canvas,
@@ -74,26 +96,34 @@ export async function drawWordActual(words, imageBinaryBit, angle) {
 }
 
 /**
-   * Function that draws a word on a canvas.
-   * This code was factored out to allow for drawing multiple times while only calculating metrics once.
-   * Therefore, only the drawing code should be in this function; the metrics should be calculated elsewhere
-   * and passed to this function, rather than calcualting from an `OcrWord` object.
-   *
-   * @param {Object} params
-   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} params.ctx
-   * @param {Array<string>} params.charArr
-   * @param {number} params.left
-   * @param {number} params.bottom
-   * @param {Array<number>} params.advanceArr - Array of pixels to advance for each character.
-   *    Unlike the "advance" property of a glyph, this is the actual distance to advance on the canvas,
-   *    and should include kerning and character spacing.
-   * @param {FontContainerFont} params.font
-   * @param {number} params.size
-   * @param {boolean} params.smallCaps
-   * @param {string} [params.fillStyle='black']
-   */
+ * Function that draws a word on a canvas.
+ * This code was factored out to allow for drawing multiple times while only calculating metrics once.
+ * Therefore, only the drawing code should be in this function; the metrics should be calculated elsewhere
+ * and passed to this function, rather than calcualting from an `OcrWord` object.
+ *
+ * @param {Object} params
+ * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} params.ctx
+ * @param {Array<string>} params.charArr
+ * @param {number} params.left
+ * @param {number} params.bottom
+ * @param {Array<number>} params.advanceArr - Array of pixels to advance for each character.
+ *    Unlike the "advance" property of a glyph, this is the actual distance to advance on the canvas,
+ *    and should include kerning and character spacing.
+ * @param {FontContainerFont} params.font
+ * @param {number} params.size
+ * @param {boolean} params.smallCaps
+ * @param {string} [params.fillStyle='black']
+ */
 const printWordOnCanvas = async ({
-  ctx, charArr, left, bottom, advanceArr, font, size, smallCaps, fillStyle = 'black',
+  ctx,
+  charArr,
+  left,
+  bottom,
+  advanceArr,
+  font,
+  size,
+  smallCaps,
+  fillStyle = 'black',
 }) => {
   ctx.font = `${font.fontFaceStyle} ${font.fontFaceWeight} ${size}px ${font.fontFaceName}`;
   ctx.fillStyle = fillStyle;
@@ -108,7 +138,9 @@ const printWordOnCanvas = async ({
         ctx.font = `${font.fontFaceStyle} ${font.fontFaceWeight} ${size}px ${font.fontFaceName}`;
       } else {
         charI = charI.toUpperCase();
-        ctx.font = `${font.fontFaceStyle} ${font.fontFaceWeight} ${size * font.smallCapsMult}px ${font.fontFaceName}`;
+        ctx.font = `${font.fontFaceStyle} ${font.fontFaceWeight} ${
+          size * font.smallCapsMult
+        }px ${font.fontFaceName}`;
       }
     }
 
@@ -118,18 +150,27 @@ const printWordOnCanvas = async ({
 };
 
 /**
-   * Print word on canvas.
-   *
-   * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} ctx
-   * @param {OcrWord} word
-   * @param {number} offsetX
-   * @param {number} cropY
-   * @param {?CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} ctxView
-   * @param {boolean} [imageRotated=false] -
-   */
-export const drawWordRender = async (ctx, word, offsetX = 0, cropY = 0, ctxView = null, imageRotated = false) => {
-  if (!FontCont.raw) throw new Error('Fonts must be defined before running this function.');
-  if (!ctx) throw new Error('Canvases must be defined before running this function.');
+ * Print word on canvas.
+ *
+ * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} ctx
+ * @param {OcrWord} word
+ * @param {number} offsetX
+ * @param {number} cropY
+ * @param {?CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} ctxView
+ * @param {boolean} [imageRotated=false] -
+ */
+export const drawWordRender = async (
+  ctx,
+  word,
+  offsetX = 0,
+  cropY = 0,
+  ctxView = null,
+  imageRotated = false
+) => {
+  if (!FontCont.raw)
+    throw new Error('Fonts must be defined before running this function.');
+  if (!ctx)
+    throw new Error('Canvases must be defined before running this function.');
 
   const fontI = FontCont.getWordFont(word);
 
@@ -144,18 +185,26 @@ export const drawWordRender = async (ctx, word, offsetX = 0, cropY = 0, ctxView
   if (word.sup) {
     const wordboxXMid = word.bbox.left + (word.bbox.right - word.bbox.left) / 2;
 
-    const baselineYWord = word.line.bbox.bottom + word.line.baseline[1] + word.line.baseline[0] * (wordboxXMid - word.line.bbox.left);
+    const baselineYWord =
+      word.line.bbox.bottom +
+      word.line.baseline[1] +
+      word.line.baseline[0] * (wordboxXMid - word.line.bbox.left);
 
-    baselineY -= (baselineYWord - word.bbox.bottom);
+    baselineY -= baselineYWord - word.bbox.bottom;
 
     if (!word.visualCoords) {
-      const fontDesc = fontI.opentype.descender / fontI.opentype.unitsPerEm * wordMetrics.fontSize;
+      const fontDesc =
+        (fontI.opentype.descender / fontI.opentype.unitsPerEm) *
+        wordMetrics.fontSize;
       baselineY += fontDesc;
     }
   } else if (!imageRotated) {
     const wordboxXMid = word.bbox.left + (word.bbox.right - word.bbox.left) / 2;
 
-    baselineY = word.line.bbox.bottom + word.line.baseline[1] + word.line.baseline[0] * (wordboxXMid - word.line.bbox.left);
+    baselineY =
+      word.line.bbox.bottom +
+      word.line.baseline[1] +
+      word.line.baseline[0] * (wordboxXMid - word.line.bbox.left);
   }
 
   const y = baselineY - cropY;
@@ -173,12 +222,27 @@ export const drawWordRender = async (ctx, word, offsetX = 0, cropY = 0, ctxView
   if (word.visualCoords) left -= wordMetrics.leftSideBearing;
 
   await printWordOnCanvas({
-    ctx, charArr: wordMetrics.charArr, left, bottom: y, advanceArr: advanceArrTotal, font: fontI, size: wordFontSize, smallCaps: word.smallCaps,
+    ctx,
+    charArr: wordMetrics.charArr,
+    left,
+    bottom: y,
+    advanceArr: advanceArrTotal,
+    font: fontI,
+    size: wordFontSize,
+    smallCaps: word.smallCaps,
   });
 
   if (ctxView) {
     await printWordOnCanvas({
-      ctx: ctxView, charArr: wordMetrics.charArr, left, bottom: y, advanceArr: advanceArrTotal, font: fontI, size: wordFontSize, smallCaps: word.smallCaps, fillStyle: 'red',
+      ctx: ctxView,
+      charArr: wordMetrics.charArr,
+      left,
+      bottom: y,
+      advanceArr: advanceArrTotal,
+      font: fontI,
+      size: wordFontSize,
+      smallCaps: word.smallCaps,
+      fillStyle: 'red',
     });
   }
 };
@@ -201,7 +265,11 @@ export const drawWordRender = async (ctx, word, offsetX = 0, cropY = 0, ctxView
  * @param {boolean} [params.options.useABaseline]
  */
 export async function evalWords({
-  wordsA, wordsB = [], binaryImage, angle, options = {},
+  wordsA,
+  wordsB = [],
+  binaryImage,
+  angle,
+  options = {},
 }) {
   // This code cannot currently handle non-Latin characters.
   // Therefore, if any Chinese words are in either set of words,
@@ -215,16 +283,19 @@ export async function evalWords({
   });
   // Also skip if the first word in the line, which are used for various calculations, are Chinese.
   if (wordsA[0].line.words[0].lang === 'chi_sim') anyChinese = true;
-  if (wordsB[0] && wordsB[0].line.words[0].lang === 'chi_sim') anyChinese = true;
+  if (wordsB[0] && wordsB[0].line.words[0].lang === 'chi_sim')
+    anyChinese = true;
 
   if (anyChinese) return { metricA: 1, metricB: 0, debug: null };
 
   const binaryImageBit = await ca.getImageBitmap(binaryImage);
 
-  if (!FontCont.raw) throw new Error('Fonts must be defined before running this function.');
+  if (!FontCont.raw)
+    throw new Error('Fonts must be defined before running this function.');
 
   const view = options?.view === undefined ? false : options?.view;
-  const useABaseline = options?.useABaseline === undefined ? true : options?.useABaseline;
+  const useABaseline =
+    options?.useABaseline === undefined ? true : options?.useABaseline;
 
   const cosAngle = Math.cos(angle * -1 * (Math.PI / 180)) || 1;
 
@@ -233,11 +304,15 @@ export async function evalWords({
   const baselineA = wordsA[0].line.baseline;
 
   // Draw the actual words (from the user-provided image)
-  const {
-    canvas, cropY, width, height,
-  } = await drawWordActual([...wordsA, ...wordsB], binaryImageBit, angle);
+  const { canvas, cropY, width, height } = await drawWordActual(
+    [...wordsA, ...wordsB],
+    binaryImageBit,
+    angle
+  );
 
-  const ctx = /** @type {OffscreenCanvasRenderingContext2D} */ (canvas.getContext('2d'));
+  const ctx = /** @type {OffscreenCanvasRenderingContext2D} */ (
+    canvas.getContext('2d')
+  );
 
   const imageDataActual = ctx.getImageData(0, 0, width, height).data;
 
@@ -249,27 +324,23 @@ export async function evalWords({
   let ctxView2;
   if (view) {
     let img;
-    if (typeof process === 'undefined') {
-      img = canvas;
-    } else {
-      img = ca.CanvasKit.MakeImage({
-        width,
-        height,
-        alphaType: ca.CanvasKit.AlphaType.Unpremul,
-        colorType: ca.CanvasKit.ColorType.RGBA_8888,
-        colorSpace: ca.CanvasKit.ColorSpace.SRGB,
-      }, imageDataActual, 4 * width);
-    }
+    img = canvas;
 
     canvasView0 = await ca.createCanvas(width, height);
-    ctxView0 = /** @type {OffscreenCanvasRenderingContext2D} */ (canvasView0.getContext('2d'));
+    ctxView0 = /** @type {OffscreenCanvasRenderingContext2D} */ (
+      canvasView0.getContext('2d')
+    );
     ctxView0.drawImage(img, 0, 0);
     canvasView1 = await ca.createCanvas(width, height);
-    ctxView1 = /** @type {OffscreenCanvasRenderingContext2D} */ (canvasView1.getContext('2d'));
+    ctxView1 = /** @type {OffscreenCanvasRenderingContext2D} */ (
+      canvasView1.getContext('2d')
+    );
     ctxView1.drawImage(img, 0, 0);
     if (wordsB.length > 0) {
       canvasView2 = await ca.createCanvas(width, height);
-      ctxView2 = /** @type {OffscreenCanvasRenderingContext2D} */ (canvasView2.getContext('2d'));
+      ctxView2 = /** @type {OffscreenCanvasRenderingContext2D} */ (
+        canvasView2.getContext('2d')
+      );
       ctxView2.drawImage(img, 0, 0);
     }
   }
@@ -279,7 +350,10 @@ export async function evalWords({
 
   // Draw the words in wordsA
   let x0 = wordsA[0].bbox.left;
-  const y0 = linebox.bottom + baselineA[1] + baselineA[0] * (wordsA[0].bbox.left - linebox.left);
+  const y0 =
+    linebox.bottom +
+    baselineA[1] +
+    baselineA[0] * (wordsA[0].bbox.left - linebox.left);
   for (let i = 0; i < wordsA.length; i++) {
     const word = wordsA[i];
     const wordIBox = word.bbox;
@@ -368,41 +442,26 @@ export async function evalWords({
   /** @type {?CompDebugBrowser|CompDebugNode} */
   let debugImg = null;
   if (view) {
-    if (typeof process === 'undefined') {
-      let imageRaw;
-      let imageA;
-      let imageB;
-
-      if (canvasView0) imageRaw = await canvasView0.convertToBlob();
-      if (canvasView1) imageA = await canvasView1.convertToBlob();
-      if (canvasView2) imageB = await canvasView2.convertToBlob();
-      const dims = { width, height };
-
-      debugImg = {
-        context: 'browser', imageRaw, imageA, imageB, dims, errorRawA: metricA, errorRawB: metricB, errorAdjA: null, errorAdjB: null,
-      };
-    } else {
-      let imageRaw;
-      let imageA;
-      let imageB;
-
-      if (canvasView0) imageRaw = canvasView0.toDataURL('image/png');
-      if (canvasView1) imageA = canvasView1.toDataURL('image/png');
-      if (canvasView2) imageB = canvasView2.toDataURL('image/png');
-
-      const dims = { width, height };
-
-      debugImg = {
-        context: 'node', imageRaw, imageA, imageB, dims, errorRawA: metricA, errorRawB: metricB, errorAdjA: null, errorAdjB: null,
-      };
-    }
-  }
-
-  if (typeof process !== 'undefined') {
-    canvas.dispose();
-    if (canvasView0) canvasView0.dispose();
-    if (canvasView1) canvasView1.dispose();
-    if (canvasView2) canvasView2.dispose();
+    let imageRaw;
+    let imageA;
+    let imageB;
+
+    if (canvasView0) imageRaw = await canvasView0.convertToBlob();
+    if (canvasView1) imageA = await canvasView1.convertToBlob();
+    if (canvasView2) imageB = await canvasView2.convertToBlob();
+    const dims = { width, height };
+
+    debugImg = {
+      context: 'browser',
+      imageRaw,
+      imageA,
+      imageB,
+      dims,
+      errorRawA: metricA,
+      errorRawB: metricB,
+      errorAdjA: null,
+      errorAdjB: null,
+    };
   }
 
   return { metricA, metricB, debug: debugImg };
@@ -422,7 +481,8 @@ function rejectWordLegacy(legacyText, lstmText) {
   // Automatically reject words that contain a number between two letters.
   // Tesseract Legacy commonly identifies letters as numbers (usually 1).
   // This does not just happen with "l"--in test documents "r" and "i" were also misidentified as "1" multiple times.
-  const replaceNum = /[a-z]\d[a-z]/i.test(legacyText) && !/[a-z]\d[a-z]/i.test(lstmText);
+  const replaceNum =
+    /[a-z]\d[a-z]/i.test(legacyText) && !/[a-z]\d[a-z]/i.test(lstmText);
 
   // Automatically reject words where "ii" is between two non-"i" letters
   // Tesseract Legacy commonly recognizes "ii" when the (actual) letter contains an accent,
@@ -430,7 +490,9 @@ function rejectWordLegacy(legacyText, lstmText) {
   // This "ii" pattern is automatically discarded, regardless of the overlap metrics,
   // because the overlap metrics often fail in this case.
   // E.g. the letter "" (o with umlaut) may overlap better with "ii" than "o".
-  const replaceII = /[a-hj-z]ii[a-hj-z]/i.test(legacyText) && !/[a-hj-z]ii[a-hj-z]/i.test(lstmText);
+  const replaceII =
+    /[a-hj-z]ii[a-hj-z]/i.test(legacyText) &&
+    !/[a-hj-z]ii[a-hj-z]/i.test(lstmText);
 
   return replaceNum || replaceII;
 }
@@ -483,17 +545,28 @@ async function penalizeWord(wordObjs) {
 
     // These calculations differ from the standard word width calculations,
     // because they do not include left/right bearings.
-    const glyphFirstMetrics = fontOpentypeI.charToGlyph(wordTextArr[0]).getMetrics();
-    const widthFirst = (glyphFirstMetrics.xMax - glyphFirstMetrics.xMin) / fontOpentypeI.unitsPerEm * wordFontSize;
-
-    const glyphSecondMetrics = fontOpentypeI.charToGlyph(wordTextArr[1]).getMetrics();
-    const widthSecond = (glyphSecondMetrics.xMax - glyphSecondMetrics.xMin) / fontOpentypeI.unitsPerEm * wordFontSize;
+    const glyphFirstMetrics = fontOpentypeI
+      .charToGlyph(wordTextArr[0])
+      .getMetrics();
+    const widthFirst =
+      ((glyphFirstMetrics.xMax - glyphFirstMetrics.xMin) /
+        fontOpentypeI.unitsPerEm) *
+      wordFontSize;
+
+    const glyphSecondMetrics = fontOpentypeI
+      .charToGlyph(wordTextArr[1])
+      .getMetrics();
+    const widthSecond =
+      ((glyphSecondMetrics.xMax - glyphSecondMetrics.xMin) /
+        fontOpentypeI.unitsPerEm) *
+      wordFontSize;
 
     const widthTotal = widthFirst + widthSecond;
 
     const wordWidth = word.bbox.right - word.bbox.left;
 
-    if (widthFirst >= wordWidth * 0.9 && widthTotal > wordWidth * 1.15) penalty += 0.05;
+    if (widthFirst >= wordWidth * 0.9 && widthTotal > wordWidth * 1.15)
+      penalty += 0.05;
   }
 
   return penalty;
@@ -525,7 +598,11 @@ async function penalizeWord(wordObjs) {
  * @param {number} [params.options.confThreshMed]
  */
 export async function compareOCRPageImp({
-  pageA, pageB, binaryImage, pageMetricsObj, options = {},
+  pageA,
+  pageB,
+  binaryImage,
+  pageMetricsObj,
+  options = {},
 }) {
   // The `binaryImage` argument is not sent for certain operations, which do not require it.
   // For example, running a basic comparison between a page and the ground truth does not require having the image.
@@ -536,25 +613,38 @@ export async function compareOCRPageImp({
   let imageRotated = false;
 
   if (binaryImage) {
-    binaryImageBit = binaryImage.imageBitmap || await ca.getImageBitmap(binaryImage.src);
+    binaryImageBit =
+      binaryImage.imageBitmap || (await ca.getImageBitmap(binaryImage.src));
     imageUpscaled = binaryImage.upscaled;
     imageRotated = binaryImage.rotated;
   }
 
   const mode = options?.mode === undefined ? 'stats' : options?.mode;
   const editConf = options?.editConf === undefined ? false : options?.editConf;
-  const legacyLSTMComb = options?.legacyLSTMComb === undefined ? false : options?.legacyLSTMComb;
+  const legacyLSTMComb =
+    options?.legacyLSTMComb === undefined ? false : options?.legacyLSTMComb;
   const useBboxB = options?.useBboxB === undefined ? false : options?.useBboxB;
-  const debugLabel = options?.debugLabel === undefined ? '' : options?.debugLabel;
-  const evalConflicts = options?.evalConflicts === undefined ? true : options?.evalConflicts;
-  const supplementComp = options?.supplementComp === undefined ? false : options?.supplementComp;
-  const tessWorker = options?.tessWorker === undefined ? null : options?.tessWorker;
-  const ignorePunct = options?.ignorePunct === undefined ? false : options?.ignorePunct;
-  const ignoreCap = options?.ignoreCap === undefined ? false : options?.ignoreCap;
-  const confThreshHigh = options?.confThreshHigh === undefined ? 85 : options?.confThreshHigh;
-  const confThreshMed = options?.confThreshMed === undefined ? 75 : options?.confThreshMed;
-
-  if (supplementComp && !tessWorker) console.log('`supplementComp` enabled, but no scheduler was provided. This step will be skipped.');
+  const debugLabel =
+    options?.debugLabel === undefined ? '' : options?.debugLabel;
+  const evalConflicts =
+    options?.evalConflicts === undefined ? true : options?.evalConflicts;
+  const supplementComp =
+    options?.supplementComp === undefined ? false : options?.supplementComp;
+  const tessWorker =
+    options?.tessWorker === undefined ? null : options?.tessWorker;
+  const ignorePunct =
+    options?.ignorePunct === undefined ? false : options?.ignorePunct;
+  const ignoreCap =
+    options?.ignoreCap === undefined ? false : options?.ignoreCap;
+  const confThreshHigh =
+    options?.confThreshHigh === undefined ? 85 : options?.confThreshHigh;
+  const confThreshMed =
+    options?.confThreshMed === undefined ? 75 : options?.confThreshMed;
+
+  if (supplementComp && !tessWorker)
+    console.log(
+      '`supplementComp` enabled, but no scheduler was provided. This step will be skipped.'
+    );
 
   // If this is not being run in a worker, clone the data so the original is not edited.
   // This is not necessary when running in a worker, as the data is already cloned when sent to the worker.
@@ -563,7 +653,7 @@ export async function compareOCRPageImp({
     pageB = structuredClone(pageB);
   }
 
-  const imgAngle = imageRotated ? (pageMetricsObj.angle || 0) : 0;
+  const imgAngle = imageRotated ? pageMetricsObj.angle || 0 : 0;
   if (imageUpscaled) {
     ocr.scalePage(pageA, 2);
     ocr.scalePage(pageB, 2);
@@ -649,10 +739,12 @@ export async function compareOCRPageImp({
 
           if (wordA.visualCoords) {
             wordBoxACore.top = wordBoxA.top + Math.round(wordBoxAHeight * 0.1);
-            wordBoxACore.bottom = wordBoxA.bottom - Math.round(wordBoxAHeight * 0.1);
+            wordBoxACore.bottom =
+              wordBoxA.bottom - Math.round(wordBoxAHeight * 0.1);
           } else {
             wordBoxACore.top = wordBoxA.top + Math.round(wordBoxAHeight * 0.25);
-            wordBoxACore.bottom = wordBoxA.bottom - Math.round(wordBoxAHeight * 0.25);
+            wordBoxACore.bottom =
+              wordBoxA.bottom - Math.round(wordBoxAHeight * 0.25);
           }
 
           for (let l = minWordB; l < lineB.words.length; l++) {
@@ -668,11 +760,15 @@ export async function compareOCRPageImp({
             const wordBoxBCore = JSON.parse(JSON.stringify(wordBoxB));
 
             if (wordB.visualCoords) {
-              wordBoxBCore.top = wordBoxB.top + Math.round(wordBoxBHeight * 0.1);
-              wordBoxBCore.bottom = wordBoxB.bottom - Math.round(wordBoxBHeight * 0.1);
+              wordBoxBCore.top =
+                wordBoxB.top + Math.round(wordBoxBHeight * 0.1);
+              wordBoxBCore.bottom =
+                wordBoxB.bottom - Math.round(wordBoxBHeight * 0.1);
             } else {
-              wordBoxBCore.top = wordBoxB.top + Math.round(wordBoxBHeight * 0.25);
-              wordBoxBCore.bottom = wordBoxB.bottom - Math.round(wordBoxBHeight * 0.25);
+              wordBoxBCore.top =
+                wordBoxB.top + Math.round(wordBoxBHeight * 0.25);
+              wordBoxBCore.bottom =
+                wordBoxB.bottom - Math.round(wordBoxBHeight * 0.25);
             }
 
             // If left of word A is past right of word B, move to next word B
@@ -687,7 +783,10 @@ export async function compareOCRPageImp({
               // Otherwise, overlap is likely
             } else {
               // Check for overlap using word height
-              if (wordBoxACore.top > wordBoxBCore.bottom || wordBoxBCore.top > wordBoxACore.bottom) {
+              if (
+                wordBoxACore.top > wordBoxBCore.bottom ||
+                wordBoxBCore.top > wordBoxACore.bottom
+              ) {
                 continue;
               }
 
@@ -710,7 +809,8 @@ export async function compareOCRPageImp({
               hocrAOverlap[wordA.id] = 1;
               hocrBOverlap[wordB.id] = 1;
 
-              if (!hocrBOverlapAWords[wordB.id]) hocrBOverlapAWords[wordB.id] = {};
+              if (!hocrBOverlapAWords[wordB.id])
+                hocrBOverlapAWords[wordB.id] = {};
               hocrBOverlapAWords[wordB.id][wordA.id] = 1;
 
               // TODO: Account for cases without 1-to-1 mapping between bounding boxes
@@ -730,7 +830,10 @@ export async function compareOCRPageImp({
                 wordA.matchTruth = false;
 
                 // Check if there is a 1-to-1 comparison between words (this is usually true)
-                let oneToOne = Math.abs(wordBoxB.left - wordBoxA.left) + Math.abs(wordBoxB.right - wordBoxA.right) < (wordBoxA.right - wordBoxA.left) * 0.1;
+                let oneToOne =
+                  Math.abs(wordBoxB.left - wordBoxA.left) +
+                    Math.abs(wordBoxB.right - wordBoxA.right) <
+                  (wordBoxA.right - wordBoxA.left) * 0.1;
 
                 // Note: The following block solves an issue that I believe has been patched in our version of Tesseract.
                 // Due to a bug with the LSTM engine, when a word is split into 3 words (for example), the first and last word can have the right bound.
@@ -741,17 +844,32 @@ export async function compareOCRPageImp({
                 if (oneToOne && legacyLSTMComb) {
                   if (wordBNext3 && wordBNext3.text.length > 2) {
                     const wordBoxBNext3 = wordBNext3.bbox;
-                    if (Math.abs(wordBoxB.left - wordBoxA.left) + Math.abs(wordBoxA.right - wordBoxBNext3.right) < (wordBoxBNext3.right - wordBoxA.left) * 0.1) oneToOne = false;
+                    if (
+                      Math.abs(wordBoxB.left - wordBoxA.left) +
+                        Math.abs(wordBoxA.right - wordBoxBNext3.right) <
+                      (wordBoxBNext3.right - wordBoxA.left) * 0.1
+                    )
+                      oneToOne = false;
                   }
 
                   if (wordBNext2 && wordBNext2.text.length > 2) {
                     const wordBoxBNext2 = wordBNext2.bbox;
-                    if (Math.abs(wordBoxB.left - wordBoxA.left) + Math.abs(wordBoxA.right - wordBoxBNext2.right) < (wordBoxBNext2.right - wordBoxA.left) * 0.1) oneToOne = false;
+                    if (
+                      Math.abs(wordBoxB.left - wordBoxA.left) +
+                        Math.abs(wordBoxA.right - wordBoxBNext2.right) <
+                      (wordBoxBNext2.right - wordBoxA.left) * 0.1
+                    )
+                      oneToOne = false;
                   }
 
                   if (wordBNext && wordBNext.text.length > 2) {
                     const wordBoxBNext = wordBNext.bbox;
-                    if (Math.abs(wordBoxB.left - wordBoxA.left) + Math.abs(wordBoxA.right - wordBoxBNext.right) < (wordBoxBNext.right - wordBoxA.left) * 0.1) oneToOne = false;
+                    if (
+                      Math.abs(wordBoxB.left - wordBoxA.left) +
+                        Math.abs(wordBoxA.right - wordBoxBNext.right) <
+                      (wordBoxBNext.right - wordBoxA.left) * 0.1
+                    )
+                      oneToOne = false;
                   }
                 }
 
@@ -765,7 +883,11 @@ export async function compareOCRPageImp({
                     const wordANext = lineA.words[k + 1];
                     if (wordANext) {
                       const wordBoxANext = wordANext.bbox;
-                      if (Math.abs(wordBoxB.left - wordBoxA.left) + Math.abs(wordBoxB.right - wordBoxANext.right) < (wordBoxANext.right - wordBoxA.left) * 0.1) {
+                      if (
+                        Math.abs(wordBoxB.left - wordBoxA.left) +
+                          Math.abs(wordBoxB.right - wordBoxANext.right) <
+                        (wordBoxANext.right - wordBoxA.left) * 0.1
+                      ) {
                         twoToOne = true;
                         wordsAArr.push(wordA);
                         wordsAArr.push(wordANext);
@@ -779,7 +901,11 @@ export async function compareOCRPageImp({
                   } else {
                     if (wordBNext3) {
                       const wordBoxBNext3 = wordBNext3.bbox;
-                      if (Math.abs(wordBoxB.left - wordBoxA.left) + Math.abs(wordBoxA.right - wordBoxBNext3.right) < (wordBoxBNext3.right - wordBoxA.left) * 0.1) {
+                      if (
+                        Math.abs(wordBoxB.left - wordBoxA.left) +
+                          Math.abs(wordBoxA.right - wordBoxBNext3.right) <
+                        (wordBoxBNext3.right - wordBoxA.left) * 0.1
+                      ) {
                         twoToOne = true;
                         wordsAArr.push(wordA);
                         wordsBArr.push(wordB);
@@ -791,7 +917,11 @@ export async function compareOCRPageImp({
 
                     if (wordBNext2 && !twoToOne) {
                       const wordBoxBNext2 = wordBNext2.bbox;
-                      if (Math.abs(wordBoxB.left - wordBoxA.left) + Math.abs(wordBoxA.right - wordBoxBNext2.right) < (wordBoxBNext2.right - wordBoxA.left) * 0.1) {
+                      if (
+                        Math.abs(wordBoxB.left - wordBoxA.left) +
+                          Math.abs(wordBoxA.right - wordBoxBNext2.right) <
+                        (wordBoxBNext2.right - wordBoxA.left) * 0.1
+                      ) {
                         twoToOne = true;
                         wordsAArr.push(wordA);
                         wordsBArr.push(wordB);
@@ -802,7 +932,11 @@ export async function compareOCRPageImp({
 
                     if (wordBNext && !twoToOne) {
                       const wordBoxBNext = wordBNext.bbox;
-                      if (Math.abs(wordBoxB.left - wordBoxA.left) + Math.abs(wordBoxA.right - wordBoxBNext.right) < (wordBoxBNext.right - wordBoxA.left) * 0.1) {
+                      if (
+                        Math.abs(wordBoxB.left - wordBoxA.left) +
+                          Math.abs(wordBoxA.right - wordBoxBNext.right) <
+                        (wordBoxBNext.right - wordBoxA.left) * 0.1
+                      ) {
                         twoToOne = true;
                         wordsAArr.push(wordA);
                         wordsBArr.push(wordB);
@@ -815,34 +949,82 @@ export async function compareOCRPageImp({
                     if (twoToOne && legacyLSTMComb) {
                       const wordsAText = wordsAArr.map((x) => x.text).join('');
                       const wordsBText = wordsBArr.map((x) => x.text).join('');
-                      if (wordsAArr.length === 1 && wordsAArr[0]?.chars?.length === wordsAText.length && wordsAText.length === wordsBText.length) {
+                      if (
+                        wordsAArr.length === 1 &&
+                        wordsAArr[0]?.chars?.length === wordsAText.length &&
+                        wordsAText.length === wordsBText.length
+                      ) {
                         // To make sure the legacy boxes are comparable, either:
                         // (1) the text must be the same between Legacy and LSTM (aside from one word being split/combined), or
                         // (2) the LSTM version must have 2 words, one word matches, and the total number of letters is the same.
                         const match = wordsAText === wordsBText;
-                        const match1 = wordsAArr[0].text.substring(0, wordsBArr[0].text.length) === wordsBArr[0].text;
-                        const match2 = wordsAArr[0].text.substring(wordsBArr[0].text.length, wordsBArr[0].text.length + wordsBArr[1].text.length) === wordsBArr[1].text;
-
-                        if (match || (wordsBArr.length === 2 && (match1 || match2))) {
+                        const match1 =
+                          wordsAArr[0].text.substring(
+                            0,
+                            wordsBArr[0].text.length
+                          ) === wordsBArr[0].text;
+                        const match2 =
+                          wordsAArr[0].text.substring(
+                            wordsBArr[0].text.length,
+                            wordsBArr[0].text.length + wordsBArr[1].text.length
+                          ) === wordsBArr[1].text;
+
+                        if (
+                          match ||
+                          (wordsBArr.length === 2 && (match1 || match2))
+                        ) {
                           wordsBArr = wordsBArr.map((x) => ocr.cloneWord(x));
-                          wordsBArr[0].chars = wordsAArr[0].chars.slice(0, wordsBArr[0].text.length).map((x) => ocr.cloneChar(x));
-                          wordsBArr[1].chars = wordsAArr[0].chars.slice(wordsBArr[0].text.length, wordsBArr[0].text.length + wordsBArr[1].text.length).map((x) => ocr.cloneChar(x));
+                          wordsBArr[0].chars = wordsAArr[0].chars
+                            .slice(0, wordsBArr[0].text.length)
+                            .map((x) => ocr.cloneChar(x));
+                          wordsBArr[1].chars = wordsAArr[0].chars
+                            .slice(
+                              wordsBArr[0].text.length,
+                              wordsBArr[0].text.length +
+                                wordsBArr[1].text.length
+                            )
+                            .map((x) => ocr.cloneChar(x));
                           if (wordsBArr[2]) {
-                            wordsBArr[2].chars = wordsAArr[0].chars.slice(wordsBArr[0].text.length + wordsBArr[1].text.length,
-                              wordsBArr[0].text.length + wordsBArr[1].text.length + wordsBArr[2].text.length).map((x) => ocr.cloneChar(x));
+                            wordsBArr[2].chars = wordsAArr[0].chars
+                              .slice(
+                                wordsBArr[0].text.length +
+                                  wordsBArr[1].text.length,
+                                wordsBArr[0].text.length +
+                                  wordsBArr[1].text.length +
+                                  wordsBArr[2].text.length
+                              )
+                              .map((x) => ocr.cloneChar(x));
                           }
                           if (wordsBArr[3]) {
-                            wordsBArr[3].chars = wordsAArr[0].chars.slice(wordsBArr[0].text.length + wordsBArr[1].text.length + wordsBArr[2].text.length,
-                              wordsBArr[0].text.length + wordsBArr[1].text.length + wordsBArr[2].text.length + wordsBArr[3].text.length).map((x) => ocr.cloneChar(x));
+                            wordsBArr[3].chars = wordsAArr[0].chars
+                              .slice(
+                                wordsBArr[0].text.length +
+                                  wordsBArr[1].text.length +
+                                  wordsBArr[2].text.length,
+                                wordsBArr[0].text.length +
+                                  wordsBArr[1].text.length +
+                                  wordsBArr[2].text.length +
+                                  wordsBArr[3].text.length
+                              )
+                              .map((x) => ocr.cloneChar(x));
                           }
                           if (!match) {
-                            wordsBArr[0].chars.forEach((x, i) => x.text = wordsBArr[0].text[i]);
-                            wordsBArr[1].chars.forEach((x, i) => x.text = wordsBArr[1].text[i]);
-                            if (wordsBArr[2]) wordsBArr[2].chars.forEach((x, i) => x.text = wordsBArr[2].text[i]);
+                            wordsBArr[0].chars.forEach(
+                              (x, i) => (x.text = wordsBArr[0].text[i])
+                            );
+                            wordsBArr[1].chars.forEach(
+                              (x, i) => (x.text = wordsBArr[1].text[i])
+                            );
+                            if (wordsBArr[2])
+                              wordsBArr[2].chars.forEach(
+                                (x, i) => (x.text = wordsBArr[2].text[i])
+                              );
                           }
                           for (const word of wordsBArr) {
                             // @ts-ignore
-                            word.bbox = ocr.calcBboxUnion(word.chars.map((x) => x.bbox));
+                            word.bbox = ocr.calcBboxUnion(
+                              word.chars.map((x) => x.bbox)
+                            );
                           }
                         }
                       }
@@ -865,13 +1047,20 @@ export async function compareOCRPageImp({
                   hocrBError = 0;
                 } else if (oneToOne) {
                   // Some common patterns detected by Tesseract Legacy are so implausible that they are automatically rejected.
-                  if (legacyLSTMComb && rejectWordLegacy(wordA.text, wordB.text)) {
+                  if (
+                    legacyLSTMComb &&
+                    rejectWordLegacy(wordA.text, wordB.text)
+                  ) {
                     hocrBError = 0;
-                  // If the top choice out of the Tesseract Legacy classifier (but not entire model) is the same as the Tesseract LSTM choice, use the LSTM choice.
-                  // This condition is common when the Legacy model improperly applies a dictionary "correction" to a word that was already correct.
-                  } else if (legacyLSTMComb && wordA.textAlt && wordA.textAlt === wordB.text) {
+                    // If the top choice out of the Tesseract Legacy classifier (but not entire model) is the same as the Tesseract LSTM choice, use the LSTM choice.
+                    // This condition is common when the Legacy model improperly applies a dictionary "correction" to a word that was already correct.
+                  } else if (
+                    legacyLSTMComb &&
+                    wordA.textAlt &&
+                    wordA.textAlt === wordB.text
+                  ) {
                     hocrBError = 0;
-                  // Otherwise, the words are compared visually.
+                    // Otherwise, the words are compared visually.
                   } else {
                     // TODO: Figure out how to compare between small caps/non small-caps words (this is the only relevant style as it is the only style LSTM detects)
                     // Clone hocrAWord and set text content equal to hocrBWord
@@ -884,30 +1073,55 @@ export async function compareOCRPageImp({
                     }
 
                     const evalRes = await evalWords({
-                      wordsA: [wordA], wordsB: [wordAClone], binaryImage: binaryImageBit, angle: imgAngle, options: { view: Boolean(debugLabel) },
+                      wordsA: [wordA],
+                      wordsB: [wordAClone],
+                      binaryImage: binaryImageBit,
+                      angle: imgAngle,
+                      options: { view: Boolean(debugLabel) },
                     });
 
-                    hocrAError = evalRes.metricA + (await penalizeWord([wordA]));
-                    hocrBError = evalRes.metricB + (await penalizeWord([wordB]));
+                    hocrAError =
+                      evalRes.metricA + (await penalizeWord([wordA]));
+                    hocrBError =
+                      evalRes.metricB + (await penalizeWord([wordB]));
 
                     // Reject Tesseract Legacy word if appropriate
-                    if (legacyLSTMComb && rejectWordLegacy(wordA.text, wordB.text)) hocrBError = 0;
+                    if (
+                      legacyLSTMComb &&
+                      rejectWordLegacy(wordA.text, wordB.text)
+                    )
+                      hocrBError = 0;
 
                     // The alternative word from Tesseract legacy is tested if both other options are rejected.
                     // This can be useful for relatively high-quality scans of non-dictionary words, which both the LSTM model and the Legacy model (after dictionary correction) may fail on,
                     // with the raw results from the Legacy classifier being the most accurate.
-                    if (legacyLSTMComb && hocrAError > 0.5 && hocrBError > 0.5 && wordA.textAlt && wordA.textAlt !== wordB.text) {
+                    if (
+                      legacyLSTMComb &&
+                      hocrAError > 0.5 &&
+                      hocrBError > 0.5 &&
+                      wordA.textAlt &&
+                      wordA.textAlt !== wordB.text
+                    ) {
                       wordAClone.text = wordA.textAlt;
 
                       // This would run faster if it was built into the original evalWords function, but this case should be rare enough that it doesn't matter.
                       const evalResAlt = await evalWords({
-                        wordsA: [wordAClone], binaryImage: binaryImageBit, angle: imgAngle, options: { view: Boolean(debugLabel) },
+                        wordsA: [wordAClone],
+                        binaryImage: binaryImageBit,
+                        angle: imgAngle,
+                        options: { view: Boolean(debugLabel) },
                       });
 
-                      hocrAAltError = evalResAlt.metricA + (await penalizeWord([wordAClone]));
+                      hocrAAltError =
+                        evalResAlt.metricA + (await penalizeWord([wordAClone]));
 
                       // To use the alt word, the error must be less than 0.5, and the alt word but be at least 0.1 better than both other options.
-                      if (hocrAAltError >= 0.5 || (hocrAError - hocrAAltError) < 0.1 || (hocrBError - hocrAAltError) < 0.1) hocrAAltError = 1;
+                      if (
+                        hocrAAltError >= 0.5 ||
+                        hocrAError - hocrAAltError < 0.1 ||
+                        hocrBError - hocrAAltError < 0.1
+                      )
+                        hocrAAltError = 1;
                     }
 
                     if (evalRes.debug) {
@@ -922,16 +1136,29 @@ export async function compareOCRPageImp({
                   const wordsAText = wordsAArr.map((x) => x.text).join('');
                   const wordsBText = wordsBArr.map((x) => x.text).join('');
 
-                  if (legacyLSTMComb && rejectWordLegacy(wordsAText, wordsBText)) {
+                  if (
+                    legacyLSTMComb &&
+                    rejectWordLegacy(wordsAText, wordsBText)
+                  ) {
                     hocrBError = 0;
                   } else {
                     const evalRes = await evalWords({
-                      wordsA: wordsAArr, wordsB: wordsBArr, binaryImage: binaryImageBit, angle: imgAngle, options: { view: Boolean(debugLabel) },
+                      wordsA: wordsAArr,
+                      wordsB: wordsBArr,
+                      binaryImage: binaryImageBit,
+                      angle: imgAngle,
+                      options: { view: Boolean(debugLabel) },
                     });
 
                     // The option with more words has a small penalty added, as otherwise words incorrectly split will often score slightly better (due to more precise positioning)
-                    hocrAError = evalRes.metricA + (wordsAArr.length - 1) * 0.025 + (await penalizeWord(wordsAArr));
-                    hocrBError = evalRes.metricB + (wordsBArr.length - 1) * 0.025 + (await penalizeWord(wordsBArr));
+                    hocrAError =
+                      evalRes.metricA +
+                      (wordsAArr.length - 1) * 0.025 +
+                      (await penalizeWord(wordsAArr));
+                    hocrBError =
+                      evalRes.metricB +
+                      (wordsBArr.length - 1) * 0.025 +
+                      (await penalizeWord(wordsBArr));
 
                     // An additional penalty is added to the option with more words when (1) the text is the same in both options and (2) at least one word has no letters.
                     // This has 2 primary motivations:
@@ -940,14 +1167,25 @@ export async function compareOCRPageImp({
                     //    TODO: It may be worth investigating if this issue can be improved in the engine.
                     //  1. Punctuation characters should not be their own word (e.g. quotes should come before/after alphanumeric characters)
                     if (wordsAText === wordsBText) {
-                      if (wordsAArr.map((x) => /[a-z]/i.test(x.text)).filter((x) => !x).length > 0 || wordsBArr.map((x) => /[a-z]/i.test(x.text)).filter((x) => !x).length > 0) {
+                      if (
+                        wordsAArr
+                          .map((x) => /[a-z]/i.test(x.text))
+                          .filter((x) => !x).length > 0 ||
+                        wordsBArr
+                          .map((x) => /[a-z]/i.test(x.text))
+                          .filter((x) => !x).length > 0
+                      ) {
                         hocrAError += (wordsAArr.length - 1) * 0.05;
                         hocrBError += (wordsBArr.length - 1) * 0.05;
                       }
                     }
 
                     // Reject Tesseract Legacy word if appropriate
-                    if (legacyLSTMComb && rejectWordLegacy(wordsAText, wordsBText)) hocrBError = 0;
+                    if (
+                      legacyLSTMComb &&
+                      rejectWordLegacy(wordsAText, wordsBText)
+                    )
+                      hocrBError = 0;
 
                     if (evalRes.debug) {
                       const debugObj = evalRes.debug;
@@ -961,8 +1199,13 @@ export async function compareOCRPageImp({
 
                 // The LSTM model is known to be more accurate on average.
                 // Therefore, if both metrics are terrible (indicating the word isn't lined up at all), the LSTM word is used.
-                if ((hocrBError < hocrAError && hocrBError < hocrAAltError) || (legacyLSTMComb && hocrAError > 0.5 && hocrAAltError > 0.5)) {
-                  const skip = ['eg', 'ie'].includes(wordA.text.replace(/\W/g, ''));
+                if (
+                  (hocrBError < hocrAError && hocrBError < hocrAAltError) ||
+                  (legacyLSTMComb && hocrAError > 0.5 && hocrAAltError > 0.5)
+                ) {
+                  const skip = ['eg', 'ie'].includes(
+                    wordA.text.replace(/\W/g, '')
+                  );
 
                   if (!skip) {
                     if (oneToOne) {
@@ -979,7 +1222,9 @@ export async function compareOCRPageImp({
                       // This is not relevant for italics as the LSTM engine does not detect italics.
                       if (wordB.smallCaps) wordA.smallCaps = true;
                     } else {
-                      const wordsBArrRep = wordsBArr.map((x) => ocr.cloneWord(x));
+                      const wordsBArrRep = wordsBArr.map((x) =>
+                        ocr.cloneWord(x)
+                      );
 
                       lineWordsEditedNew += wordsBArrRep.length;
                       lineBReplace = lineB;
@@ -1017,9 +1262,14 @@ export async function compareOCRPageImp({
                       break;
                     }
                   }
-                } else if (wordA.textAlt && hocrAAltError < 0.5 && hocrAAltError < hocrAError) {
+                } else if (
+                  wordA.textAlt &&
+                  hocrAAltError < 0.5 &&
+                  hocrAAltError < hocrAError
+                ) {
                   lineWordsEditedNew += 1;
-                  if (wordA.text.length !== wordA.textAlt.length) wordA.chars = null;
+                  if (wordA.text.length !== wordA.textAlt.length)
+                    wordA.chars = null;
                   wordA.text = wordA.textAlt;
                 }
               }
@@ -1045,9 +1295,18 @@ export async function compareOCRPageImp({
       for (let j = 0; j < line.words.length; j++) {
         const word = line.words[j];
         if (!word.compTruth) {
-          const res = await checkWords([word], binaryImageBit, imageRotated, pageMetricsObj, tessWorker, {
-            ignorePunct, tessWorker, view: false,
-          });
+          const res = await checkWords(
+            [word],
+            binaryImageBit,
+            imageRotated,
+            pageMetricsObj,
+            tessWorker,
+            {
+              ignorePunct,
+              tessWorker,
+              view: false,
+            }
+          );
           word.matchTruth = res.match;
           word.conf = word.matchTruth ? 100 : 0;
         }
@@ -1062,7 +1321,9 @@ export async function compareOCRPageImp({
     if (imageUpscaled) ocr.scalePage(pageAInt, 0.5);
 
     return {
-      page: pageAInt, metrics: null, debugImg,
+      page: pageAInt,
+      metrics: null,
+      debugImg,
     };
   }
 
@@ -1081,13 +1342,19 @@ export async function compareOCRPageImp({
 
   // Delete any punctuation-only words from the stats if they are being ignored.
   if (ignorePunct) {
-    const punctOnlyIDsA = ocr.getPageWords(pageA).filter((x) => !x.text.replace(/[\W_]/g, '')).map((x) => x.id);
+    const punctOnlyIDsA = ocr
+      .getPageWords(pageA)
+      .filter((x) => !x.text.replace(/[\W_]/g, ''))
+      .map((x) => x.id);
     punctOnlyIDsA.forEach((x) => {
       delete hocrAAll[x];
       delete hocrAOverlap[x];
       delete hocrACorrect[x];
     });
-    const punctOnlyIDsB = ocr.getPageWords(pageB).filter((x) => !x.text.replace(/[\W_]/g, '')).map((x) => x.id);
+    const punctOnlyIDsB = ocr
+      .getPageWords(pageB)
+      .filter((x) => !x.text.replace(/[\W_]/g, ''))
+      .map((x) => x.id);
     punctOnlyIDsB.forEach((x) => {
       delete hocrBAll[x];
       delete hocrBOverlap[x];
@@ -1164,7 +1431,9 @@ export async function compareOCRPageImp({
   if (imageUpscaled) ocr.scalePage(pageAInt, 0.5);
 
   return {
-    page: pageAInt, metrics: metricsRet, debugImg,
+    page: pageAInt,
+    metrics: metricsRet,
+    debugImg,
   };
 }
 
@@ -1178,13 +1447,22 @@ export async function compareOCRPageImp({
  * @param {boolean} [options.ignorePunct]
  * @param {boolean} [options.ignoreCap]
  */
-export async function checkWords(wordsA, binaryImage, imageRotated, pageMetricsObj, tessWorker, options = {}) {
+export async function checkWords(
+  wordsA,
+  binaryImage,
+  imageRotated,
+  pageMetricsObj,
+  tessWorker,
+  options = {}
+) {
   const view = options?.view === undefined ? false : options?.view;
-  const ignorePunct = options?.ignorePunct === undefined ? false : options?.ignorePunct;
-  const ignoreCap = options?.ignoreCap === undefined ? false : options?.ignoreCap;
+  const ignorePunct =
+    options?.ignorePunct === undefined ? false : options?.ignorePunct;
+  const ignoreCap =
+    options?.ignoreCap === undefined ? false : options?.ignoreCap;
 
   // Draw the actual words (from the user-provided image)
-  const angle = imageRotated ? (pageMetricsObj.angle || 0) : 0;
+  const angle = imageRotated ? pageMetricsObj.angle || 0 : 0;
   // const ctxViewArr = view ? [{ canvas: viewCanvas0, ctx: viewCtx0 }, { canvas: viewCanvas1, ctx: viewCtx1 }, { canvas: viewCanvas2, ctx: viewCtx2 }] : undefined;
   const { canvas } = await drawWordActual(wordsA, binaryImage, angle);
 
@@ -1192,7 +1470,7 @@ export async function checkWords(wordsA, binaryImage, imageRotated, pageMetricsO
     tessedit_pageseg_mode: '6', // "Single block"
   };
 
-  const inputImage = typeof process === 'undefined' ? await canvas.convertToBlob() : await canvas.toDataURL();
+  const inputImage = await canvas.convertToBlob();
 
   const res = (await tessWorker.recognize(inputImage, extraConfig)).data;
 
@@ -1226,7 +1504,11 @@ export async function checkWords(wordsA, binaryImage, imageRotated, pageMetricsO
  * @returns
  */
 export async function evalPageBase({
-  page, binaryImage, pageMetricsObj, func = null, view = false,
+  page,
+  binaryImage,
+  pageMetricsObj,
+  func = null,
+  view = false,
 }) {
   // If this is not being run in a worker, clone the data so the original is not edited.
   // This is not necessary when running in a worker, as the data is already cloned when sent to the worker.
@@ -1236,16 +1518,18 @@ export async function evalPageBase({
 
   const lines = 'lines' in page ? page.lines : [page];
 
-  const imgAngle = binaryImage.rotated ? (pageMetricsObj.angle || 0) : 0;
+  const imgAngle = binaryImage.rotated ? pageMetricsObj.angle || 0 : 0;
   if (binaryImage.upscaled) {
     for (let i = 0; i < lines.length; i++) {
       ocr.scaleLine(lines[i], 2);
     }
   }
 
-  const binaryImageBit = binaryImage.imageBitmap || await ca.getImageBitmap(binaryImage.src);
+  const binaryImageBit =
+    binaryImage.imageBitmap || (await ca.getImageBitmap(binaryImage.src));
 
-  if (!FontCont.raw) throw new Error('Fonts must be defined before running this function.');
+  if (!FontCont.raw)
+    throw new Error('Fonts must be defined before running this function.');
 
   let metricTotal = 0;
   let wordsTotal = 0;
@@ -1264,10 +1548,13 @@ export async function evalPageBase({
     if (!ocrLineJ) continue;
 
     const evalRes = await evalWords({
-      wordsA: ocrLineJ.words, binaryImage: binaryImageBit, angle: imgAngle, options: { view },
+      wordsA: ocrLineJ.words,
+      binaryImage: binaryImageBit,
+      angle: imgAngle,
+      options: { view },
     });
 
-    metricTotal += (evalRes.metricA * ocrLineJ.words.length);
+    metricTotal += evalRes.metricA * ocrLineJ.words.length;
 
     wordsTotal += ocrLineJ.words.length;
 
@@ -1287,7 +1574,11 @@ export async function evalPageBase({
  * @returns
  */
 export async function evalPageFont({
-  page, binaryImage, pageMetricsObj, font, opt = false,
+  page,
+  binaryImage,
+  pageMetricsObj,
+  font,
+  opt = false,
 }) {
   const enableOptSave = FontCont.enableOpt;
   const forceOptSave = FontCont.forceOpt;
@@ -1295,7 +1586,8 @@ export async function evalPageFont({
   // Allowing the font to be set here allows for better performance during font optimization compared to using the `enableFontOpt` function.
   // This is because the `enableFontOpt` function requires a response from the main thread and *every* worker before completing, which leads to non-trivial waiting time.
   if (opt === true) {
-    if (!FontCont.opt) throw new Error('Optimized fonts requested but not defined.');
+    if (!FontCont.opt)
+      throw new Error('Optimized fonts requested but not defined.');
     FontCont.forceOpt = true;
   } else if (opt === false) {
     if (!FontCont.raw) throw new Error('Raw fonts requested but not defined.');
@@ -1304,10 +1596,11 @@ export async function evalPageFont({
   }
 
   /**
- * @param {OcrLine} ocrLineJ
- */
+   * @param {OcrLine} ocrLineJ
+   */
   const transformLineFont = (ocrLineJ) => {
-    if (!FontCont.raw) throw new Error('Fonts must be defined before running this function.');
+    if (!FontCont.raw)
+      throw new Error('Fonts must be defined before running this function.');
 
     if (!ocrLineJ.words[0]) {
       console.log('Line has 0 words, this should not happen.');
@@ -1315,7 +1608,9 @@ export async function evalPageFont({
     }
 
     // If the font is not set for a specific word, whether it is assumed sans/serif will be determined by the default font.
-    const lineFontType = ocrLineJ.words[0].font ? FontCont.getWordFont(ocrLineJ.words[0]).type : FontCont.getFont('Default').type;
+    const lineFontType = ocrLineJ.words[0].font
+      ? FontCont.getWordFont(ocrLineJ.words[0]).type
+      : FontCont.getFont('Default').type;
 
     if (FontCont.raw[font].normal.type !== lineFontType) return null;
 
@@ -1329,7 +1624,10 @@ export async function evalPageFont({
   };
 
   const res = await evalPageBase({
-    page, binaryImage, pageMetricsObj, func: transformLineFont,
+    page,
+    binaryImage,
+    pageMetricsObj,
+    func: transformLineFont,
   });
 
   FontCont.enableOpt = enableOptSave;
@@ -1348,7 +1646,11 @@ export async function evalPageFont({
  * @returns
  */
 export async function nudgePageBase({
-  page, binaryImage, pageMetricsObj, func, view = false,
+  page,
+  binaryImage,
+  pageMetricsObj,
+  func,
+  view = false,
 }) {
   // If this is not being run in a worker, clone the data so the original is not edited.
   // This is not necessary when running in a worker, as the data is already cloned when sent to the worker.
@@ -1356,15 +1658,18 @@ export async function nudgePageBase({
     page = structuredClone(page);
   }
 
-  const imgAngle = binaryImage.rotated ? (pageMetricsObj.angle || 0) : 0;
+  const imgAngle = binaryImage.rotated ? pageMetricsObj.angle || 0 : 0;
   if (binaryImage.upscaled) {
     ocr.scalePage(page, 2);
   }
 
-  const binaryImageBit = binaryImage.imageBitmap || await ca.getImageBitmap(binaryImage.src);
+  const binaryImageBit =
+    binaryImage.imageBitmap || (await ca.getImageBitmap(binaryImage.src));
 
-  if (!FontCont.raw) throw new Error('Fonts must be defined before running this function.');
-  if (!calcCtx) throw new Error('Canvases must be defined before running this function.');
+  if (!FontCont.raw)
+    throw new Error('Fonts must be defined before running this function.');
+  if (!calcCtx)
+    throw new Error('Canvases must be defined before running this function.');
 
   let improveCt = 0;
   let totalCt = 0;
@@ -1379,7 +1684,11 @@ export async function nudgePageBase({
       if (!ocrLineJClone) return false;
 
       const evalRes = await evalWords({
-        wordsA: ocrLineJ.words, wordsB: ocrLineJClone.words, binaryImage: binaryImageBit, angle: imgAngle, options: { view, useAFontSize: false, useABaseline: false },
+        wordsA: ocrLineJ.words,
+        wordsB: ocrLineJClone.words,
+        binaryImage: binaryImageBit,
+        angle: imgAngle,
+        options: { view, useAFontSize: false, useABaseline: false },
       });
 
       if (evalRes.debug) debugImg.push(evalRes.debug);
@@ -1406,7 +1715,10 @@ export async function nudgePageBase({
   }
 
   return {
-    page, improveCt, totalCt, debug: view ? debugImg : null,
+    page,
+    improveCt,
+    totalCt,
+    debug: view ? debugImg : null,
   };
 }
 
@@ -1419,7 +1731,10 @@ export async function nudgePageBase({
  * @returns
  */
 export async function nudgePageFontSize({
-  page, binaryImage, pageMetricsObj, view = false,
+  page,
+  binaryImage,
+  pageMetricsObj,
+  view = false,
 }) {
   const func = async (lineJ, x) => {
     const fontSizeBase = calcLineFontSize(lineJ);
@@ -1428,7 +1743,11 @@ export async function nudgePageFontSize({
   };
 
   return await nudgePageBase({
-    page, binaryImage, pageMetricsObj, func, view,
+    page,
+    binaryImage,
+    pageMetricsObj,
+    func,
+    view,
   });
 }
 
@@ -1441,14 +1760,21 @@ export async function nudgePageFontSize({
  * @returns
  */
 export async function nudgePageBaseline({
-  page, binaryImage, pageMetricsObj, view = false,
+  page,
+  binaryImage,
+  pageMetricsObj,
+  view = false,
 }) {
   const func = async (lineJ, x) => {
     lineJ.baseline[1] += x;
   };
 
   return await nudgePageBase({
-    page, binaryImage, pageMetricsObj, func, view,
+    page,
+    binaryImage,
+    pageMetricsObj,
+    func,
+    view,
   });
 }
 
@@ -1470,12 +1796,19 @@ export async function nudgePageBaseline({
  *
  */
 export const renderPageStaticImp = async ({
-  page, image, angle = 0, displayMode = 'proof', confThreshMed = 75, confThreshHigh = 85,
+  page,
+  image,
+  angle = 0,
+  displayMode = 'proof',
+  confThreshMed = 75,
+  confThreshHigh = 85,
 }) => {
   const dims = image ? imageUtils.getDims(image) : page.dims;
 
   const canvas = await ca.createCanvas(dims.width, dims.height);
-  const ctx = /** @type {OffscreenCanvasRenderingContext2D} */ (/** @type {unknown} */ (canvas.getContext('2d')));
+  const ctx = /** @type {OffscreenCanvasRenderingContext2D} */ (
+    /** @type {unknown} */ (canvas.getContext('2d'))
+  );
 
   const imageBit = await ca.getImageBitmap(image.src);
   if (image) ctx.drawImage(imageBit, 0, 0);
@@ -1488,15 +1821,25 @@ export const renderPageStaticImp = async ({
   const cosAngle = Math.cos(angle * (Math.PI / 180));
 
   for (const lineObj of page.lines) {
-    const angleAdjLine = image.rotated ? ocr.calcLineStartAngleAdj(lineObj) : { x: 0, y: 0 };
+    const angleAdjLine = image.rotated
+      ? ocr.calcLineStartAngleAdj(lineObj)
+      : { x: 0, y: 0 };
 
-    const baselineY = lineObj.bbox.bottom + lineObj.baseline[1] + angleAdjLine.y;
+    const baselineY =
+      lineObj.bbox.bottom + lineObj.baseline[1] + angleAdjLine.y;
     const lineLeftAdj = lineObj.bbox.left + angleAdjLine.x;
 
     const rotateText = !image?.rotated;
 
     if (rotateText) {
-      ctx.setTransform(cosAngle, sinAngle, -sinAngle, cosAngle, lineLeftAdj, baselineY);
+      ctx.setTransform(
+        cosAngle,
+        sinAngle,
+        -sinAngle,
+        cosAngle,
+        lineLeftAdj,
+        baselineY
+      );
     } else {
       ctx.setTransform(1, 0, 0, 1, lineLeftAdj, baselineY);
     }
@@ -1504,11 +1847,18 @@ export const renderPageStaticImp = async ({
     for (const wordObj of lineObj.words) {
       if (!wordObj.text) continue;
 
-      const { fill, opacity } = ocr.getWordFillOpacity(wordObj, displayMode, confThreshMed, confThreshHigh);
+      const { fill, opacity } = ocr.getWordFillOpacity(
+        wordObj,
+        displayMode,
+        confThreshMed,
+        confThreshHigh
+      );
 
       ctx.fillStyle = fill;
 
-      const angleAdjWord = wordObj.sup ? ocr.calcWordAngleAdj(wordObj) : { x: 0, y: 0 };
+      const angleAdjWord = wordObj.sup
+        ? ocr.calcWordAngleAdj(wordObj)
+        : { x: 0, y: 0 };
 
       const wordMetrics = calcWordMetrics(wordObj);
       const advanceArr = wordMetrics.advanceArr;
@@ -1520,10 +1870,16 @@ export const renderPageStaticImp = async ({
       // TODO: Test whether the math here is correct for drop caps.
       let ts = 0;
       if (wordObj.sup || wordObj.dropcap) {
-        ts = (lineObj.bbox.bottom + lineObj.baseline[1] + angleAdjLine.y) - (wordObj.bbox.bottom + angleAdjLine.y + angleAdjWord.y);
+        ts =
+          lineObj.bbox.bottom +
+          lineObj.baseline[1] +
+          angleAdjLine.y -
+          (wordObj.bbox.bottom + angleAdjLine.y + angleAdjWord.y);
         if (!wordObj.visualCoords) {
           const font = FontCont.getWordFont(wordObj);
-          const fontDesc = font.opentype.descender / font.opentype.unitsPerEm * wordMetrics.fontSize;
+          const fontDesc =
+            (font.opentype.descender / font.opentype.unitsPerEm) *
+            wordMetrics.fontSize;
           ts -= fontDesc;
         }
       } else {
@@ -1545,7 +1901,9 @@ export const renderPageStaticImp = async ({
 
       const font = FontCont.getWordFont(wordObj);
       ctx.font = `${font.fontFaceStyle} ${font.fontFaceWeight} ${wordFontSize}px ${font.fontFaceName}`;
-      let leftI = wordObj.visualCoords ? visualLeft - leftSideBearing : visualLeft;
+      let leftI = wordObj.visualCoords
+        ? visualLeft - leftSideBearing
+        : visualLeft;
       for (let i = 0; i < wordMetrics.charArr.length; i++) {
         let charI = wordMetrics.charArr[i];
 
@@ -1554,7 +1912,9 @@ export const renderPageStaticImp = async ({
             ctx.font = `${font.fontFaceStyle} ${font.fontFaceWeight} ${wordFontSize}px ${font.fontFaceName}`;
           } else {
             charI = charI.toUpperCase();
-            ctx.font = `${font.fontFaceStyle} ${font.fontFaceWeight} ${wordFontSize * font.smallCapsMult}px ${font.fontFaceName}`;
+            ctx.font = `${font.fontFaceStyle} ${font.fontFaceWeight} ${
+              wordFontSize * font.smallCapsMult
+            }px ${font.fontFaceName}`;
           }
         }
 
@@ -1564,7 +1924,7 @@ export const renderPageStaticImp = async ({
     }
   }
 
-  const img = typeof process === 'undefined' ? await canvas.convertToBlob() : await canvas.toDataURL();
+  const img = await canvas.convertToBlob();
 
   return img;
 };
diff --git a/js/worker/generalWorker.js b/js/worker/generalWorker.js
index 0fcce32dcc11369f67d96930ea81b25897433b0c..43d6f6367c38f41e56388a47ab65bd2963fc752a 100644
--- a/js/worker/generalWorker.js
+++ b/js/worker/generalWorker.js
@@ -15,10 +15,14 @@ import {
 } from './compareOCRModule.js';
 import { optimizeFont } from './optimizeFontModule.js';
 
-const parentPort = typeof process === 'undefined' ? globalThis : (await import('worker_threads')).parentPort;
+const parentPort = true
+  ? globalThis
+  : (await import('worker_threads')).parentPort;
 if (!parentPort) throw new Error('This file must be run in a worker');
 
-const Tesseract = typeof process === 'undefined' ? (await import('../../tess/tesseract.esm.min.js')).default : await import('@scribe.js/tesseract.js');
+const Tesseract = true
+  ? (await import('../../tess/tesseract.esm.min.js')).default
+  : await import('@scribe.js/tesseract.js');
 
 // TODO: Add back support for multiple PSM modes.
 // There is already an advanced option in the UI that claims to switch this, but it currently does nothing.
@@ -65,23 +69,31 @@ let vanillaMode_ = false;
 // Second, >99% of devices now support the SIMD version, so only using the SIMD version is fine.
 let corePath;
 if (vanillaMode_) {
-  corePath = new URL('../../tess/core_vanilla/tesseract-core-simd.wasm.js', import.meta.url).href;
+  corePath = new URL(
+    '../../tess/core_vanilla/tesseract-core-simd.wasm.js',
+    import.meta.url
+  ).href;
 } else {
-  corePath = new URL('../../tess/core/tesseract-core-simd.wasm.js', import.meta.url).href;
+  corePath = new URL(
+    '../../tess/core/tesseract-core-simd.wasm.js',
+    import.meta.url
+  ).href;
 }
 
 const workerPath = new URL('../../tess/worker.min.js', import.meta.url).href;
 
 // Custom build is currently only used for browser version, while the Node.js version uses the published npm package.
 // If recognition capabilities are ever added for the Node.js version, then we should use the same build for consistency. .
-const tessOptions = typeof process === 'undefined' ? {
-  corePath,
-  workerPath,
-  // langPath: '/tess/tessdata_dist',
-  legacyCore: true,
-  legacyLang: true,
-  workerBlobURL: false,
-} : { legacyCore: true, legacyLang: true };
+const tessOptions = true
+  ? {
+      corePath,
+      workerPath,
+      // langPath: '/tess/tessdata_dist',
+      legacyCore: true,
+      legacyLang: true,
+      workerBlobURL: false,
+    }
+  : { legacyCore: true, legacyLang: true };
 
 /** @type {?Tesseract.Worker} */
 let worker;
@@ -100,11 +112,11 @@ let workerLSTM;
  * @param {?boolean} param.vanillaMode
  * @param {Object<string, string>} param.config - Config params to pass to to Tesseract.js.
  */
-const reinitialize = async ({
-  langs, oem, vanillaMode, config,
-}) => {
+const reinitialize = async ({ langs, oem, vanillaMode, config }) => {
   const langArr = typeof langs === 'string' ? langs.split('+') : langs;
-  const changeLang = langs && JSON.stringify(langArr.sort()) !== JSON.stringify(langArrCurrent.sort());
+  const changeLang =
+    langs &&
+    JSON.stringify(langArr.sort()) !== JSON.stringify(langArrCurrent.sort());
   // oem can be 0, so using "truthy" checks does not work
   const changeOEM = oem !== null && oem !== undefined && oem !== oemCurrent;
   const changeVanilla = vanillaMode && vanillaMode !== vanillaMode_;
@@ -119,7 +131,9 @@ const reinitialize = async ({
   if (changeOEM) oemCurrent = oem;
   if (changeVanilla) vanillaMode_ = vanillaMode;
 
-  const initConfigs = vanillaMode_ ? structuredClone(defaultInitConfigsVanilla) : structuredClone(defaultInitConfigs);
+  const initConfigs = vanillaMode_
+    ? structuredClone(defaultInitConfigsVanilla)
+    : structuredClone(defaultInitConfigs);
 
   const defaultConfigsI = vanillaMode_ ? defaultConfigsVanilla : defaultConfigs;
   for (const [key, value] of Object.entries(defaultConfigsI)) {
@@ -136,13 +150,24 @@ const reinitialize = async ({
   // or if it was never created in the first place.
   if (changeVanilla || !worker) {
     if (vanillaMode_) {
-      tessOptions.corePath = new URL('../../tess/core_vanilla/tesseract-core-simd.wasm.js', import.meta.url).href;
+      tessOptions.corePath = new URL(
+        '../../tess/core_vanilla/tesseract-core-simd.wasm.js',
+        import.meta.url
+      ).href;
     } else {
-      tessOptions.corePath = new URL('../../tess/core/tesseract-core-simd.wasm.js', import.meta.url).href;
+      tessOptions.corePath = new URL(
+        '../../tess/core/tesseract-core-simd.wasm.js',
+        import.meta.url
+      ).href;
     }
 
     if (worker) await worker.terminate();
-    worker = await Tesseract.createWorker(langArrCurrent, oemCurrent, tessOptions, initConfigs);
+    worker = await Tesseract.createWorker(
+      langArrCurrent,
+      oemCurrent,
+      tessOptions,
+      initConfigs
+    );
   } else {
     await worker.reinitialize(langArrCurrent, oemCurrent, initConfigs);
   }
@@ -162,22 +187,32 @@ const reinitialize = async ({
  */
 const reinitialize2 = async ({ langs, vanillaMode }) => {
   const langArr = typeof langs === 'string' ? langs.split('+') : langs;
-  const changeLang = langs && JSON.stringify(langArr.sort()) !== JSON.stringify(langArrCurrent.sort());
+  const changeLang =
+    langs &&
+    JSON.stringify(langArr.sort()) !== JSON.stringify(langArrCurrent.sort());
   const changeVanilla = vanillaMode && vanillaMode !== vanillaMode_;
 
   if (!changeLang && !changeVanilla && workerLegacy && workerLSTM) return;
   if (changeLang) langArrCurrent = langArr;
   if (changeVanilla) vanillaMode_ = vanillaMode;
 
-  const initConfigs = vanillaMode_ ? defaultInitConfigsVanilla : defaultInitConfigs;
+  const initConfigs = vanillaMode_
+    ? defaultInitConfigsVanilla
+    : defaultInitConfigs;
 
   // The worker only needs to be created from scratch if the build of Tesseract being used changes,
   // or if it was never created in the first place.
   if (changeVanilla || !workerLegacy || !workerLSTM) {
     if (vanillaMode_) {
-      tessOptions.corePath = new URL('../../tess/core_vanilla/tesseract-core-simd.wasm.js', import.meta.url).href;
+      tessOptions.corePath = new URL(
+        '../../tess/core_vanilla/tesseract-core-simd.wasm.js',
+        import.meta.url
+      ).href;
     } else {
-      tessOptions.corePath = new URL('../../tess/core/tesseract-core-simd.wasm.js', import.meta.url).href;
+      tessOptions.corePath = new URL(
+        '../../tess/core/tesseract-core-simd.wasm.js',
+        import.meta.url
+      ).href;
     }
 
     if (workerLegacy) {
@@ -191,8 +226,18 @@ const reinitialize2 = async ({ langs, vanillaMode }) => {
       workerLSTM = null;
     }
 
-    workerLegacy = await Tesseract.createWorker(langArrCurrent, 0, tessOptions, initConfigs);
-    workerLSTM = await Tesseract.createWorker(langArrCurrent, 1, tessOptions, initConfigs);
+    workerLegacy = await Tesseract.createWorker(
+      langArrCurrent,
+      0,
+      tessOptions,
+      initConfigs
+    );
+    workerLSTM = await Tesseract.createWorker(
+      langArrCurrent,
+      1,
+      tessOptions,
+      initConfigs
+    );
   } else if (changeLang) {
     await workerLegacy.reinitialize(langArrCurrent, 0, initConfigs);
     await workerLSTM.reinitialize(langArrCurrent, 1, initConfigs);
@@ -218,20 +263,35 @@ const reinitialize2 = async ({ langs, vanillaMode }) => {
  * Exported for type inference purposes, should not be imported anywhere.
  */
 export const recognizeAndConvert = async ({
-  image, options, output, n, knownAngle = null, pageDims,
+  image,
+  options,
+  output,
+  n,
+  knownAngle = null,
+  pageDims,
 }) => {
   if (!worker) throw new Error('Worker not initialized');
 
   const res1 = await worker.recognize(image, options, output);
 
-  const angle = knownAngle === null || knownAngle === undefined ? (res1.data.rotateRadians || 0) * (180 / Math.PI) * -1 : knownAngle;
+  const angle =
+    knownAngle === null || knownAngle === undefined
+      ? (res1.data.rotateRadians || 0) * (180 / Math.PI) * -1
+      : knownAngle;
 
   const keepItalic = oemCurrent === 0;
 
-  const ocrBlocks = /** @type {Array<import('@scribe.js/tesseract.js').Block>} */(res1.data.blocks);
+  const ocrBlocks =
+    /** @type {Array<import('@scribe.js/tesseract.js').Block>} */ (
+      res1.data.blocks
+    );
 
   const res2 = await convertPageBlocks({
-    ocrBlocks, n, pageDims, rotateAngle: angle, keepItalic,
+    ocrBlocks,
+    n,
+    pageDims,
+    rotateAngle: angle,
+    keepItalic,
   });
 
   return { recognize: res1.data, convert: res2 };
@@ -250,10 +310,12 @@ export const recognizeAndConvert = async ({
  * @param {?string} [params.engineName] -
  * Exported for type inference purposes, should not be imported anywhere.
  */
-export const recognizeAndConvert2 = async ({
-  image, options, output, n, pageDims, knownAngle = null,
-}, id) => {
-  if (!worker && !(workerLegacy && workerLSTM)) throw new Error('Worker not initialized');
+export const recognizeAndConvert2 = async (
+  { image, options, output, n, pageDims, knownAngle = null },
+  id
+) => {
+  if (!worker && !(workerLegacy && workerLSTM))
+    throw new Error('Worker not initialized');
 
   // Disable output formats that are not used.
   // Leaving these enabled can significantly inflate runtimes for no benefit.
@@ -287,56 +349,98 @@ export const recognizeAndConvert2 = async ({
 
   const res0 = await resArr[0];
 
-  const angle = knownAngle === null || knownAngle === undefined ? (res0.data.rotateRadians || 0) * (180 / Math.PI) * -1 : knownAngle;
+  const angle =
+    knownAngle === null || knownAngle === undefined
+      ? (res0.data.rotateRadians || 0) * (180 / Math.PI) * -1
+      : knownAngle;
 
   let resLegacy;
   let resLSTM;
   if (options.lstm && options.legacy) {
-    const legacyBlocks = /** @type {Array<import('@scribe.js/tesseract.js').Block>} */(res0.data.blocks);
+    const legacyBlocks =
+      /** @type {Array<import('@scribe.js/tesseract.js').Block>} */ (
+        res0.data.blocks
+      );
     resLegacy = await convertPageBlocks({
-      ocrBlocks: legacyBlocks, n, pageDims, rotateAngle: angle, keepItalic: true, upscale: res0.data.upscale,
+      ocrBlocks: legacyBlocks,
+      n,
+      pageDims,
+      rotateAngle: angle,
+      keepItalic: true,
+      upscale: res0.data.upscale,
     });
     (async () => {
       const res1 = await resArr[1];
 
-      const lstmBlocks = /** @type {Array<import('@scribe.js/tesseract.js').Block>} */(res1.data.blocks);
+      const lstmBlocks =
+        /** @type {Array<import('@scribe.js/tesseract.js').Block>} */ (
+          res1.data.blocks
+        );
       resLSTM = await convertPageBlocks({
-        ocrBlocks: lstmBlocks, n, pageDims, rotateAngle: angle, keepItalic: false, upscale: res0.data.upscale,
+        ocrBlocks: lstmBlocks,
+        n,
+        pageDims,
+        rotateAngle: angle,
+        keepItalic: false,
+        upscale: res0.data.upscale,
       });
 
-      const xB = { recognize: res1.data, convert: { legacy: null, lstm: resLSTM } };
+      const xB = {
+        recognize: res1.data,
+        convert: { legacy: null, lstm: resLSTM },
+      };
 
       parentPort.postMessage({ data: xB, id: `${id}b`, status: 'resolve' });
     })();
   } else if (!options.lstm && options.legacy) {
-    const legacyBlocks = /** @type {Array<import('@scribe.js/tesseract.js').Block>} */(res0.data.blocks);
+    const legacyBlocks =
+      /** @type {Array<import('@scribe.js/tesseract.js').Block>} */ (
+        res0.data.blocks
+      );
     resLegacy = await convertPageBlocks({
-      ocrBlocks: legacyBlocks, n, pageDims, rotateAngle: angle, keepItalic: true, upscale: res0.data.upscale,
+      ocrBlocks: legacyBlocks,
+      n,
+      pageDims,
+      rotateAngle: angle,
+      keepItalic: true,
+      upscale: res0.data.upscale,
     });
   } else if (options.lstm && !options.legacy) {
-    const lstmBlocks = /** @type {Array<import('@scribe.js/tesseract.js').Block>} */(res0.data.blocks);
+    const lstmBlocks =
+      /** @type {Array<import('@scribe.js/tesseract.js').Block>} */ (
+        res0.data.blocks
+      );
     resLSTM = await convertPageBlocks({
-      ocrBlocks: lstmBlocks, n, pageDims, rotateAngle: angle, keepItalic: false, upscale: res0.data.upscale,
+      ocrBlocks: lstmBlocks,
+      n,
+      pageDims,
+      rotateAngle: angle,
+      keepItalic: false,
+      upscale: res0.data.upscale,
     });
   }
 
-  const x = { recognize: res0.data, convert: { legacy: resLegacy, lstm: resLSTM } };
+  const x = {
+    recognize: res0.data,
+    convert: { legacy: resLegacy, lstm: resLSTM },
+  };
 
   parentPort.postMessage({ data: x, id, status: 'resolve' });
 
   // Both promises must resolve for the scheduler to move on, even if only one OCR engine is being run.
-  if (!options.legacy || !options.lstm) parentPort.postMessage({ data: null, id: `${id}b` });
+  if (!options.legacy || !options.lstm)
+    parentPort.postMessage({ data: null, id: `${id}b` });
 };
 
 /**
-* @template {Partial<Tesseract.OutputFormats>} TO
-* @param {Object} args
-* @param {Parameters<Tesseract.Worker['recognize']>[0]} args.image
-* @param {Parameters<Tesseract.Worker['recognize']>[1]} args.options
-* @param {TO} args.output
-* @returns {Promise<Tesseract.Page<TO>>}
-* Exported for type inference purposes, should not be imported anywhere.
-*/
+ * @template {Partial<Tesseract.OutputFormats>} TO
+ * @param {Object} args
+ * @param {Parameters<Tesseract.Worker['recognize']>[0]} args.image
+ * @param {Parameters<Tesseract.Worker['recognize']>[1]} args.options
+ * @param {TO} args.output
+ * @returns {Promise<Tesseract.Page<TO>>}
+ * Exported for type inference purposes, should not be imported anywhere.
+ */
 export const recognize = async ({ image, options, output }) => {
   if (!worker) throw new Error('Worker not initialized');
   const res1 = await worker.recognize(image, options, output);
@@ -367,7 +471,13 @@ async function loadFontsWorker({ src, opt }) {
 }
 
 async function updateFontContWorker({
-  rawMetrics, optMetrics, defaultFontName, sansDefaultName, serifDefaultName, enableOpt, forceOpt,
+  rawMetrics,
+  optMetrics,
+  defaultFontName,
+  sansDefaultName,
+  serifDefaultName,
+  enableOpt,
+  forceOpt,
 }) {
   if (sansDefaultName) FontCont.sansDefaultName = sansDefaultName;
   if (serifDefaultName) FontCont.serifDefaultName = serifDefaultName;
@@ -421,12 +531,15 @@ const handleMessage = async (data) => {
     // Change state of worker
     loadFontsWorker,
     updateFontContWorker,
-  })[func](args)
+  })
+    [func](args)
     .then((x) => parentPort.postMessage({ data: x, id, status: 'resolve' }))
-    .catch((err) => parentPort.postMessage({ data: err, id, status: 'reject' }));
+    .catch((err) =>
+      parentPort.postMessage({ data: err, id, status: 'reject' })
+    );
 };
 
-if (typeof process === 'undefined') {
+if (true) {
   onmessage = (event) => handleMessage(event.data);
 } else {
   parentPort.on('message', handleMessage);
diff --git a/js/worker/optimizeFontModule.js b/js/worker/optimizeFontModule.js
index 44a4a2ce2ed16e2465085a26ab44f28aeed20aba..0ba81d0c72c372c1758d92ee0de114ba76fd3505 100644
--- a/js/worker/optimizeFontModule.js
+++ b/js/worker/optimizeFontModule.js
@@ -4,7 +4,7 @@ import opentype from '../../lib/opentype.module.js';
 
 // Defining "window" is needed due to bad browser/node detection in Opentype.js
 // Can hopefully remove in future version
-if (typeof process === 'object') {
+if (false) {
   // @ts-ignore
   globalThis.self = globalThis;
   // @ts-ignore
@@ -23,7 +23,7 @@ if (typeof process === 'object') {
  * @returns {number} The rounded number.
  */
 function round6(x) {
-  return (Math.round(x * 1e6) / 1e6);
+  return Math.round(x * 1e6) / 1e6;
 }
 
 /**
@@ -48,7 +48,12 @@ function transformGlyph(glyph, func, transX = false, transY = false) {
   for (let j = 0; j < glyph.path.commands.length; j++) {
     const pointJ = glyph.path.commands[j];
 
-    if (pointJ.type === 'M' || pointJ.type === 'L' || pointJ.type === 'C' || pointJ.type === 'Q') {
+    if (
+      pointJ.type === 'M' ||
+      pointJ.type === 'L' ||
+      pointJ.type === 'C' ||
+      pointJ.type === 'Q'
+    ) {
       if (transX) pointJ.x = funcRound(pointJ.x);
       if (transY) pointJ.y = funcRound(pointJ.y);
       if (pointJ.type === 'C' || pointJ.type === 'Q') {
@@ -122,7 +127,8 @@ const calculateKerningPairs = (font, fontMetricsObj, xHeight, style) => {
     }
 
     // Calculate current space between these 2 glyphs (without kerning adjustments)
-    const spaceCurrent = (glyphFirst.advanceWidth - metricsFirst.xMax) + metricsSecond.xMin;
+    const spaceCurrent =
+      glyphFirst.advanceWidth - metricsFirst.xMax + metricsSecond.xMin;
 
     // Calculate kerning adjustment needed
     let fontKern = spaceTarget - spaceCurrent;
@@ -131,12 +137,18 @@ const calculateKerningPairs = (font, fontMetricsObj, xHeight, style) => {
     // Unlike letters, some text will legitimately have a large space before/after curly quotes.
     // TODO: Handle quotes in a more systematic way (setting advance for quotes, or kerning for all letters,
     // rather than relying on each individual pairing.)
-    if (['8220', '8216'].includes(nameFirst) || ['8221', '8217'].includes(nameSecond)) {
+    if (
+      ['8220', '8216'].includes(nameFirst) ||
+      ['8221', '8217'].includes(nameSecond)
+    ) {
       fontKern = Math.min(Math.max(fontKern, minKern), maxKern * 2);
 
       // For pairs that commonly use ligatures ("ff", "fi", "fl") allow lower minimum
     } else if (['102,102', '102,105', '102,108'].includes(key)) {
-      fontKern = Math.min(Math.max(fontKern, Math.round(minKern * 1.5)), maxKern);
+      fontKern = Math.min(
+        Math.max(fontKern, Math.round(minKern * 1.5)),
+        maxKern
+      );
     } else {
       fontKern = Math.min(Math.max(fontKern, minKern), maxKern);
     }
@@ -160,10 +172,19 @@ const calculateKerningPairs = (font, fontMetricsObj, xHeight, style) => {
  *    If `false`, only font-level transformations (adjusting em size and standardizing 'o' height) are performed.
  */
 export async function optimizeFont({
-  fontData, fontMetricsObj, style, adjustAllLeftBearings = false, standardizeSize = false, targetEmSize = null, transGlyphs = true,
+  fontData,
+  fontMetricsObj,
+  style,
+  adjustAllLeftBearings = false,
+  standardizeSize = false,
+  targetEmSize = null,
+  transGlyphs = true,
 }) {
   /** @type {opentype.Font} */
-  const workingFont = typeof (fontData) === 'string' ? await opentype.load(fontData) : opentype.parse(fontData, { lowMemory: false });
+  const workingFont =
+    typeof fontData === 'string'
+      ? await opentype.load(fontData)
+      : opentype.parse(fontData, { lowMemory: false });
 
   // let workingFont;
   // if (typeof (fontData) == "string") {
@@ -189,33 +210,78 @@ export async function optimizeFont({
         transformGlyph(value, scaleGlyph, true, true);
       }
     } else {
-      console.log("Font is not standard size ('o' 0.47x em size).  Either standardize the font ahead of time or enable `standardizeSize = true` to standardize on the fly.");
+      console.log(
+        "Font is not standard size ('o' 0.47x em size).  Either standardize the font ahead of time or enable `standardizeSize = true` to standardize on the fly."
+      );
     }
   }
 
   if (targetEmSize && targetEmSize !== workingFont.unitsPerEm) {
     for (const [key, value] of Object.entries(workingFont.glyphs.glyphs)) {
-      transformGlyph(value, (x) => x * (targetEmSize / workingFont.unitsPerEm), true, true);
+      transformGlyph(
+        value,
+        (x) => x * (targetEmSize / workingFont.unitsPerEm),
+        true,
+        true
+      );
     }
     workingFont.unitsPerEm = targetEmSize;
   }
 
   // If no glyph-level transformations are requested, return early.
   if (!transGlyphs) {
-    workingFont.kerningPairs = calculateKerningPairs(workingFont, fontMetricsObj, xHeight, style);
-
-    return { fontData: workingFont.toArrayBuffer(), kerningPairs: workingFont.kerningPairs };
+    workingFont.kerningPairs = calculateKerningPairs(
+      workingFont,
+      fontMetricsObj,
+      xHeight,
+      style
+    );
+
+    return {
+      fontData: workingFont.toArrayBuffer(),
+      kerningPairs: workingFont.kerningPairs,
+    };
   }
 
   oGlyph = workingFont.charToGlyph('o').getMetrics();
   xHeight = oGlyph.yMax - oGlyph.yMin;
 
-  const heightCapsBelievable = fontMetricsObj.obsCaps >= 10 && fontMetricsObj.heightCaps >= 1.1 && fontMetricsObj.heightCaps < 2;
+  const heightCapsBelievable =
+    fontMetricsObj.obsCaps >= 10 &&
+    fontMetricsObj.heightCaps >= 1.1 &&
+    fontMetricsObj.heightCaps < 2;
 
   const fontAscHeight = workingFont.charToGlyph('A').getMetrics().yMax;
 
   // Define various character classes
-  const lower = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];
+  const lower = [
+    'a',
+    'b',
+    'c',
+    'd',
+    'e',
+    'f',
+    'g',
+    'h',
+    'i',
+    'j',
+    'k',
+    'l',
+    'm',
+    'n',
+    'o',
+    'p',
+    'q',
+    'r',
+    's',
+    't',
+    'u',
+    'v',
+    'w',
+    'x',
+    'y',
+    'z',
+  ];
 
   const singleStemClassA = ['i', 'l', 't', 'I'];
   const singleStemClassB = ['f', 'i', 'j', 'l', 't', 'I', 'J', 'T'];
@@ -226,12 +292,16 @@ export async function optimizeFont({
   // Adjust character width and advance
   for (const [key, value] of Object.entries(fontMetricsObj.width)) {
     // 33 is the first latin glyph (excluding space which is 32)
-    if (parseInt(key) < 33) { continue; }
+    if (parseInt(key) < 33) {
+      continue;
+    }
 
     const charLit = String.fromCharCode(parseInt(key));
 
     // Some glyphs do not benefit from recalculating statistics, as they are commonly misidentified
-    if (['.'].includes(charLit)) { continue; }
+    if (['.'].includes(charLit)) {
+      continue;
+    }
 
     const glyphI = workingFont.charToGlyph(charLit);
 
@@ -248,7 +318,9 @@ export async function optimizeFont({
 
     const glyphICenterPoint = charLit === 'f' ? 0.35 : 0.5;
 
-    const glyphICenter = Math.max(glyphIMetrics.xMin, 0) + Math.round(glyphIWidth * glyphICenterPoint);
+    const glyphICenter =
+      Math.max(glyphIMetrics.xMin, 0) +
+      Math.round(glyphIWidth * glyphICenterPoint);
     const glyphIWidthQuarter = Math.round(glyphIWidth / 4);
 
     // Horizontal scaling is limited for certain letters with a single vertical stem.
@@ -262,7 +334,8 @@ export async function optimizeFont({
       scaleXFactor = Math.max(Math.min(scaleXFactor, 1.3), 0.7);
     }
 
-    const scaleH1 = (x) => Math.round((x - glyphICenter) * scaleXFactor) + glyphICenter;
+    const scaleH1 = (x) =>
+      Math.round((x - glyphICenter) * scaleXFactor) + glyphICenter;
     const scaleH2 = (x) => Math.round(x * scaleXFactor);
 
     if (singleStemClassB.includes(charLit) && style !== 'italic') {
@@ -279,7 +352,10 @@ export async function optimizeFont({
     // This must be done after any horizontal scaling for the calculations to be correct.
     // Left bearings are currently only changed for specific punctuation characters (overall scaling aside)
     let shiftX = 0;
-    if ([';', ':', '', '', '', '', '"'].includes(charLit) || adjustAllLeftBearings) {
+    if (
+      [';', ':', '', '', '', '', '"'].includes(charLit) ||
+      adjustAllLeftBearings
+    ) {
       const leftBearingCorrect = 0;
       // xMin is automatically updated by getMetrics, leftSideBearing is not
       const leftBearingAct = glyphIMetrics.xMin;
@@ -305,7 +381,7 @@ export async function optimizeFont({
 
   // Adjust height for capital letters (if heightCaps is believable)
   if (heightCapsBelievable) {
-    const capsMult = xHeight * fontMetricsObj.heightCaps / fontAscHeight;
+    const capsMult = (xHeight * fontMetricsObj.heightCaps) / fontAscHeight;
     for (const key of [...Array(26).keys()].map((x) => x + 65)) {
       const charLit = String.fromCharCode(key);
 
@@ -318,10 +394,33 @@ export async function optimizeFont({
   }
 
   // This purposefully does not include numbers, as those are normalized differently.
-  const upperAsc = ['A', 'B', 'D', 'E', 'F', 'H', 'I', 'K', 'L', 'M', 'N', 'P', 'R', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
+  const upperAsc = [
+    'A',
+    'B',
+    'D',
+    'E',
+    'F',
+    'H',
+    'I',
+    'K',
+    'L',
+    'M',
+    'N',
+    'P',
+    'R',
+    'T',
+    'U',
+    'V',
+    'W',
+    'X',
+    'Y',
+    'Z',
+  ];
   const upperAscCodes = upperAsc.map((x) => String(x.charCodeAt(0)));
   const charHeightKeys = Object.keys(fontMetricsObj.height);
-  const heightAscArr = Object.values(fontMetricsObj.height).filter((element, index) => upperAscCodes.includes(charHeightKeys[index]));
+  const heightAscArr = Object.values(fontMetricsObj.height).filter(
+    (element, index) => upperAscCodes.includes(charHeightKeys[index])
+  );
 
   // At least 10 observations are required to adjust from the default.
   if (heightAscArr.length >= 10) {
@@ -332,16 +431,25 @@ export async function optimizeFont({
       // TODO: Extend similar logic to apply to other descenders such as "p" and "q"
       // Adjust height of capital J (which often has a height greater than other capital letters)
       // All height from "J" above that of "A" is assumed to occur under the baseline
-      const actJMult = Math.max(round6(fontMetricsObj.height[74]) / charHeightA, 0);
+      const actJMult = Math.max(
+        round6(fontMetricsObj.height[74]) / charHeightA,
+        0
+      );
       const fontJMetrics = workingFont.charToGlyph('J').getMetrics();
       const fontAMetrics = workingFont.charToGlyph('A').getMetrics();
-      const fontJMult = Math.max((fontJMetrics.yMax - fontJMetrics.yMin) / (fontAMetrics.yMax - fontAMetrics.yMin), 1);
+      const fontJMult = Math.max(
+        (fontJMetrics.yMax - fontJMetrics.yMin) /
+          (fontAMetrics.yMax - fontAMetrics.yMin),
+        1
+      );
       const actFontJMult = actJMult / fontJMult;
 
       if (Math.abs(1 - actFontJMult) > 0.02) {
         const glyphI = workingFont.charToGlyph('J');
         const glyphIMetrics = glyphI.getMetrics();
-        const yAdj = Math.round(glyphIMetrics.yMax - (glyphIMetrics.yMax * actFontJMult));
+        const yAdj = Math.round(
+          glyphIMetrics.yMax - glyphIMetrics.yMax * actFontJMult
+        );
 
         const transDescFunc = (x) => Math.round(x * actFontJMult + yAdj);
 
@@ -358,13 +466,18 @@ export async function optimizeFont({
   for (let i = 0; i < descAdjArr.length; i++) {
     const charI = descAdjArr[i];
     const charICode = charI.charCodeAt(0);
-    const actMult = Math.max(fontMetricsObj.height[charICode] / fontMetricsObj.height[97], 0);
+    const actMult = Math.max(
+      fontMetricsObj.height[charICode] / fontMetricsObj.height[97],
+      0
+    );
     const metrics = workingFont.charToGlyph(charI).getMetrics();
-    const fontMult = (metrics.yMax - metrics.yMin) / (fontAMetrics.yMax - fontAMetrics.yMin);
+    const fontMult =
+      (metrics.yMax - metrics.yMin) / (fontAMetrics.yMax - fontAMetrics.yMin);
     const actFontMult = actMult / fontMult;
     const glyphHeight = metrics.yMax - metrics.yMin;
     const glyphLowerStemHeight = minA - metrics.yMin;
-    const scaleYFactor = ((actFontMult - 1) * (glyphHeight / glyphLowerStemHeight)) + 1;
+    const scaleYFactor =
+      (actFontMult - 1) * (glyphHeight / glyphLowerStemHeight) + 1;
 
     const scaleYFunc = (x) => Math.round((x - minA) * scaleYFactor);
 
@@ -378,12 +491,20 @@ export async function optimizeFont({
       for (let j = 0; j < glyphI.path.commands.length; j++) {
         const pointJ = glyphI.path.commands[j];
 
-        if (pointJ.type === 'M' || pointJ.type === 'L' || pointJ.type === 'C' || pointJ.type === 'Q') {
-          if (pointJ.y < minA) pointJ.y = Math.round((pointJ.y - minA) * scaleYFactor);
+        if (
+          pointJ.type === 'M' ||
+          pointJ.type === 'L' ||
+          pointJ.type === 'C' ||
+          pointJ.type === 'Q'
+        ) {
+          if (pointJ.y < minA)
+            pointJ.y = Math.round((pointJ.y - minA) * scaleYFactor);
           if (pointJ.type === 'C' || pointJ.type === 'Q') {
-            if (pointJ.y1 < minA) pointJ.y1 = Math.round((pointJ.y1 - minA) * scaleYFactor);
+            if (pointJ.y1 < minA)
+              pointJ.y1 = Math.round((pointJ.y1 - minA) * scaleYFactor);
             if (pointJ.type === 'C') {
-              if (pointJ.y2 < minA) pointJ.y2 = Math.round((pointJ.y2 - minA) * scaleYFactor);
+              if (pointJ.y2 < minA)
+                pointJ.y2 = Math.round((pointJ.y2 - minA) * scaleYFactor);
             }
           }
         }
@@ -391,11 +512,22 @@ export async function optimizeFont({
     }
   }
 
-  workingFont.kerningPairs = calculateKerningPairs(workingFont, fontMetricsObj, xHeight, style);
+  workingFont.kerningPairs = calculateKerningPairs(
+    workingFont,
+    fontMetricsObj,
+    xHeight,
+    style
+  );
 
   // Append suffix to avoid naming conflict with raw font.
   // This is necessary for the Node.js version due to quirks with node-canvas.
-  workingFont.tables.name.postScriptName.en = `${workingFont.tables.name.postScriptName.en.replaceAll(/\s+/g, '')}-Opt`;
-
-  return { fontData: workingFont.toArrayBuffer(), kerningPairs: workingFont.kerningPairs };
+  workingFont.tables.name.postScriptName.en = `${workingFont.tables.name.postScriptName.en.replaceAll(
+    /\s+/g,
+    ''
+  )}-Opt`;
+
+  return {
+    fontData: workingFont.toArrayBuffer(),
+    kerningPairs: workingFont.kerningPairs,
+  };
 }
diff --git a/mupdf/libmupdf.js b/mupdf/libmupdf.js
index 0b1ac9b036ee0c94431f1bb6f5598e27c4f6b889..ba1fed59f6ebd1375e8ca581da595b64a87549f5 100644
--- a/mupdf/libmupdf.js
+++ b/mupdf/libmupdf.js
@@ -1,18 +1,22 @@
-export var Module = typeof Module != "undefined" ? Module : {};
+export var Module = typeof Module != 'undefined' ? Module : {};
 
-var ENVIRONMENT_IS_WEB = typeof window == "object";
+var ENVIRONMENT_IS_WEB = true;
 
-var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";
+var ENVIRONMENT_IS_WORKER = typeof importScripts == 'function';
 
-var ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string";
+var ENVIRONMENT_IS_NODE = false;
 
-var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
+var ENVIRONMENT_IS_SHELL =
+  !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
 
-if (Module["ENVIRONMENT"]) {
-  throw new Error("Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)");
+if (Module['ENVIRONMENT']) {
+  throw new Error(
+    'Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)'
+  );
 }
 
-if (ENVIRONMENT_IS_NODE) {}
+if (ENVIRONMENT_IS_NODE) {
+}
 
 Module.noExitRuntime = true;
 
@@ -22,17 +26,17 @@ var moduleOverrides = Object.assign({}, Module);
 
 var arguments_ = [];
 
-var thisProgram = "./this.program";
+var thisProgram = './this.program';
 
 var quit_ = (status, toThrow) => {
   throw toThrow;
 };
 
-var scriptDirectory = "";
+var scriptDirectory = '';
 
 function locateFile(path) {
-  if (Module["locateFile"]) {
-    return Module["locateFile"](path, scriptDirectory);
+  if (Module['locateFile']) {
+    return Module['locateFile'](path, scriptDirectory);
   }
   return scriptDirectory + path;
 }
@@ -40,21 +44,37 @@ function locateFile(path) {
 var read_, readAsync, readBinary;
 
 if (ENVIRONMENT_IS_NODE) {
-  if (typeof process == "undefined" || !process.release || process.release.name !== "node") throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
+  if (
+    true ||
+    !process.release ||
+    process.release.name !== 'node'
+  )
+    throw new Error(
+      'not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)'
+    );
   var nodeVersion = process.versions.node;
-  var numericVersion = nodeVersion.split(".").slice(0, 3);
-  numericVersion = (numericVersion[0] * 1e4) + (numericVersion[1] * 100) + (numericVersion[2].split("-")[0] * 1);
+  var numericVersion = nodeVersion.split('.').slice(0, 3);
+  numericVersion =
+    numericVersion[0] * 1e4 +
+    numericVersion[1] * 100 +
+    numericVersion[2].split('-')[0] * 1;
   if (numericVersion < 16e4) {
-    throw new Error("This emscripten-generated code requires node v16.0.0 (detected v" + nodeVersion + ")");
-  }
-  var fs = require("fs");
-  var nodePath = require("path");
-  scriptDirectory = __dirname + "/";
+    throw new Error(
+      'This emscripten-generated code requires node v16.0.0 (detected v' +
+        nodeVersion +
+        ')'
+    );
+  }
+  var fs = require('fs');
+  var nodePath = require('path');
+  scriptDirectory = __dirname + '/';
   read_ = (filename, binary) => {
-    filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
-    return fs.readFileSync(filename, binary ? undefined : "utf8");
+    filename = isFileURI(filename)
+      ? new URL(filename)
+      : nodePath.normalize(filename);
+    return fs.readFileSync(filename, binary ? undefined : 'utf8');
   };
-  readBinary = filename => {
+  readBinary = (filename) => {
     var ret = read_(filename, true);
     if (!ret.buffer) {
       ret = new Uint8Array(ret);
@@ -63,20 +83,27 @@ if (ENVIRONMENT_IS_NODE) {
     return ret;
   };
   readAsync = (filename, onload, onerror, binary = true) => {
-    filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
-    fs.readFile(filename, binary ? undefined : "utf8", (err, data) => {
-      if (err) onerror(err); else onload(binary ? data.buffer : data);
+    filename = isFileURI(filename)
+      ? new URL(filename)
+      : nodePath.normalize(filename);
+    fs.readFile(filename, binary ? undefined : 'utf8', (err, data) => {
+      if (err) onerror(err);
+      else onload(binary ? data.buffer : data);
     });
   };
-  if (!Module["thisProgram"] && process.argv.length > 1) {
-    thisProgram = process.argv[1].replace(/\\/g, "/");
+  if (!Module['thisProgram'] && process.argv.length > 1) {
+    thisProgram = process.argv[1].replace(/\\/g, '/');
   }
   arguments_ = process.argv.slice(2);
-  if (typeof module != "undefined") {
-    module["exports"] = Module;
-  }
-  process.on("uncaughtException", ex => {
-    if (ex !== "unwind" && !(ex instanceof ExitStatus) && !(ex.context instanceof ExitStatus)) {
+  if (typeof module != 'undefined') {
+    module['exports'] = Module;
+  }
+  process.on('uncaughtException', (ex) => {
+    if (
+      ex !== 'unwind' &&
+      !(ex instanceof ExitStatus) &&
+      !(ex.context instanceof ExitStatus)
+    ) {
       throw ex;
     }
   });
@@ -85,39 +112,52 @@ if (ENVIRONMENT_IS_NODE) {
     throw toThrow;
   };
 } else if (ENVIRONMENT_IS_SHELL) {
-  if ((typeof process == "object" && typeof require === "function") || typeof window == "object" || typeof importScripts == "function") throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
+  if (
+    (typeof process == 'object' && typeof require === 'function') ||
+    typeof window == 'object' ||
+    typeof importScripts == 'function'
+  )
+    throw new Error(
+      'not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)'
+    );
 } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
   if (ENVIRONMENT_IS_WORKER) {
     scriptDirectory = self.location.href;
-  } else if (typeof document != "undefined" && document.currentScript) {
+  } else if (typeof document != 'undefined' && document.currentScript) {
     scriptDirectory = document.currentScript.src;
   }
-  if (scriptDirectory.startsWith("blob:")) {
-    scriptDirectory = "";
+  if (scriptDirectory.startsWith('blob:')) {
+    scriptDirectory = '';
   } else {
-    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
-  }
-  if (!(typeof window == "object" || typeof importScripts == "function")) throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
+    scriptDirectory = scriptDirectory.substr(
+      0,
+      scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/') + 1
+    );
+  }
+  if (!(typeof window == 'object' || typeof importScripts == 'function'))
+    throw new Error(
+      'not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)'
+    );
   {
-    read_ = url => {
-      var xhr = new XMLHttpRequest;
-      xhr.open("GET", url, false);
+    read_ = (url) => {
+      var xhr = new XMLHttpRequest();
+      xhr.open('GET', url, false);
       xhr.send(null);
       return xhr.responseText;
     };
     if (ENVIRONMENT_IS_WORKER) {
-      readBinary = url => {
-        var xhr = new XMLHttpRequest;
-        xhr.open("GET", url, false);
-        xhr.responseType = "arraybuffer";
+      readBinary = (url) => {
+        var xhr = new XMLHttpRequest();
+        xhr.open('GET', url, false);
+        xhr.responseType = 'arraybuffer';
         xhr.send(null);
         return new Uint8Array(/** @type{!ArrayBuffer} */ (xhr.response));
       };
     }
     readAsync = (url, onload, onerror) => {
-      var xhr = new XMLHttpRequest;
-      xhr.open("GET", url, true);
-      xhr.responseType = "arraybuffer";
+      var xhr = new XMLHttpRequest();
+      xhr.open('GET', url, true);
+      xhr.responseType = 'arraybuffer';
       xhr.onload = () => {
         if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) {
           onload(xhr.response);
@@ -130,12 +170,12 @@ if (ENVIRONMENT_IS_NODE) {
     };
   }
 } else {
-  throw new Error("environment detection error");
+  throw new Error('environment detection error');
 }
 
-var out = Module["print"] || console.log.bind(console);
+var out = Module['print'] || console.log.bind(console);
 
-var err = Module["printErr"] || console.error.bind(console);
+var err = Module['printErr'] || console.error.bind(console);
 
 Object.assign(Module, moduleOverrides);
 
@@ -143,61 +183,91 @@ moduleOverrides = null;
 
 checkIncomingModuleAPI();
 
-if (Module["arguments"]) arguments_ = Module["arguments"];
+if (Module['arguments']) arguments_ = Module['arguments'];
 
-legacyModuleProp("arguments", "arguments_");
+legacyModuleProp('arguments', 'arguments_');
 
-if (Module["thisProgram"]) thisProgram = Module["thisProgram"];
+if (Module['thisProgram']) thisProgram = Module['thisProgram'];
 
-legacyModuleProp("thisProgram", "thisProgram");
+legacyModuleProp('thisProgram', 'thisProgram');
 
-if (Module["quit"]) quit_ = Module["quit"];
+if (Module['quit']) quit_ = Module['quit'];
 
-legacyModuleProp("quit", "quit_");
+legacyModuleProp('quit', 'quit_');
 
-assert(typeof Module["memoryInitializerPrefixURL"] == "undefined", "Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead");
+assert(
+  typeof Module['memoryInitializerPrefixURL'] == 'undefined',
+  'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead'
+);
 
-assert(typeof Module["pthreadMainPrefixURL"] == "undefined", "Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead");
+assert(
+  typeof Module['pthreadMainPrefixURL'] == 'undefined',
+  'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead'
+);
 
-assert(typeof Module["cdInitializerPrefixURL"] == "undefined", "Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead");
+assert(
+  typeof Module['cdInitializerPrefixURL'] == 'undefined',
+  'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead'
+);
 
-assert(typeof Module["filePackagePrefixURL"] == "undefined", "Module.filePackagePrefixURL option was removed, use Module.locateFile instead");
+assert(
+  typeof Module['filePackagePrefixURL'] == 'undefined',
+  'Module.filePackagePrefixURL option was removed, use Module.locateFile instead'
+);
 
-assert(typeof Module["read"] == "undefined", "Module.read option was removed (modify read_ in JS)");
+assert(
+  typeof Module['read'] == 'undefined',
+  'Module.read option was removed (modify read_ in JS)'
+);
 
-assert(typeof Module["readAsync"] == "undefined", "Module.readAsync option was removed (modify readAsync in JS)");
+assert(
+  typeof Module['readAsync'] == 'undefined',
+  'Module.readAsync option was removed (modify readAsync in JS)'
+);
 
-assert(typeof Module["readBinary"] == "undefined", "Module.readBinary option was removed (modify readBinary in JS)");
+assert(
+  typeof Module['readBinary'] == 'undefined',
+  'Module.readBinary option was removed (modify readBinary in JS)'
+);
 
-assert(typeof Module["setWindowTitle"] == "undefined", "Module.setWindowTitle option was removed (modify emscripten_set_window_title in JS)");
+assert(
+  typeof Module['setWindowTitle'] == 'undefined',
+  'Module.setWindowTitle option was removed (modify emscripten_set_window_title in JS)'
+);
 
-assert(typeof Module["TOTAL_MEMORY"] == "undefined", "Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY");
+assert(
+  typeof Module['TOTAL_MEMORY'] == 'undefined',
+  'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY'
+);
 
-legacyModuleProp("asm", "wasmExports");
+legacyModuleProp('asm', 'wasmExports');
 
-legacyModuleProp("read", "read_");
+legacyModuleProp('read', 'read_');
 
-legacyModuleProp("readAsync", "readAsync");
+legacyModuleProp('readAsync', 'readAsync');
 
-legacyModuleProp("readBinary", "readBinary");
+legacyModuleProp('readBinary', 'readBinary');
 
-legacyModuleProp("setWindowTitle", "setWindowTitle");
+legacyModuleProp('setWindowTitle', 'setWindowTitle');
 
-assert(!ENVIRONMENT_IS_SHELL, "shell environment detected but not enabled at build time.  Add `shell` to `-sENVIRONMENT` to enable.");
+assert(
+  !ENVIRONMENT_IS_SHELL,
+  'shell environment detected but not enabled at build time.  Add `shell` to `-sENVIRONMENT` to enable.'
+);
 
 var wasmBinary;
 
-if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];
+if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];
 
-legacyModuleProp("wasmBinary", "wasmBinary");
+legacyModuleProp('wasmBinary', 'wasmBinary');
 
-if (typeof WebAssembly != "object") {
-  err("no native wasm support detected");
+if (typeof WebAssembly != 'object') {
+  err('no native wasm support detected');
 }
 
 function intArrayFromBase64(s) {
-  if (typeof ENVIRONMENT_IS_NODE != "undefined" && ENVIRONMENT_IS_NODE) {
-    var buf = Buffer.from(s, "base64");
+  if (typeof ENVIRONMENT_IS_NODE != 'undefined' && ENVIRONMENT_IS_NODE) {
+    var buf = Buffer.from(s, 'base64');
     return new Uint8Array(buf.buffer, buf.byteOffset, buf.length);
   }
   var decoded = atob(s);
@@ -216,31 +286,53 @@ var EXITSTATUS;
 
 /** @type {function(*, string=)} */ function assert(condition, text) {
   if (!condition) {
-    abort("Assertion failed" + (text ? ": " + text : ""));
+    abort('Assertion failed' + (text ? ': ' + text : ''));
   }
 }
 
-var /** @type {!Int8Array} */ HEAP8, /** @type {!Uint8Array} */ HEAPU8, /** @type {!Int16Array} */ HEAP16, /** @type {!Uint16Array} */ HEAPU16, /** @type {!Int32Array} */ HEAP32, /** @type {!Uint32Array} */ HEAPU32, /** @type {!Float32Array} */ HEAPF32, /** @type {!Float64Array} */ HEAPF64;
+var /** @type {!Int8Array} */ HEAP8,
+  /** @type {!Uint8Array} */ HEAPU8,
+  /** @type {!Int16Array} */ HEAP16,
+  /** @type {!Uint16Array} */ HEAPU16,
+  /** @type {!Int32Array} */ HEAP32,
+  /** @type {!Uint32Array} */ HEAPU32,
+  /** @type {!Float32Array} */ HEAPF32,
+  /** @type {!Float64Array} */ HEAPF64;
 
 function updateMemoryViews() {
   var b = wasmMemory.buffer;
-  Module["HEAP8"] = HEAP8 = new Int8Array(b);
-  Module["HEAP16"] = HEAP16 = new Int16Array(b);
-  Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
-  Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
-  Module["HEAP32"] = HEAP32 = new Int32Array(b);
-  Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
-  Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
-  Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
-}
-
-assert(!Module["STACK_SIZE"], "STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time");
-
-assert(typeof Int32Array != "undefined" && typeof Float64Array !== "undefined" && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined, "JS engine does not provide full typed array support");
-
-assert(!Module["wasmMemory"], "Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally");
-
-assert(!Module["INITIAL_MEMORY"], "Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically");
+  Module['HEAP8'] = HEAP8 = new Int8Array(b);
+  Module['HEAP16'] = HEAP16 = new Int16Array(b);
+  Module['HEAPU8'] = HEAPU8 = new Uint8Array(b);
+  Module['HEAPU16'] = HEAPU16 = new Uint16Array(b);
+  Module['HEAP32'] = HEAP32 = new Int32Array(b);
+  Module['HEAPU32'] = HEAPU32 = new Uint32Array(b);
+  Module['HEAPF32'] = HEAPF32 = new Float32Array(b);
+  Module['HEAPF64'] = HEAPF64 = new Float64Array(b);
+}
+
+assert(
+  !Module['STACK_SIZE'],
+  'STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time'
+);
+
+assert(
+  typeof Int32Array != 'undefined' &&
+    typeof Float64Array !== 'undefined' &&
+    Int32Array.prototype.subarray != undefined &&
+    Int32Array.prototype.set != undefined,
+  'JS engine does not provide full typed array support'
+);
+
+assert(
+  !Module['wasmMemory'],
+  'Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally'
+);
+
+assert(
+  !Module['INITIAL_MEMORY'],
+  'Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically'
+);
 
 function writeStackCookie() {
   var max = _emscripten_stack_get_end();
@@ -248,9 +340,9 @@ function writeStackCookie() {
   if (max == 0) {
     max += 4;
   }
-  HEAPU32[((max) >>> 2) >>> 0] = 34821223;
-  HEAPU32[(((max) + (4)) >>> 2) >>> 0] = 2310721022;
-  HEAPU32[((0) >>> 2) >>> 0] = 1668509029;
+  HEAPU32[(max >>> 2) >>> 0] = 34821223;
+  HEAPU32[((max + 4) >>> 2) >>> 0] = 2310721022;
+  HEAPU32[(0 >>> 2) >>> 0] = 1668509029;
 }
 
 function checkStackCookie() {
@@ -259,21 +351,30 @@ function checkStackCookie() {
   if (max == 0) {
     max += 4;
   }
-  var cookie1 = HEAPU32[((max) >>> 2) >>> 0];
-  var cookie2 = HEAPU32[(((max) + (4)) >>> 2) >>> 0];
+  var cookie1 = HEAPU32[(max >>> 2) >>> 0];
+  var cookie2 = HEAPU32[((max + 4) >>> 2) >>> 0];
   if (cookie1 != 34821223 || cookie2 != 2310721022) {
-    abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);
+    abort(
+      `Stack overflow! Stack cookie has been overwritten at ${ptrToString(
+        max
+      )}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(
+        cookie2
+      )} ${ptrToString(cookie1)}`
+    );
   }
-  if (HEAPU32[((0) >>> 2) >>> 0] != 1668509029) /* 'emsc' */ {
-    abort("Runtime error: The application has corrupted its heap memory area (address zero)!");
+  if (HEAPU32[(0 >>> 2) >>> 0] != 1668509029) {
+    /* 'emsc' */ abort(
+      'Runtime error: The application has corrupted its heap memory area (address zero)!'
+    );
   }
 }
 
-(function() {
+(function () {
   var h16 = new Int16Array(1);
   var h8 = new Int8Array(h16.buffer);
   h16[0] = 25459;
-  if (h8[0] !== 115 || h8[1] !== 99) throw "Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)";
+  if (h8[0] !== 115 || h8[1] !== 99)
+    throw 'Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)';
 })();
 
 var __ATPRERUN__ = [];
@@ -285,10 +386,11 @@ var __ATPOSTRUN__ = [];
 var runtimeInitialized = false;
 
 function preRun() {
-  if (Module["preRun"]) {
-    if (typeof Module["preRun"] == "function") Module["preRun"] = [ Module["preRun"] ];
-    while (Module["preRun"].length) {
-      addOnPreRun(Module["preRun"].shift());
+  if (Module['preRun']) {
+    if (typeof Module['preRun'] == 'function')
+      Module['preRun'] = [Module['preRun']];
+    while (Module['preRun'].length) {
+      addOnPreRun(Module['preRun'].shift());
     }
   }
   callRuntimeCallbacks(__ATPRERUN__);
@@ -298,7 +400,7 @@ function initRuntime() {
   assert(!runtimeInitialized);
   runtimeInitialized = true;
   checkStackCookie();
-  if (!Module["noFSInit"] && !FS.init.initialized) FS.init();
+  if (!Module['noFSInit'] && !FS.init.initialized) FS.init();
   FS.ignorePermissions = false;
   TTY.init();
   callRuntimeCallbacks(__ATINIT__);
@@ -306,10 +408,11 @@ function initRuntime() {
 
 function postRun() {
   checkStackCookie();
-  if (Module["postRun"]) {
-    if (typeof Module["postRun"] == "function") Module["postRun"] = [ Module["postRun"] ];
-    while (Module["postRun"].length) {
-      addOnPostRun(Module["postRun"].shift());
+  if (Module['postRun']) {
+    if (typeof Module['postRun'] == 'function')
+      Module['postRun'] = [Module['postRun']];
+    while (Module['postRun'].length) {
+      addOnPostRun(Module['postRun'].shift());
     }
   }
   callRuntimeCallbacks(__ATPOSTRUN__);
@@ -327,13 +430,25 @@ function addOnPostRun(cb) {
   __ATPOSTRUN__.unshift(cb);
 }
 
-assert(Math.imul, "This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
+assert(
+  Math.imul,
+  'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill'
+);
 
-assert(Math.fround, "This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
+assert(
+  Math.fround,
+  'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill'
+);
 
-assert(Math.clz32, "This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
+assert(
+  Math.clz32,
+  'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill'
+);
 
-assert(Math.trunc, "This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
+assert(
+  Math.trunc,
+  'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill'
+);
 
 var runDependencies = 0;
 
@@ -353,11 +468,11 @@ function getUniqueRunDependency(id) {
 
 function addRunDependency(id) {
   runDependencies++;
-  Module["monitorRunDependencies"]?.(runDependencies);
+  Module['monitorRunDependencies']?.(runDependencies);
   if (id) {
     assert(!runDependencyTracking[id]);
     runDependencyTracking[id] = 1;
-    if (runDependencyWatcher === null && typeof setInterval != "undefined") {
+    if (runDependencyWatcher === null && typeof setInterval != 'undefined') {
       runDependencyWatcher = setInterval(() => {
         if (ABORT) {
           clearInterval(runDependencyWatcher);
@@ -368,28 +483,28 @@ function addRunDependency(id) {
         for (var dep in runDependencyTracking) {
           if (!shown) {
             shown = true;
-            err("still waiting on run dependencies:");
+            err('still waiting on run dependencies:');
           }
           err(`dependency: ${dep}`);
         }
         if (shown) {
-          err("(end of list)");
+          err('(end of list)');
         }
       }, 1e4);
     }
   } else {
-    err("warning: run dependency added without ID");
+    err('warning: run dependency added without ID');
   }
 }
 
 function removeRunDependency(id) {
   runDependencies--;
-  Module["monitorRunDependencies"]?.(runDependencies);
+  Module['monitorRunDependencies']?.(runDependencies);
   if (id) {
     assert(runDependencyTracking[id]);
     delete runDependencyTracking[id];
   } else {
-    err("warning: run dependency removed without ID");
+    err('warning: run dependency removed without ID');
   }
   if (runDependencies == 0) {
     if (runDependencyWatcher !== null) {
@@ -405,8 +520,8 @@ function removeRunDependency(id) {
 }
 
 /** @param {string|number=} what */ function abort(what) {
-  Module["onAbort"]?.(what);
-  what = "Aborted(" + what + ")";
+  Module['onAbort']?.(what);
+  what = 'Aborted(' + what + ')';
   err(what);
   ABORT = true;
   EXITSTATUS = 1;
@@ -414,30 +529,36 @@ function removeRunDependency(id) {
   throw e;
 }
 
-var dataURIPrefix = "data:application/octet-stream;base64,";
+var dataURIPrefix = 'data:application/octet-stream;base64,';
 
 /**
  * Indicates whether filename is a base64 data URI.
  * @noinline
- */ var isDataURI = filename => filename.startsWith(dataURIPrefix);
+ */ var isDataURI = (filename) => filename.startsWith(dataURIPrefix);
 
 /**
  * Indicates whether filename is delivered via file protocol (as opposed to http/https)
  * @noinline
- */ var isFileURI = filename => filename.startsWith("file://");
+ */ var isFileURI = (filename) => filename.startsWith('file://');
 
 function createExportWrapper(name, nargs) {
   return (...args) => {
-    assert(runtimeInitialized, `native function \`${name}\` called before runtime initialization`);
+    assert(
+      runtimeInitialized,
+      `native function \`${name}\` called before runtime initialization`
+    );
     var f = wasmExports[name];
     assert(f, `exported native function \`${name}\` not found`);
-    assert(args.length <= nargs, `native function \`${name}\` called with ${args.length} args but expects ${nargs}`);
+    assert(
+      args.length <= nargs,
+      `native function \`${name}\` called with ${args.length} args but expects ${nargs}`
+    );
     return f(...args);
   };
 }
 
 function findWasmBinary() {
-  var f = "libmupdf.wasm";
+  var f = 'libmupdf.wasm';
   if (!isDataURI(f)) {
     return locateFile(f);
   }
@@ -445,9 +566,8 @@ function findWasmBinary() {
 }
 
 var wasmBinaryFile;
-const wasmBinaryFileURL = new URL("./libmupdf.wasm", import.meta.url);
-if (typeof process === "undefined") wasmBinaryFile = wasmBinaryFileURL.href;
-
+const wasmBinaryFileURL = new URL('./libmupdf.wasm', import.meta.url);
+if (true) wasmBinaryFile = wasmBinaryFileURL.href;
 
 function getBinarySync(file) {
   if (file == wasmBinaryFile && wasmBinary) {
@@ -456,23 +576,30 @@ function getBinarySync(file) {
   if (readBinary) {
     return readBinary(file);
   }
-  throw "both async and sync fetching of the wasm failed";
+  throw 'both async and sync fetching of the wasm failed';
 }
 
 function getBinaryPromise(binaryFile) {
   if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
-    if (typeof fetch == "function" && !isFileURI(binaryFile)) {
+    if (typeof fetch == 'function' && !isFileURI(binaryFile)) {
       return fetch(binaryFile, {
-        credentials: "same-origin"
-      }).then(response => {
-        if (!response["ok"]) {
-          throw `failed to load wasm binary file at '${binaryFile}'`;
-        }
-        return response["arrayBuffer"]();
-      }).catch(() => getBinarySync(binaryFile));
+        credentials: 'same-origin',
+      })
+        .then((response) => {
+          if (!response['ok']) {
+            throw `failed to load wasm binary file at '${binaryFile}'`;
+          }
+          return response['arrayBuffer']();
+        })
+        .catch(() => getBinarySync(binaryFile));
     } else if (readAsync) {
       return new Promise((resolve, reject) => {
-        readAsync(binaryFile, response => resolve(new Uint8Array(/** @type{!ArrayBuffer} */ (response))), reject);
+        readAsync(
+          binaryFile,
+          (response) =>
+            resolve(new Uint8Array(/** @type{!ArrayBuffer} */ (response))),
+          reject
+        );
       });
     }
   }
@@ -480,24 +607,36 @@ function getBinaryPromise(binaryFile) {
 }
 
 function instantiateArrayBuffer(binaryFile, imports, receiver) {
-  return getBinaryPromise(binaryFile).then(binary => WebAssembly.instantiate(binary, imports)).then(receiver, reason => {
-    err(`failed to asynchronously prepare wasm: ${reason}`);
-    if (isFileURI(wasmBinaryFile)) {
-      err(`warning: Loading from a file URI (${wasmBinaryFile}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`);
-    }
-    abort(reason);
-  });
+  return getBinaryPromise(binaryFile)
+    .then((binary) => WebAssembly.instantiate(binary, imports))
+    .then(receiver, (reason) => {
+      err(`failed to asynchronously prepare wasm: ${reason}`);
+      if (isFileURI(wasmBinaryFile)) {
+        err(
+          `warning: Loading from a file URI (${wasmBinaryFile}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`
+        );
+      }
+      abort(reason);
+    });
 }
 
 function instantiateAsync(binary, binaryFile, imports, callback) {
-  if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !isFileURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
+  if (
+    !binary &&
+    typeof WebAssembly.instantiateStreaming == 'function' &&
+    !isDataURI(binaryFile) &&
+    !isFileURI(binaryFile) &&
+    !ENVIRONMENT_IS_NODE &&
+    typeof fetch == 'function'
+  ) {
     return fetch(binaryFile, {
-      credentials: "same-origin"
-    }).then(response => {
-      /** @suppress {checkTypes} */ var result = WebAssembly.instantiateStreaming(response, imports);
-      return result.then(callback, function(reason) {
+      credentials: 'same-origin',
+    }).then((response) => {
+      /** @suppress {checkTypes} */ var result =
+        WebAssembly.instantiateStreaming(response, imports);
+      return result.then(callback, function (reason) {
         err(`wasm streaming compile failed: ${reason}`);
-        err("falling back to ArrayBuffer instantiation");
+        err('falling back to ArrayBuffer instantiation');
         return instantiateArrayBuffer(binaryFile, imports, callback);
       });
     });
@@ -507,42 +646,53 @@ function instantiateAsync(binary, binaryFile, imports, callback) {
 
 function getWasmImports() {
   return {
-    "env": wasmImports,
-    "wasi_snapshot_preview1": wasmImports
+    env: wasmImports,
+    wasi_snapshot_preview1: wasmImports,
   };
 }
 
 function createWasm() {
   var info = getWasmImports();
-  /** @param {WebAssembly.Module=} module*/ function receiveInstance(instance, module) {
+  /** @param {WebAssembly.Module=} module*/ function receiveInstance(
+    instance,
+    module
+  ) {
     wasmExports = instance.exports;
     wasmExports = applySignatureConversions(wasmExports);
-    wasmMemory = wasmExports["memory"];
-    assert(wasmMemory, "memory not found in wasm exports");
+    wasmMemory = wasmExports['memory'];
+    assert(wasmMemory, 'memory not found in wasm exports');
     updateMemoryViews();
-    wasmTable = wasmExports["__indirect_function_table"];
-    assert(wasmTable, "table not found in wasm exports");
-    addOnInit(wasmExports["__wasm_call_ctors"]);
-    removeRunDependency("wasm-instantiate");
+    wasmTable = wasmExports['__indirect_function_table'];
+    assert(wasmTable, 'table not found in wasm exports');
+    addOnInit(wasmExports['__wasm_call_ctors']);
+    removeRunDependency('wasm-instantiate');
     return wasmExports;
   }
-  addRunDependency("wasm-instantiate");
+  addRunDependency('wasm-instantiate');
   var trueModule = Module;
   function receiveInstantiationResult(result) {
-    assert(Module === trueModule, "the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?");
+    assert(
+      Module === trueModule,
+      'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?'
+    );
     trueModule = null;
-    receiveInstance(result["instance"]);
+    receiveInstance(result['instance']);
   }
-  if (Module["instantiateWasm"]) {
+  if (Module['instantiateWasm']) {
     try {
-      return Module["instantiateWasm"](info, receiveInstance);
+      return Module['instantiateWasm'](info, receiveInstance);
     } catch (e) {
       err(`Module.instantiateWasm callback failed with error: ${e}`);
       return false;
     }
   }
   if (!wasmBinaryFile) wasmBinaryFile = findWasmBinary();
-  instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult);
+  instantiateAsync(
+    wasmBinary,
+    wasmBinaryFile,
+    info,
+    receiveInstantiationResult
+  );
   return {};
 }
 
@@ -555,56 +705,73 @@ function legacyModuleProp(prop, newName, incoming = true) {
     Object.defineProperty(Module, prop, {
       configurable: true,
       get() {
-        let extra = incoming ? " (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)" : "";
+        let extra = incoming
+          ? ' (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)'
+          : '';
         abort(`\`Module.${prop}\` has been replaced by \`${newName}\`` + extra);
-      }
+      },
     });
   }
 }
 
 function ignoredModuleProp(prop) {
   if (Object.getOwnPropertyDescriptor(Module, prop)) {
-    abort(`\`Module.${prop}\` was supplied but \`${prop}\` not included in INCOMING_MODULE_JS_API`);
+    abort(
+      `\`Module.${prop}\` was supplied but \`${prop}\` not included in INCOMING_MODULE_JS_API`
+    );
   }
 }
 
 function isExportedByForceFilesystem(name) {
-  return name === "FS_createPath" || name === "FS_createDataFile" || name === "FS_createPreloadedFile" || name === "FS_unlink" || name === "addRunDependency" || name === "FS_createLazyFile" || name === "FS_createDevice" || name === "removeRunDependency";
+  return (
+    name === 'FS_createPath' ||
+    name === 'FS_createDataFile' ||
+    name === 'FS_createPreloadedFile' ||
+    name === 'FS_unlink' ||
+    name === 'addRunDependency' ||
+    name === 'FS_createLazyFile' ||
+    name === 'FS_createDevice' ||
+    name === 'removeRunDependency'
+  );
 }
 
 function missingGlobal(sym, msg) {
-  if (typeof globalThis != "undefined") {
+  if (typeof globalThis != 'undefined') {
     Object.defineProperty(globalThis, sym, {
       configurable: true,
       get() {
         warnOnce(`\`${sym}\` is not longer defined by emscripten. ${msg}`);
         return undefined;
-      }
+      },
     });
   }
 }
 
-missingGlobal("buffer", "Please use HEAP8.buffer or wasmMemory.buffer");
+missingGlobal('buffer', 'Please use HEAP8.buffer or wasmMemory.buffer');
 
-missingGlobal("asm", "Please use wasmExports instead");
+missingGlobal('asm', 'Please use wasmExports instead');
 
 function missingLibrarySymbol(sym) {
-  if (typeof globalThis != "undefined" && !Object.getOwnPropertyDescriptor(globalThis, sym)) {
+  if (
+    typeof globalThis != 'undefined' &&
+    !Object.getOwnPropertyDescriptor(globalThis, sym)
+  ) {
     Object.defineProperty(globalThis, sym, {
       configurable: true,
       get() {
         var msg = `\`${sym}\` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line`;
         var librarySymbol = sym;
-        if (!librarySymbol.startsWith("_")) {
-          librarySymbol = "$" + sym;
+        if (!librarySymbol.startsWith('_')) {
+          librarySymbol = '$' + sym;
         }
         msg += ` (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='${librarySymbol}')`;
         if (isExportedByForceFilesystem(sym)) {
-          msg += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you";
+          msg +=
+            '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';
         }
         warnOnce(msg);
         return undefined;
-      }
+      },
     });
   }
   unexportedRuntimeSymbol(sym);
@@ -617,96 +784,97 @@ function unexportedRuntimeSymbol(sym) {
       get() {
         var msg = `'${sym}' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)`;
         if (isExportedByForceFilesystem(sym)) {
-          msg += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you";
+          msg +=
+            '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';
         }
         abort(msg);
-      }
+      },
     });
   }
 }
 
 var ASM_CONSTS = {
   1868496: () => {
-    throw new libmupdf.TryLaterError("operation in progress");
+    throw new libmupdf.TryLaterError('operation in progress');
   },
-  1868559: $0 => {
+  1868559: ($0) => {
     throw new Error(UTF8ToString($0));
   },
   1868598: () => {
-    throw new Error("Cannot create MuPDF context!");
-  }
+    throw new Error('Cannot create MuPDF context!');
+  },
 };
 
 /** @constructor */ function ExitStatus(status) {
-  this.name = "ExitStatus";
+  this.name = 'ExitStatus';
   this.message = `Program terminated with exit(${status})`;
   this.status = status;
 }
 
-var callRuntimeCallbacks = callbacks => {
+var callRuntimeCallbacks = (callbacks) => {
   while (callbacks.length > 0) {
     callbacks.shift()(Module);
   }
 };
 
 /**
-     * @param {number} ptr
-     * @param {string} type
-     */ function getValue(ptr, type = "i8") {
-  if (type.endsWith("*")) type = "*";
+ * @param {number} ptr
+ * @param {string} type
+ */ function getValue(ptr, type = 'i8') {
+  if (type.endsWith('*')) type = '*';
   switch (type) {
-   case "i1":
-    return HEAP8[ptr >>> 0];
+    case 'i1':
+      return HEAP8[ptr >>> 0];
 
-   case "i8":
-    return HEAP8[ptr >>> 0];
+    case 'i8':
+      return HEAP8[ptr >>> 0];
 
-   case "i16":
-    return HEAP16[((ptr) >>> 1) >>> 0];
+    case 'i16':
+      return HEAP16[(ptr >>> 1) >>> 0];
 
-   case "i32":
-    return HEAP32[((ptr) >>> 2) >>> 0];
+    case 'i32':
+      return HEAP32[(ptr >>> 2) >>> 0];
 
-   case "i64":
-    abort("to do getValue(i64) use WASM_BIGINT");
+    case 'i64':
+      abort('to do getValue(i64) use WASM_BIGINT');
 
-   case "float":
-    return HEAPF32[((ptr) >>> 2) >>> 0];
+    case 'float':
+      return HEAPF32[(ptr >>> 2) >>> 0];
 
-   case "double":
-    return HEAPF64[((ptr) >>> 3) >>> 0];
+    case 'double':
+      return HEAPF64[(ptr >>> 3) >>> 0];
 
-   case "*":
-    return HEAPU32[((ptr) >>> 2) >>> 0];
+    case '*':
+      return HEAPU32[(ptr >>> 2) >>> 0];
 
-   default:
-    abort(`invalid type for getValue: ${type}`);
+    default:
+      abort(`invalid type for getValue: ${type}`);
   }
 }
 
-var noExitRuntime = Module["noExitRuntime"] || true;
+var noExitRuntime = Module['noExitRuntime'] || true;
 
-var ptrToString = ptr => {
-  assert(typeof ptr === "number");
-  return "0x" + ptr.toString(16).padStart(8, "0");
+var ptrToString = (ptr) => {
+  assert(typeof ptr === 'number');
+  return '0x' + ptr.toString(16).padStart(8, '0');
 };
 
-var stackRestore = val => __emscripten_stack_restore(val);
+var stackRestore = (val) => __emscripten_stack_restore(val);
 
 var stackSave = () => _emscripten_stack_get_current();
 
-var warnOnce = text => {
+var warnOnce = (text) => {
   warnOnce.shown ||= {};
   if (!warnOnce.shown[text]) {
     warnOnce.shown[text] = 1;
-    if (ENVIRONMENT_IS_NODE) text = "warning: " + text;
+    if (ENVIRONMENT_IS_NODE) text = 'warning: ' + text;
     err(text);
   }
 };
 
 /** @suppress {duplicate } */ function syscallGetVarargI() {
   assert(SYSCALLS.varargs != undefined);
-  var ret = HEAP32[((+SYSCALLS.varargs) >>> 2) >>> 0];
+  var ret = HEAP32[(+SYSCALLS.varargs >>> 2) >>> 0];
   SYSCALLS.varargs += 4;
   return ret;
 }
@@ -714,18 +882,19 @@ var warnOnce = text => {
 var syscallGetVarargP = syscallGetVarargI;
 
 var PATH = {
-  isAbs: path => path.charAt(0) === "/",
-  splitPath: filename => {
-    var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
+  isAbs: (path) => path.charAt(0) === '/',
+  splitPath: (filename) => {
+    var splitPathRe =
+      /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
     return splitPathRe.exec(filename).slice(1);
   },
   normalizeArray: (parts, allowAboveRoot) => {
     var up = 0;
     for (var i = parts.length - 1; i >= 0; i--) {
       var last = parts[i];
-      if (last === ".") {
+      if (last === '.') {
         parts.splice(i, 1);
-      } else if (last === "..") {
+      } else if (last === '..') {
         parts.splice(i, 1);
         up++;
       } else if (up) {
@@ -734,97 +903,112 @@ var PATH = {
       }
     }
     if (allowAboveRoot) {
-      for (;up; up--) {
-        parts.unshift("..");
+      for (; up; up--) {
+        parts.unshift('..');
       }
     }
     return parts;
   },
-  normalize: path => {
-    var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";
-    path = PATH.normalizeArray(path.split("/").filter(p => !!p), !isAbsolute).join("/");
+  normalize: (path) => {
+    var isAbsolute = PATH.isAbs(path),
+      trailingSlash = path.substr(-1) === '/';
+    path = PATH.normalizeArray(
+      path.split('/').filter((p) => !!p),
+      !isAbsolute
+    ).join('/');
     if (!path && !isAbsolute) {
-      path = ".";
+      path = '.';
     }
     if (path && trailingSlash) {
-      path += "/";
+      path += '/';
     }
-    return (isAbsolute ? "/" : "") + path;
+    return (isAbsolute ? '/' : '') + path;
   },
-  dirname: path => {
-    var result = PATH.splitPath(path), root = result[0], dir = result[1];
+  dirname: (path) => {
+    var result = PATH.splitPath(path),
+      root = result[0],
+      dir = result[1];
     if (!root && !dir) {
-      return ".";
+      return '.';
     }
     if (dir) {
       dir = dir.substr(0, dir.length - 1);
     }
     return root + dir;
   },
-  basename: path => {
-    if (path === "/") return "/";
+  basename: (path) => {
+    if (path === '/') return '/';
     path = PATH.normalize(path);
-    path = path.replace(/\/$/, "");
-    var lastSlash = path.lastIndexOf("/");
+    path = path.replace(/\/$/, '');
+    var lastSlash = path.lastIndexOf('/');
     if (lastSlash === -1) return path;
     return path.substr(lastSlash + 1);
   },
-  join: (...paths) => PATH.normalize(paths.join("/")),
-  join2: (l, r) => PATH.normalize(l + "/" + r)
+  join: (...paths) => PATH.normalize(paths.join('/')),
+  join2: (l, r) => PATH.normalize(l + '/' + r),
 };
 
 var initRandomFill = () => {
-  if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
-    return view => crypto.getRandomValues(view);
+  if (
+    typeof crypto == 'object' &&
+    typeof crypto['getRandomValues'] == 'function'
+  ) {
+    return (view) => crypto.getRandomValues(view);
   } else if (ENVIRONMENT_IS_NODE) {
     try {
-      var crypto_module = require("crypto");
-      var randomFillSync = crypto_module["randomFillSync"];
+      var crypto_module = require('crypto');
+      var randomFillSync = crypto_module['randomFillSync'];
       if (randomFillSync) {
-        return view => crypto_module["randomFillSync"](view);
+        return (view) => crypto_module['randomFillSync'](view);
       }
-      var randomBytes = crypto_module["randomBytes"];
-      return view => (view.set(randomBytes(view.byteLength)), view);
+      var randomBytes = crypto_module['randomBytes'];
+      return (view) => (view.set(randomBytes(view.byteLength)), view);
     } catch (e) {}
   }
-  abort("no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: (array) => { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };");
+  abort(
+    'no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: (array) => { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };'
+  );
 };
 
-var randomFill = view => (randomFill = initRandomFill())(view);
+var randomFill = (view) => (randomFill = initRandomFill())(view);
 
 var PATH_FS = {
   resolve: (...args) => {
-    var resolvedPath = "", resolvedAbsolute = false;
+    var resolvedPath = '',
+      resolvedAbsolute = false;
     for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
-      var path = (i >= 0) ? args[i] : FS.cwd();
-      if (typeof path != "string") {
-        throw new TypeError("Arguments to path.resolve must be strings");
+      var path = i >= 0 ? args[i] : FS.cwd();
+      if (typeof path != 'string') {
+        throw new TypeError('Arguments to path.resolve must be strings');
       } else if (!path) {
-        return "";
+        return '';
       }
-      resolvedPath = path + "/" + resolvedPath;
+      resolvedPath = path + '/' + resolvedPath;
       resolvedAbsolute = PATH.isAbs(path);
     }
-    resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter(p => !!p), !resolvedAbsolute).join("/");
-    return ((resolvedAbsolute ? "/" : "") + resolvedPath) || ".";
+    resolvedPath = PATH.normalizeArray(
+      resolvedPath.split('/').filter((p) => !!p),
+      !resolvedAbsolute
+    ).join('/');
+    return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
   },
   relative: (from, to) => {
     from = PATH_FS.resolve(from).substr(1);
     to = PATH_FS.resolve(to).substr(1);
     function trim(arr) {
       var start = 0;
-      for (;start < arr.length; start++) {
-        if (arr[start] !== "") break;
+      for (; start < arr.length; start++) {
+        if (arr[start] !== '') break;
       }
       var end = arr.length - 1;
-      for (;end >= 0; end--) {
-        if (arr[end] !== "") break;
+      for (; end >= 0; end--) {
+        if (arr[end] !== '') break;
       }
       if (start > end) return [];
       return arr.slice(start, end - start + 1);
     }
-    var fromParts = trim(from.split("/"));
-    var toParts = trim(to.split("/"));
+    var fromParts = trim(from.split('/'));
+    var toParts = trim(to.split('/'));
     var length = Math.min(fromParts.length, toParts.length);
     var samePartsLength = length;
     for (var i = 0; i < length; i++) {
@@ -835,24 +1019,25 @@ var PATH_FS = {
     }
     var outputParts = [];
     for (var i = samePartsLength; i < fromParts.length; i++) {
-      outputParts.push("..");
+      outputParts.push('..');
     }
     outputParts = outputParts.concat(toParts.slice(samePartsLength));
-    return outputParts.join("/");
-  }
+    return outputParts.join('/');
+  },
 };
 
-var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : undefined;
+var UTF8Decoder =
+  typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;
 
 /**
-     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given
-     * array that contains uint8 values, returns a copy of that string as a
-     * Javascript String object.
-     * heapOrArray is either a regular array, or a JavaScript typed array view.
-     * @param {number} idx
-     * @param {number=} maxBytesToRead
-     * @return {string}
-     */ var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
+ * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given
+ * array that contains uint8 values, returns a copy of that string as a
+ * Javascript String object.
+ * heapOrArray is either a regular array, or a JavaScript typed array view.
+ * @param {number} idx
+ * @param {number=} maxBytesToRead
+ * @return {string}
+ */ var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
   idx >>>= 0;
   var endIdx = idx + maxBytesToRead;
   var endPtr = idx;
@@ -860,7 +1045,7 @@ var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") :
   if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
     return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
   }
-  var str = "";
+  var str = '';
   while (idx < endPtr) {
     var u0 = heapOrArray[idx++];
     if (!(u0 & 128)) {
@@ -876,8 +1061,14 @@ var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") :
     if ((u0 & 240) == 224) {
       u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
     } else {
-      if ((u0 & 248) != 240) warnOnce("Invalid UTF-8 leading byte " + ptrToString(u0) + " encountered when deserializing a UTF-8 string in wasm memory to a JS string!");
-      u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);
+      if ((u0 & 248) != 240)
+        warnOnce(
+          'Invalid UTF-8 leading byte ' +
+            ptrToString(u0) +
+            ' encountered when deserializing a UTF-8 string in wasm memory to a JS string!'
+        );
+      u0 =
+        ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);
     }
     if (u0 < 65536) {
       str += String.fromCharCode(u0);
@@ -891,7 +1082,7 @@ var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") :
 
 var FS_stdin_getChar_buffer = [];
 
-var lengthBytesUTF8 = str => {
+var lengthBytesUTF8 = (str) => {
   var len = 0;
   for (var i = 0; i < str.length; ++i) {
     var c = str.charCodeAt(i);
@@ -911,7 +1102,10 @@ var lengthBytesUTF8 = str => {
 
 var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
   outIdx >>>= 0;
-  assert(typeof str === "string", `stringToUTF8Array expects a string (got ${typeof str})`);
+  assert(
+    typeof str === 'string',
+    `stringToUTF8Array expects a string (got ${typeof str})`
+  );
   if (!(maxBytesToWrite > 0)) return 0;
   var startIdx = outIdx;
   var endIdx = outIdx + maxBytesToWrite - 1;
@@ -919,7 +1113,7 @@ var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
     var u = str.charCodeAt(i);
     if (u >= 55296 && u <= 57343) {
       var u1 = str.charCodeAt(++i);
-      u = 65536 + ((u & 1023) << 10) | (u1 & 1023);
+      u = (65536 + ((u & 1023) << 10)) | (u1 & 1023);
     }
     if (u <= 127) {
       if (outIdx >= endIdx) break;
@@ -935,7 +1129,12 @@ var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
       heap[outIdx++ >>> 0] = 128 | (u & 63);
     } else {
       if (outIdx + 3 >= endIdx) break;
-      if (u > 1114111) warnOnce("Invalid Unicode code point " + ptrToString(u) + " encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).");
+      if (u > 1114111)
+        warnOnce(
+          'Invalid Unicode code point ' +
+            ptrToString(u) +
+            ' encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).'
+        );
       heap[outIdx++ >>> 0] = 240 | (u >> 18);
       heap[outIdx++ >>> 0] = 128 | ((u >> 12) & 63);
       heap[outIdx++ >>> 0] = 128 | ((u >> 6) & 63);
@@ -946,7 +1145,11 @@ var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
   return outIdx - startIdx;
 };
 
-/** @type {function(string, boolean=, number=)} */ function intArrayFromString(stringy, dontAddNull, length) {
+/** @type {function(string, boolean=, number=)} */ function intArrayFromString(
+  stringy,
+  dontAddNull,
+  length
+) {
   var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
   var u8array = new Array(len);
   var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
@@ -965,17 +1168,22 @@ var FS_stdin_getChar = () => {
       try {
         bytesRead = fs.readSync(fd, buf, 0, BUFSIZE);
       } catch (e) {
-        if (e.toString().includes("EOF")) bytesRead = 0; else throw e;
+        if (e.toString().includes('EOF')) bytesRead = 0;
+        else throw e;
       }
       if (bytesRead > 0) {
-        result = buf.slice(0, bytesRead).toString("utf-8");
+        result = buf.slice(0, bytesRead).toString('utf-8');
       }
-    } else if (typeof window != "undefined" && typeof window.prompt == "function") {
-      result = window.prompt("Input: ");
+    } else if (
+      typeof window != 'undefined' &&
+      typeof window.prompt == 'function'
+    ) {
+      result = window.prompt('Input: ');
       if (result !== null) {
-        result += "\n";
+        result += '\n';
       }
-    } else {}
+    } else {
+    }
     if (!result) {
       return null;
     }
@@ -992,7 +1200,7 @@ var TTY = {
     TTY.ttys[dev] = {
       input: [],
       output: [],
-      ops: ops
+      ops: ops,
     };
     FS.registerDevice(dev, TTY.stream_ops);
   },
@@ -1050,7 +1258,7 @@ var TTY = {
         stream.node.timestamp = Date.now();
       }
       return i;
-    }
+    },
   },
   default_tty_ops: {
     get_char(tty) {
@@ -1076,15 +1284,18 @@ var TTY = {
         c_oflag: 5,
         c_cflag: 191,
         c_lflag: 35387,
-        c_cc: [ 3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
+        c_cc: [
+          3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0,
+          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+        ],
       };
     },
     ioctl_tcsets(tty, optional_actions, data) {
       return 0;
     },
     ioctl_tiocgwinsz(tty) {
-      return [ 24, 80 ];
-    }
+      return [24, 80];
+    },
   },
   default_tty1_ops: {
     put_char(tty, val) {
@@ -1100,18 +1311,20 @@ var TTY = {
         err(UTF8ArrayToString(tty.output, 0));
         tty.output = [];
       }
-    }
-  }
+    },
+  },
 };
 
-var mmapAlloc = size => {
-  abort("internal error: mmapAlloc called but `emscripten_builtin_memalign` native symbol not exported");
+var mmapAlloc = (size) => {
+  abort(
+    'internal error: mmapAlloc called but `emscripten_builtin_memalign` native symbol not exported'
+  );
 };
 
 var MEMFS = {
   ops_table: null,
   mount(mount) {
-    return MEMFS.createNode(null, "/", 16384 | 511, /* 0777 */ 0);
+    return MEMFS.createNode(null, '/', 16384 | 511, /* 0777 */ 0);
   },
   createNode(parent, name, mode, dev) {
     if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
@@ -1128,16 +1341,16 @@ var MEMFS = {
           unlink: MEMFS.node_ops.unlink,
           rmdir: MEMFS.node_ops.rmdir,
           readdir: MEMFS.node_ops.readdir,
-          symlink: MEMFS.node_ops.symlink
+          symlink: MEMFS.node_ops.symlink,
         },
         stream: {
-          llseek: MEMFS.stream_ops.llseek
-        }
+          llseek: MEMFS.stream_ops.llseek,
+        },
       },
       file: {
         node: {
           getattr: MEMFS.node_ops.getattr,
-          setattr: MEMFS.node_ops.setattr
+          setattr: MEMFS.node_ops.setattr,
         },
         stream: {
           llseek: MEMFS.stream_ops.llseek,
@@ -1145,24 +1358,24 @@ var MEMFS = {
           write: MEMFS.stream_ops.write,
           allocate: MEMFS.stream_ops.allocate,
           mmap: MEMFS.stream_ops.mmap,
-          msync: MEMFS.stream_ops.msync
-        }
+          msync: MEMFS.stream_ops.msync,
+        },
       },
       link: {
         node: {
           getattr: MEMFS.node_ops.getattr,
           setattr: MEMFS.node_ops.setattr,
-          readlink: MEMFS.node_ops.readlink
+          readlink: MEMFS.node_ops.readlink,
         },
-        stream: {}
+        stream: {},
       },
       chrdev: {
         node: {
           getattr: MEMFS.node_ops.getattr,
-          setattr: MEMFS.node_ops.setattr
+          setattr: MEMFS.node_ops.setattr,
         },
-        stream: FS.chrdev_stream_ops
-      }
+        stream: FS.chrdev_stream_ops,
+      },
     };
     var node = FS.createNode(parent, name, mode, dev);
     if (FS.isDir(node.mode)) {
@@ -1190,18 +1403,23 @@ var MEMFS = {
   },
   getFileDataAsTypedArray(node) {
     if (!node.contents) return new Uint8Array(0);
-    if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);
+    if (node.contents.subarray)
+      return node.contents.subarray(0, node.usedBytes);
     return new Uint8Array(node.contents);
   },
   expandFileStorage(node, newCapacity) {
     var prevCapacity = node.contents ? node.contents.length : 0;
     if (prevCapacity >= newCapacity) return;
     var CAPACITY_DOUBLING_MAX = 1024 * 1024;
-    newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125)) >>> 0);
+    newCapacity = Math.max(
+      newCapacity,
+      (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125)) >>> 0
+    );
     if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);
     var oldContents = node.contents;
     node.contents = new Uint8Array(newCapacity);
-    if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
+    if (node.usedBytes > 0)
+      node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
   },
   resizeFileStorage(node, newSize) {
     if (node.usedBytes == newSize) return;
@@ -1212,7 +1430,9 @@ var MEMFS = {
       var oldContents = node.contents;
       node.contents = new Uint8Array(newSize);
       if (oldContents) {
-        node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
+        node.contents.set(
+          oldContents.subarray(0, Math.min(newSize, node.usedBytes))
+        );
       }
       node.usedBytes = newSize;
     }
@@ -1292,7 +1512,7 @@ var MEMFS = {
       parent.timestamp = Date.now();
     },
     readdir(node) {
-      var entries = [ ".", ".." ];
+      var entries = ['.', '..'];
       for (var key of Object.keys(node.contents)) {
         entries.push(key);
       }
@@ -1308,7 +1528,7 @@ var MEMFS = {
         throw new FS.ErrnoError(28);
       }
       return node.link;
-    }
+    },
   },
   stream_ops: {
     read(stream, buffer, offset, length, position) {
@@ -1319,7 +1539,8 @@ var MEMFS = {
       if (size > 8 && contents.subarray) {
         buffer.set(contents.subarray(position, position + size), offset);
       } else {
-        for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
+        for (var i = 0; i < size; i++)
+          buffer[offset + i] = contents[position + i];
       }
       return size;
     },
@@ -1333,7 +1554,10 @@ var MEMFS = {
       node.timestamp = Date.now();
       if (buffer.subarray && (!node.contents || node.contents.subarray)) {
         if (canOwn) {
-          assert(position === 0, "canOwn must imply no weird position inside the file");
+          assert(
+            position === 0,
+            'canOwn must imply no weird position inside the file'
+          );
           node.contents = buffer.subarray(offset, offset + length);
           node.usedBytes = length;
           return length;
@@ -1390,7 +1614,11 @@ var MEMFS = {
           if (contents.subarray) {
             contents = contents.subarray(position, position + length);
           } else {
-            contents = Array.prototype.slice.call(contents, position, position + length);
+            contents = Array.prototype.slice.call(
+              contents,
+              position,
+              position + length
+            );
           }
         }
         allocated = true;
@@ -1402,29 +1630,41 @@ var MEMFS = {
       }
       return {
         ptr: ptr,
-        allocated: allocated
+        allocated: allocated,
       };
     },
     msync(stream, buffer, offset, length, mmapFlags) {
       MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
       return 0;
-    }
-  }
+    },
+  },
 };
 
-/** @param {boolean=} noRunDep */ var asyncLoad = (url, onload, onerror, noRunDep) => {
-  var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : "";
-  readAsync(url, arrayBuffer => {
-    assert(arrayBuffer, `Loading data file "${url}" failed (no arrayBuffer).`);
-    onload(new Uint8Array(arrayBuffer));
-    if (dep) removeRunDependency(dep);
-  }, event => {
-    if (onerror) {
-      onerror();
-    } else {
-      throw `Loading data file "${url}" failed.`;
+/** @param {boolean=} noRunDep */ var asyncLoad = (
+  url,
+  onload,
+  onerror,
+  noRunDep
+) => {
+  var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : '';
+  readAsync(
+    url,
+    (arrayBuffer) => {
+      assert(
+        arrayBuffer,
+        `Loading data file "${url}" failed (no arrayBuffer).`
+      );
+      onload(new Uint8Array(arrayBuffer));
+      if (dep) removeRunDependency(dep);
+    },
+    (event) => {
+      if (onerror) {
+        onerror();
+      } else {
+        throw `Loading data file "${url}" failed.`;
+      }
     }
-  });
+  );
   if (dep) addRunDependency(dep);
 };
 
@@ -1432,22 +1672,33 @@ var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
   FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
 };
 
-var preloadPlugins = Module["preloadPlugins"] || [];
+var preloadPlugins = Module['preloadPlugins'] || [];
 
 var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
-  if (typeof Browser != "undefined") Browser.init();
+  if (typeof Browser != 'undefined') Browser.init();
   var handled = false;
-  preloadPlugins.forEach(plugin => {
+  preloadPlugins.forEach((plugin) => {
     if (handled) return;
-    if (plugin["canHandle"](fullname)) {
-      plugin["handle"](byteArray, fullname, finish, onerror);
+    if (plugin['canHandle'](fullname)) {
+      plugin['handle'](byteArray, fullname, finish, onerror);
       handled = true;
     }
   });
   return handled;
 };
 
-var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
+var FS_createPreloadedFile = (
+  parent,
+  name,
+  url,
+  canRead,
+  canWrite,
+  onload,
+  onerror,
+  dontCreateFile,
+  canOwn,
+  preFinish
+) => {
   var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
   var dep = getUniqueRunDependency(`cp ${fullname}`);
   function processData(byteArray) {
@@ -1459,33 +1710,35 @@ var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, oner
       onload?.();
       removeRunDependency(dep);
     }
-    if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
-      onerror?.();
-      removeRunDependency(dep);
-    })) {
+    if (
+      FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
+        onerror?.();
+        removeRunDependency(dep);
+      })
+    ) {
       return;
     }
     finish(byteArray);
   }
   addRunDependency(dep);
-  if (typeof url == "string") {
+  if (typeof url == 'string') {
     asyncLoad(url, processData, onerror);
   } else {
     processData(url);
   }
 };
 
-var FS_modeStringToFlags = str => {
+var FS_modeStringToFlags = (str) => {
   var flagModes = {
-    "r": 0,
-    "r+": 2,
-    "w": 512 | 64 | 1,
-    "w+": 512 | 64 | 2,
-    "a": 1024 | 64 | 1,
-    "a+": 1024 | 64 | 2
+    r: 0,
+    'r+': 2,
+    w: 512 | 64 | 1,
+    'w+': 512 | 64 | 2,
+    a: 1024 | 64 | 1,
+    'a+': 1024 | 64 | 2,
   };
   var flags = flagModes[str];
-  if (typeof flags == "undefined") {
+  if (typeof flags == 'undefined') {
     throw new Error(`Unknown file open mode: ${str}`);
   }
   return flags;
@@ -1499,249 +1752,249 @@ var FS_getMode = (canRead, canWrite) => {
 };
 
 var ERRNO_MESSAGES = {
-  0: "Success",
-  1: "Arg list too long",
-  2: "Permission denied",
-  3: "Address already in use",
-  4: "Address not available",
-  5: "Address family not supported by protocol family",
-  6: "No more processes",
-  7: "Socket already connected",
-  8: "Bad file number",
-  9: "Trying to read unreadable message",
-  10: "Mount device busy",
-  11: "Operation canceled",
-  12: "No children",
-  13: "Connection aborted",
-  14: "Connection refused",
-  15: "Connection reset by peer",
-  16: "File locking deadlock error",
-  17: "Destination address required",
-  18: "Math arg out of domain of func",
-  19: "Quota exceeded",
-  20: "File exists",
-  21: "Bad address",
-  22: "File too large",
-  23: "Host is unreachable",
-  24: "Identifier removed",
-  25: "Illegal byte sequence",
-  26: "Connection already in progress",
-  27: "Interrupted system call",
-  28: "Invalid argument",
-  29: "I/O error",
-  30: "Socket is already connected",
-  31: "Is a directory",
-  32: "Too many symbolic links",
-  33: "Too many open files",
-  34: "Too many links",
-  35: "Message too long",
-  36: "Multihop attempted",
-  37: "File or path name too long",
-  38: "Network interface is not configured",
-  39: "Connection reset by network",
-  40: "Network is unreachable",
-  41: "Too many open files in system",
-  42: "No buffer space available",
-  43: "No such device",
-  44: "No such file or directory",
-  45: "Exec format error",
-  46: "No record locks available",
-  47: "The link has been severed",
-  48: "Not enough core",
-  49: "No message of desired type",
-  50: "Protocol not available",
-  51: "No space left on device",
-  52: "Function not implemented",
-  53: "Socket is not connected",
-  54: "Not a directory",
-  55: "Directory not empty",
-  56: "State not recoverable",
-  57: "Socket operation on non-socket",
-  59: "Not a typewriter",
-  60: "No such device or address",
-  61: "Value too large for defined data type",
-  62: "Previous owner died",
-  63: "Not super-user",
-  64: "Broken pipe",
-  65: "Protocol error",
-  66: "Unknown protocol",
-  67: "Protocol wrong type for socket",
-  68: "Math result not representable",
-  69: "Read only file system",
-  70: "Illegal seek",
-  71: "No such process",
-  72: "Stale file handle",
-  73: "Connection timed out",
-  74: "Text file busy",
-  75: "Cross-device link",
-  100: "Device not a stream",
-  101: "Bad font file fmt",
-  102: "Invalid slot",
-  103: "Invalid request code",
-  104: "No anode",
-  105: "Block device required",
-  106: "Channel number out of range",
-  107: "Level 3 halted",
-  108: "Level 3 reset",
-  109: "Link number out of range",
-  110: "Protocol driver not attached",
-  111: "No CSI structure available",
-  112: "Level 2 halted",
-  113: "Invalid exchange",
-  114: "Invalid request descriptor",
-  115: "Exchange full",
-  116: "No data (for no delay io)",
-  117: "Timer expired",
-  118: "Out of streams resources",
-  119: "Machine is not on the network",
-  120: "Package not installed",
-  121: "The object is remote",
-  122: "Advertise error",
-  123: "Srmount error",
-  124: "Communication error on send",
-  125: "Cross mount point (not really error)",
-  126: "Given log. name not unique",
-  127: "f.d. invalid for this operation",
-  128: "Remote address changed",
-  129: "Can   access a needed shared lib",
-  130: "Accessing a corrupted shared lib",
-  131: ".lib section in a.out corrupted",
-  132: "Attempting to link in too many libs",
-  133: "Attempting to exec a shared library",
-  135: "Streams pipe error",
-  136: "Too many users",
-  137: "Socket type not supported",
-  138: "Not supported",
-  139: "Protocol family not supported",
+  0: 'Success',
+  1: 'Arg list too long',
+  2: 'Permission denied',
+  3: 'Address already in use',
+  4: 'Address not available',
+  5: 'Address family not supported by protocol family',
+  6: 'No more processes',
+  7: 'Socket already connected',
+  8: 'Bad file number',
+  9: 'Trying to read unreadable message',
+  10: 'Mount device busy',
+  11: 'Operation canceled',
+  12: 'No children',
+  13: 'Connection aborted',
+  14: 'Connection refused',
+  15: 'Connection reset by peer',
+  16: 'File locking deadlock error',
+  17: 'Destination address required',
+  18: 'Math arg out of domain of func',
+  19: 'Quota exceeded',
+  20: 'File exists',
+  21: 'Bad address',
+  22: 'File too large',
+  23: 'Host is unreachable',
+  24: 'Identifier removed',
+  25: 'Illegal byte sequence',
+  26: 'Connection already in progress',
+  27: 'Interrupted system call',
+  28: 'Invalid argument',
+  29: 'I/O error',
+  30: 'Socket is already connected',
+  31: 'Is a directory',
+  32: 'Too many symbolic links',
+  33: 'Too many open files',
+  34: 'Too many links',
+  35: 'Message too long',
+  36: 'Multihop attempted',
+  37: 'File or path name too long',
+  38: 'Network interface is not configured',
+  39: 'Connection reset by network',
+  40: 'Network is unreachable',
+  41: 'Too many open files in system',
+  42: 'No buffer space available',
+  43: 'No such device',
+  44: 'No such file or directory',
+  45: 'Exec format error',
+  46: 'No record locks available',
+  47: 'The link has been severed',
+  48: 'Not enough core',
+  49: 'No message of desired type',
+  50: 'Protocol not available',
+  51: 'No space left on device',
+  52: 'Function not implemented',
+  53: 'Socket is not connected',
+  54: 'Not a directory',
+  55: 'Directory not empty',
+  56: 'State not recoverable',
+  57: 'Socket operation on non-socket',
+  59: 'Not a typewriter',
+  60: 'No such device or address',
+  61: 'Value too large for defined data type',
+  62: 'Previous owner died',
+  63: 'Not super-user',
+  64: 'Broken pipe',
+  65: 'Protocol error',
+  66: 'Unknown protocol',
+  67: 'Protocol wrong type for socket',
+  68: 'Math result not representable',
+  69: 'Read only file system',
+  70: 'Illegal seek',
+  71: 'No such process',
+  72: 'Stale file handle',
+  73: 'Connection timed out',
+  74: 'Text file busy',
+  75: 'Cross-device link',
+  100: 'Device not a stream',
+  101: 'Bad font file fmt',
+  102: 'Invalid slot',
+  103: 'Invalid request code',
+  104: 'No anode',
+  105: 'Block device required',
+  106: 'Channel number out of range',
+  107: 'Level 3 halted',
+  108: 'Level 3 reset',
+  109: 'Link number out of range',
+  110: 'Protocol driver not attached',
+  111: 'No CSI structure available',
+  112: 'Level 2 halted',
+  113: 'Invalid exchange',
+  114: 'Invalid request descriptor',
+  115: 'Exchange full',
+  116: 'No data (for no delay io)',
+  117: 'Timer expired',
+  118: 'Out of streams resources',
+  119: 'Machine is not on the network',
+  120: 'Package not installed',
+  121: 'The object is remote',
+  122: 'Advertise error',
+  123: 'Srmount error',
+  124: 'Communication error on send',
+  125: 'Cross mount point (not really error)',
+  126: 'Given log. name not unique',
+  127: 'f.d. invalid for this operation',
+  128: 'Remote address changed',
+  129: 'Can   access a needed shared lib',
+  130: 'Accessing a corrupted shared lib',
+  131: '.lib section in a.out corrupted',
+  132: 'Attempting to link in too many libs',
+  133: 'Attempting to exec a shared library',
+  135: 'Streams pipe error',
+  136: 'Too many users',
+  137: 'Socket type not supported',
+  138: 'Not supported',
+  139: 'Protocol family not supported',
   140: "Can't send after socket shutdown",
-  141: "Too many references",
-  142: "Host is down",
-  148: "No medium (in tape drive)",
-  156: "Level 2 not synchronized"
+  141: 'Too many references',
+  142: 'Host is down',
+  148: 'No medium (in tape drive)',
+  156: 'Level 2 not synchronized',
 };
 
 var ERRNO_CODES = {
-  "EPERM": 63,
-  "ENOENT": 44,
-  "ESRCH": 71,
-  "EINTR": 27,
-  "EIO": 29,
-  "ENXIO": 60,
-  "E2BIG": 1,
-  "ENOEXEC": 45,
-  "EBADF": 8,
-  "ECHILD": 12,
-  "EAGAIN": 6,
-  "EWOULDBLOCK": 6,
-  "ENOMEM": 48,
-  "EACCES": 2,
-  "EFAULT": 21,
-  "ENOTBLK": 105,
-  "EBUSY": 10,
-  "EEXIST": 20,
-  "EXDEV": 75,
-  "ENODEV": 43,
-  "ENOTDIR": 54,
-  "EISDIR": 31,
-  "EINVAL": 28,
-  "ENFILE": 41,
-  "EMFILE": 33,
-  "ENOTTY": 59,
-  "ETXTBSY": 74,
-  "EFBIG": 22,
-  "ENOSPC": 51,
-  "ESPIPE": 70,
-  "EROFS": 69,
-  "EMLINK": 34,
-  "EPIPE": 64,
-  "EDOM": 18,
-  "ERANGE": 68,
-  "ENOMSG": 49,
-  "EIDRM": 24,
-  "ECHRNG": 106,
-  "EL2NSYNC": 156,
-  "EL3HLT": 107,
-  "EL3RST": 108,
-  "ELNRNG": 109,
-  "EUNATCH": 110,
-  "ENOCSI": 111,
-  "EL2HLT": 112,
-  "EDEADLK": 16,
-  "ENOLCK": 46,
-  "EBADE": 113,
-  "EBADR": 114,
-  "EXFULL": 115,
-  "ENOANO": 104,
-  "EBADRQC": 103,
-  "EBADSLT": 102,
-  "EDEADLOCK": 16,
-  "EBFONT": 101,
-  "ENOSTR": 100,
-  "ENODATA": 116,
-  "ETIME": 117,
-  "ENOSR": 118,
-  "ENONET": 119,
-  "ENOPKG": 120,
-  "EREMOTE": 121,
-  "ENOLINK": 47,
-  "EADV": 122,
-  "ESRMNT": 123,
-  "ECOMM": 124,
-  "EPROTO": 65,
-  "EMULTIHOP": 36,
-  "EDOTDOT": 125,
-  "EBADMSG": 9,
-  "ENOTUNIQ": 126,
-  "EBADFD": 127,
-  "EREMCHG": 128,
-  "ELIBACC": 129,
-  "ELIBBAD": 130,
-  "ELIBSCN": 131,
-  "ELIBMAX": 132,
-  "ELIBEXEC": 133,
-  "ENOSYS": 52,
-  "ENOTEMPTY": 55,
-  "ENAMETOOLONG": 37,
-  "ELOOP": 32,
-  "EOPNOTSUPP": 138,
-  "EPFNOSUPPORT": 139,
-  "ECONNRESET": 15,
-  "ENOBUFS": 42,
-  "EAFNOSUPPORT": 5,
-  "EPROTOTYPE": 67,
-  "ENOTSOCK": 57,
-  "ENOPROTOOPT": 50,
-  "ESHUTDOWN": 140,
-  "ECONNREFUSED": 14,
-  "EADDRINUSE": 3,
-  "ECONNABORTED": 13,
-  "ENETUNREACH": 40,
-  "ENETDOWN": 38,
-  "ETIMEDOUT": 73,
-  "EHOSTDOWN": 142,
-  "EHOSTUNREACH": 23,
-  "EINPROGRESS": 26,
-  "EALREADY": 7,
-  "EDESTADDRREQ": 17,
-  "EMSGSIZE": 35,
-  "EPROTONOSUPPORT": 66,
-  "ESOCKTNOSUPPORT": 137,
-  "EADDRNOTAVAIL": 4,
-  "ENETRESET": 39,
-  "EISCONN": 30,
-  "ENOTCONN": 53,
-  "ETOOMANYREFS": 141,
-  "EUSERS": 136,
-  "EDQUOT": 19,
-  "ESTALE": 72,
-  "ENOTSUP": 138,
-  "ENOMEDIUM": 148,
-  "EILSEQ": 25,
-  "EOVERFLOW": 61,
-  "ECANCELED": 11,
-  "ENOTRECOVERABLE": 56,
-  "EOWNERDEAD": 62,
-  "ESTRPIPE": 135
+  EPERM: 63,
+  ENOENT: 44,
+  ESRCH: 71,
+  EINTR: 27,
+  EIO: 29,
+  ENXIO: 60,
+  E2BIG: 1,
+  ENOEXEC: 45,
+  EBADF: 8,
+  ECHILD: 12,
+  EAGAIN: 6,
+  EWOULDBLOCK: 6,
+  ENOMEM: 48,
+  EACCES: 2,
+  EFAULT: 21,
+  ENOTBLK: 105,
+  EBUSY: 10,
+  EEXIST: 20,
+  EXDEV: 75,
+  ENODEV: 43,
+  ENOTDIR: 54,
+  EISDIR: 31,
+  EINVAL: 28,
+  ENFILE: 41,
+  EMFILE: 33,
+  ENOTTY: 59,
+  ETXTBSY: 74,
+  EFBIG: 22,
+  ENOSPC: 51,
+  ESPIPE: 70,
+  EROFS: 69,
+  EMLINK: 34,
+  EPIPE: 64,
+  EDOM: 18,
+  ERANGE: 68,
+  ENOMSG: 49,
+  EIDRM: 24,
+  ECHRNG: 106,
+  EL2NSYNC: 156,
+  EL3HLT: 107,
+  EL3RST: 108,
+  ELNRNG: 109,
+  EUNATCH: 110,
+  ENOCSI: 111,
+  EL2HLT: 112,
+  EDEADLK: 16,
+  ENOLCK: 46,
+  EBADE: 113,
+  EBADR: 114,
+  EXFULL: 115,
+  ENOANO: 104,
+  EBADRQC: 103,
+  EBADSLT: 102,
+  EDEADLOCK: 16,
+  EBFONT: 101,
+  ENOSTR: 100,
+  ENODATA: 116,
+  ETIME: 117,
+  ENOSR: 118,
+  ENONET: 119,
+  ENOPKG: 120,
+  EREMOTE: 121,
+  ENOLINK: 47,
+  EADV: 122,
+  ESRMNT: 123,
+  ECOMM: 124,
+  EPROTO: 65,
+  EMULTIHOP: 36,
+  EDOTDOT: 125,
+  EBADMSG: 9,
+  ENOTUNIQ: 126,
+  EBADFD: 127,
+  EREMCHG: 128,
+  ELIBACC: 129,
+  ELIBBAD: 130,
+  ELIBSCN: 131,
+  ELIBMAX: 132,
+  ELIBEXEC: 133,
+  ENOSYS: 52,
+  ENOTEMPTY: 55,
+  ENAMETOOLONG: 37,
+  ELOOP: 32,
+  EOPNOTSUPP: 138,
+  EPFNOSUPPORT: 139,
+  ECONNRESET: 15,
+  ENOBUFS: 42,
+  EAFNOSUPPORT: 5,
+  EPROTOTYPE: 67,
+  ENOTSOCK: 57,
+  ENOPROTOOPT: 50,
+  ESHUTDOWN: 140,
+  ECONNREFUSED: 14,
+  EADDRINUSE: 3,
+  ECONNABORTED: 13,
+  ENETUNREACH: 40,
+  ENETDOWN: 38,
+  ETIMEDOUT: 73,
+  EHOSTDOWN: 142,
+  EHOSTUNREACH: 23,
+  EINPROGRESS: 26,
+  EALREADY: 7,
+  EDESTADDRREQ: 17,
+  EMSGSIZE: 35,
+  EPROTONOSUPPORT: 66,
+  ESOCKTNOSUPPORT: 137,
+  EADDRNOTAVAIL: 4,
+  ENETRESET: 39,
+  EISCONN: 30,
+  ENOTCONN: 53,
+  ETOOMANYREFS: 141,
+  EUSERS: 136,
+  EDQUOT: 19,
+  ESTALE: 72,
+  ENOTSUP: 138,
+  ENOMEDIUM: 148,
+  EILSEQ: 25,
+  EOVERFLOW: 61,
+  ECANCELED: 11,
+  ENOTRECOVERABLE: 56,
+  EOWNERDEAD: 62,
+  ESTRPIPE: 135,
 };
 
 export var FS = {
@@ -1751,13 +2004,13 @@ export var FS = {
   streams: [],
   nextInode: 1,
   nameTable: null,
-  currentPath: "/",
+  currentPath: '/',
   initialized: false,
   ignorePermissions: true,
   ErrnoError: class extends Error {
     constructor(errno) {
       super(ERRNO_MESSAGES[errno]);
-      this.name = "ErrnoError";
+      this.name = 'ErrnoError';
       this.errno = errno;
       for (var key in ERRNO_CODES) {
         if (ERRNO_CODES[key] === errno) {
@@ -1787,7 +2040,7 @@ export var FS = {
       return (this.flags & 2097155) !== 0;
     }
     get isAppend() {
-      return (this.flags & 1024);
+      return this.flags & 1024;
     }
     get flags() {
       return this.shared.flags;
@@ -1823,13 +2076,13 @@ export var FS = {
       return (this.mode & this.readMode) === this.readMode;
     }
     set read(val) {
-      val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
+      val ? (this.mode |= this.readMode) : (this.mode &= ~this.readMode);
     }
     get write() {
       return (this.mode & this.writeMode) === this.writeMode;
     }
     set write(val) {
-      val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
+      val ? (this.mode |= this.writeMode) : (this.mode &= ~this.writeMode);
     }
     get isFolder() {
       return FS.isDir(this.mode);
@@ -1840,23 +2093,24 @@ export var FS = {
   },
   lookupPath(path, opts = {}) {
     path = PATH_FS.resolve(path);
-    if (!path) return {
-      path: "",
-      node: null
-    };
+    if (!path)
+      return {
+        path: '',
+        node: null,
+      };
     var defaults = {
       follow_mount: true,
-      recurse_count: 0
+      recurse_count: 0,
     };
     opts = Object.assign(defaults, opts);
     if (opts.recurse_count > 8) {
       throw new FS.ErrnoError(32);
     }
-    var parts = path.split("/").filter(p => !!p);
+    var parts = path.split('/').filter((p) => !!p);
     var current = FS.root;
-    var current_path = "/";
+    var current_path = '/';
     for (var i = 0; i < parts.length; i++) {
-      var islast = (i === parts.length - 1);
+      var islast = i === parts.length - 1;
       if (islast && opts.parent) {
         break;
       }
@@ -1873,7 +2127,7 @@ export var FS = {
           var link = FS.readlink(current_path);
           current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
           var lookup = FS.lookupPath(current_path, {
-            recurse_count: opts.recurse_count + 1
+            recurse_count: opts.recurse_count + 1,
           });
           current = lookup.node;
           if (count++ > 40) {
@@ -1884,7 +2138,7 @@ export var FS = {
     }
     return {
       path: current_path,
-      node: current
+      node: current,
     };
   },
   getPath(node) {
@@ -1893,7 +2147,9 @@ export var FS = {
       if (FS.isRoot(node)) {
         var mount = node.mount.mountpoint;
         if (!path) return mount;
-        return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;
+        return mount[mount.length - 1] !== '/'
+          ? `${mount}/${path}`
+          : mount + path;
       }
       path = path ? `${node.name}/${path}` : node.name;
       node = node.parent;
@@ -1941,7 +2197,7 @@ export var FS = {
     return FS.lookup(parent, name);
   },
   createNode(parent, name, mode, rdev) {
-    assert(typeof parent == "object");
+    assert(typeof parent == 'object');
     var node = new FS.FSNode(parent, name, mode, rdev);
     FS.hashAddNode(node);
     return node;
@@ -1977,9 +2233,9 @@ export var FS = {
     return (mode & 49152) === 49152;
   },
   flagsToPermissionString(flag) {
-    var perms = [ "r", "w", "rw" ][flag & 3];
-    if ((flag & 512)) {
-      perms += "w";
+    var perms = ['r', 'w', 'rw'][flag & 3];
+    if (flag & 512) {
+      perms += 'w';
     }
     return perms;
   },
@@ -1987,18 +2243,18 @@ export var FS = {
     if (FS.ignorePermissions) {
       return 0;
     }
-    if (perms.includes("r") && !(node.mode & 292)) {
+    if (perms.includes('r') && !(node.mode & 292)) {
       return 2;
-    } else if (perms.includes("w") && !(node.mode & 146)) {
+    } else if (perms.includes('w') && !(node.mode & 146)) {
       return 2;
-    } else if (perms.includes("x") && !(node.mode & 73)) {
+    } else if (perms.includes('x') && !(node.mode & 73)) {
       return 2;
     }
     return 0;
   },
   mayLookup(dir) {
     if (!FS.isDir(dir.mode)) return 54;
-    var errCode = FS.nodePermissions(dir, "x");
+    var errCode = FS.nodePermissions(dir, 'x');
     if (errCode) return errCode;
     if (!dir.node_ops.lookup) return 2;
     return 0;
@@ -2008,7 +2264,7 @@ export var FS = {
       var node = FS.lookupNode(dir, name);
       return 20;
     } catch (e) {}
-    return FS.nodePermissions(dir, "wx");
+    return FS.nodePermissions(dir, 'wx');
   },
   mayDelete(dir, name, isdir) {
     var node;
@@ -2017,7 +2273,7 @@ export var FS = {
     } catch (e) {
       return e.errno;
     }
-    var errCode = FS.nodePermissions(dir, "wx");
+    var errCode = FS.nodePermissions(dir, 'wx');
     if (errCode) {
       return errCode;
     }
@@ -2042,7 +2298,7 @@ export var FS = {
     if (FS.isLink(node.mode)) {
       return 32;
     } else if (FS.isDir(node.mode)) {
-      if (FS.flagsToPermissionString(flags) !== "r" || (flags & 512)) {
+      if (FS.flagsToPermissionString(flags) !== 'r' || flags & 512) {
         return 31;
       }
     }
@@ -2064,9 +2320,9 @@ export var FS = {
     }
     return stream;
   },
-  getStream: fd => FS.streams[fd],
+  getStream: (fd) => FS.streams[fd],
   createStream(stream, fd = -1) {
-    stream = Object.assign(new FS.FSStream, stream);
+    stream = Object.assign(new FS.FSStream(), stream);
     if (fd == -1) {
       fd = FS.nextfd();
     }
@@ -2090,20 +2346,20 @@ export var FS = {
     },
     llseek() {
       throw new FS.ErrnoError(70);
-    }
+    },
   },
-  major: dev => ((dev) >> 8),
-  minor: dev => ((dev) & 255),
-  makedev: (ma, mi) => ((ma) << 8 | (mi)),
+  major: (dev) => dev >> 8,
+  minor: (dev) => dev & 255,
+  makedev: (ma, mi) => (ma << 8) | mi,
   registerDevice(dev, ops) {
     FS.devices[dev] = {
-      stream_ops: ops
+      stream_ops: ops,
     };
   },
-  getDevice: dev => FS.devices[dev],
+  getDevice: (dev) => FS.devices[dev],
   getMounts(mount) {
     var mounts = [];
-    var check = [ mount ];
+    var check = [mount];
     while (check.length) {
       var m = check.pop();
       mounts.push(m);
@@ -2112,13 +2368,15 @@ export var FS = {
     return mounts;
   },
   syncfs(populate, callback) {
-    if (typeof populate == "function") {
+    if (typeof populate == 'function') {
       callback = populate;
       populate = false;
     }
     FS.syncFSRequests++;
     if (FS.syncFSRequests > 1) {
-      err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
+      err(
+        `warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`
+      );
     }
     var mounts = FS.getMounts(FS.root.mount);
     var completed = 0;
@@ -2139,7 +2397,7 @@ export var FS = {
         doCallback(null);
       }
     }
-    mounts.forEach(mount => {
+    mounts.forEach((mount) => {
       if (!mount.type.syncfs) {
         return done(null);
       }
@@ -2147,17 +2405,17 @@ export var FS = {
     });
   },
   mount(type, opts, mountpoint) {
-    if (typeof type == "string") {
+    if (typeof type == 'string') {
       throw type;
     }
-    var root = mountpoint === "/";
+    var root = mountpoint === '/';
     var pseudo = !mountpoint;
     var node;
     if (root && FS.root) {
       throw new FS.ErrnoError(10);
     } else if (!root && !pseudo) {
       var lookup = FS.lookupPath(mountpoint, {
-        follow_mount: false
+        follow_mount: false,
       });
       mountpoint = lookup.path;
       node = lookup.node;
@@ -2172,7 +2430,7 @@ export var FS = {
       type: type,
       opts: opts,
       mountpoint: mountpoint,
-      mounts: []
+      mounts: [],
     };
     var mountRoot = type.mount(mount);
     mountRoot.mount = mount;
@@ -2189,7 +2447,7 @@ export var FS = {
   },
   unmount(mountpoint) {
     var lookup = FS.lookupPath(mountpoint, {
-      follow_mount: false
+      follow_mount: false,
     });
     if (!FS.isMountpoint(lookup.node)) {
       throw new FS.ErrnoError(28);
@@ -2197,7 +2455,7 @@ export var FS = {
     var node = lookup.node;
     var mount = node.mounted;
     var mounts = FS.getMounts(mount);
-    Object.keys(FS.nameTable).forEach(hash => {
+    Object.keys(FS.nameTable).forEach((hash) => {
       var current = FS.nameTable[hash];
       while (current) {
         var next = current.name_next;
@@ -2217,11 +2475,11 @@ export var FS = {
   },
   mknod(path, mode, dev) {
     var lookup = FS.lookupPath(path, {
-      parent: true
+      parent: true,
     });
     var parent = lookup.node;
     var name = PATH.basename(path);
-    if (!name || name === "." || name === "..") {
+    if (!name || name === '.' || name === '..') {
       throw new FS.ErrnoError(28);
     }
     var errCode = FS.mayCreate(parent, name);
@@ -2246,11 +2504,11 @@ export var FS = {
     return FS.mknod(path, mode, 0);
   },
   mkdirTree(path, mode) {
-    var dirs = path.split("/");
-    var d = "";
+    var dirs = path.split('/');
+    var d = '';
     for (var i = 0; i < dirs.length; ++i) {
       if (!dirs[i]) continue;
-      d += "/" + dirs[i];
+      d += '/' + dirs[i];
       try {
         FS.mkdir(d, mode);
       } catch (e) {
@@ -2259,7 +2517,7 @@ export var FS = {
     }
   },
   mkdev(path, mode, dev) {
-    if (typeof dev == "undefined") {
+    if (typeof dev == 'undefined') {
       dev = mode;
       mode = 438;
     }
@@ -2271,7 +2529,7 @@ export var FS = {
       throw new FS.ErrnoError(44);
     }
     var lookup = FS.lookupPath(newpath, {
-      parent: true
+      parent: true,
     });
     var parent = lookup.node;
     if (!parent) {
@@ -2294,11 +2552,11 @@ export var FS = {
     var new_name = PATH.basename(new_path);
     var lookup, old_dir, new_dir;
     lookup = FS.lookupPath(old_path, {
-      parent: true
+      parent: true,
     });
     old_dir = lookup.node;
     lookup = FS.lookupPath(new_path, {
-      parent: true
+      parent: true,
     });
     new_dir = lookup.node;
     if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
@@ -2307,11 +2565,11 @@ export var FS = {
     }
     var old_node = FS.lookupNode(old_dir, old_name);
     var relative = PATH_FS.relative(old_path, new_dirname);
-    if (relative.charAt(0) !== ".") {
+    if (relative.charAt(0) !== '.') {
       throw new FS.ErrnoError(28);
     }
     relative = PATH_FS.relative(new_path, old_dirname);
-    if (relative.charAt(0) !== ".") {
+    if (relative.charAt(0) !== '.') {
       throw new FS.ErrnoError(55);
     }
     var new_node;
@@ -2326,7 +2584,9 @@ export var FS = {
     if (errCode) {
       throw new FS.ErrnoError(errCode);
     }
-    errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
+    errCode = new_node
+      ? FS.mayDelete(new_dir, new_name, isdir)
+      : FS.mayCreate(new_dir, new_name);
     if (errCode) {
       throw new FS.ErrnoError(errCode);
     }
@@ -2337,7 +2597,7 @@ export var FS = {
       throw new FS.ErrnoError(10);
     }
     if (new_dir !== old_dir) {
-      errCode = FS.nodePermissions(old_dir, "w");
+      errCode = FS.nodePermissions(old_dir, 'w');
       if (errCode) {
         throw new FS.ErrnoError(errCode);
       }
@@ -2353,7 +2613,7 @@ export var FS = {
   },
   rmdir(path) {
     var lookup = FS.lookupPath(path, {
-      parent: true
+      parent: true,
     });
     var parent = lookup.node;
     var name = PATH.basename(path);
@@ -2373,7 +2633,7 @@ export var FS = {
   },
   readdir(path) {
     var lookup = FS.lookupPath(path, {
-      follow: true
+      follow: true,
     });
     var node = lookup.node;
     if (!node.node_ops.readdir) {
@@ -2383,7 +2643,7 @@ export var FS = {
   },
   unlink(path) {
     var lookup = FS.lookupPath(path, {
-      parent: true
+      parent: true,
     });
     var parent = lookup.node;
     if (!parent) {
@@ -2413,11 +2673,14 @@ export var FS = {
     if (!link.node_ops.readlink) {
       throw new FS.ErrnoError(28);
     }
-    return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
+    return PATH_FS.resolve(
+      FS.getPath(link.parent),
+      link.node_ops.readlink(link)
+    );
   },
   stat(path, dontFollow) {
     var lookup = FS.lookupPath(path, {
-      follow: !dontFollow
+      follow: !dontFollow,
     });
     var node = lookup.node;
     if (!node) {
@@ -2433,9 +2696,9 @@ export var FS = {
   },
   chmod(path, mode, dontFollow) {
     var node;
-    if (typeof path == "string") {
+    if (typeof path == 'string') {
       var lookup = FS.lookupPath(path, {
-        follow: !dontFollow
+        follow: !dontFollow,
       });
       node = lookup.node;
     } else {
@@ -2446,7 +2709,7 @@ export var FS = {
     }
     node.node_ops.setattr(node, {
       mode: (mode & 4095) | (node.mode & ~4095),
-      timestamp: Date.now()
+      timestamp: Date.now(),
     });
   },
   lchmod(path, mode) {
@@ -2458,9 +2721,9 @@ export var FS = {
   },
   chown(path, uid, gid, dontFollow) {
     var node;
-    if (typeof path == "string") {
+    if (typeof path == 'string') {
       var lookup = FS.lookupPath(path, {
-        follow: !dontFollow
+        follow: !dontFollow,
       });
       node = lookup.node;
     } else {
@@ -2470,7 +2733,7 @@ export var FS = {
       throw new FS.ErrnoError(63);
     }
     node.node_ops.setattr(node, {
-      timestamp: Date.now()
+      timestamp: Date.now(),
     });
   },
   lchown(path, uid, gid) {
@@ -2485,9 +2748,9 @@ export var FS = {
       throw new FS.ErrnoError(28);
     }
     var node;
-    if (typeof path == "string") {
+    if (typeof path == 'string') {
       var lookup = FS.lookupPath(path, {
-        follow: true
+        follow: true,
       });
       node = lookup.node;
     } else {
@@ -2502,13 +2765,13 @@ export var FS = {
     if (!FS.isFile(node.mode)) {
       throw new FS.ErrnoError(28);
     }
-    var errCode = FS.nodePermissions(node, "w");
+    var errCode = FS.nodePermissions(node, 'w');
     if (errCode) {
       throw new FS.ErrnoError(errCode);
     }
     node.node_ops.setattr(node, {
       size: len,
-      timestamp: Date.now()
+      timestamp: Date.now(),
     });
   },
   ftruncate(fd, len) {
@@ -2520,40 +2783,40 @@ export var FS = {
   },
   utime(path, atime, mtime) {
     var lookup = FS.lookupPath(path, {
-      follow: true
+      follow: true,
     });
     var node = lookup.node;
     node.node_ops.setattr(node, {
-      timestamp: Math.max(atime, mtime)
+      timestamp: Math.max(atime, mtime),
     });
   },
   open(path, flags, mode) {
-    if (path === "") {
+    if (path === '') {
       throw new FS.ErrnoError(44);
     }
-    flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
-    if ((flags & 64)) {
-      mode = typeof mode == "undefined" ? 438 : /* 0666 */ mode;
+    flags = typeof flags == 'string' ? FS_modeStringToFlags(flags) : flags;
+    if (flags & 64) {
+      mode = typeof mode == 'undefined' ? 438 : /* 0666 */ mode;
       mode = (mode & 4095) | 32768;
     } else {
       mode = 0;
     }
     var node;
-    if (typeof path == "object") {
+    if (typeof path == 'object') {
       node = path;
     } else {
       path = PATH.normalize(path);
       try {
         var lookup = FS.lookupPath(path, {
-          follow: !(flags & 131072)
+          follow: !(flags & 131072),
         });
         node = lookup.node;
       } catch (e) {}
     }
     var created = false;
-    if ((flags & 64)) {
+    if (flags & 64) {
       if (node) {
-        if ((flags & 128)) {
+        if (flags & 128) {
           throw new FS.ErrnoError(20);
         }
       } else {
@@ -2567,7 +2830,7 @@ export var FS = {
     if (FS.isChrdev(node.mode)) {
       flags &= ~512;
     }
-    if ((flags & 65536) && !FS.isDir(node.mode)) {
+    if (flags & 65536 && !FS.isDir(node.mode)) {
       throw new FS.ErrnoError(54);
     }
     if (!created) {
@@ -2576,7 +2839,7 @@ export var FS = {
         throw new FS.ErrnoError(errCode);
       }
     }
-    if ((flags & 512) && !created) {
+    if (flags & 512 && !created) {
       FS.truncate(node, 0);
     }
     flags &= ~(128 | 512 | 131072);
@@ -2588,12 +2851,12 @@ export var FS = {
       position: 0,
       stream_ops: node.stream_ops,
       ungotten: [],
-      error: false
+      error: false,
     });
     if (stream.stream_ops.open) {
       stream.stream_ops.open(stream);
     }
-    if (Module["logReadFiles"] && !(flags & 1)) {
+    if (Module['logReadFiles'] && !(flags & 1)) {
       if (!FS.readFiles) FS.readFiles = {};
       if (!(path in FS.readFiles)) {
         FS.readFiles[path] = 1;
@@ -2651,13 +2914,19 @@ export var FS = {
     if (!stream.stream_ops.read) {
       throw new FS.ErrnoError(28);
     }
-    var seeking = typeof position != "undefined";
+    var seeking = typeof position != 'undefined';
     if (!seeking) {
       position = stream.position;
     } else if (!stream.seekable) {
       throw new FS.ErrnoError(70);
     }
-    var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
+    var bytesRead = stream.stream_ops.read(
+      stream,
+      buffer,
+      offset,
+      length,
+      position
+    );
     if (!seeking) stream.position += bytesRead;
     return bytesRead;
   },
@@ -2681,13 +2950,20 @@ export var FS = {
     if (stream.seekable && stream.flags & 1024) {
       FS.llseek(stream, 0, 2);
     }
-    var seeking = typeof position != "undefined";
+    var seeking = typeof position != 'undefined';
     if (!seeking) {
       position = stream.position;
     } else if (!stream.seekable) {
       throw new FS.ErrnoError(70);
     }
-    var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
+    var bytesWritten = stream.stream_ops.write(
+      stream,
+      buffer,
+      offset,
+      length,
+      position,
+      canOwn
+    );
     if (!seeking) stream.position += bytesWritten;
     return bytesWritten;
   },
@@ -2710,7 +2986,11 @@ export var FS = {
     stream.stream_ops.allocate(stream, offset, length);
   },
   mmap(stream, length, position, prot, flags) {
-    if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
+    if (
+      (prot & 2) !== 0 &&
+      (flags & 2) === 0 &&
+      (stream.flags & 2097155) !== 2
+    ) {
       throw new FS.ErrnoError(2);
     }
     if ((stream.flags & 2097155) === 1) {
@@ -2736,8 +3016,8 @@ export var FS = {
   },
   readFile(path, opts = {}) {
     opts.flags = opts.flags || 0;
-    opts.encoding = opts.encoding || "binary";
-    if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
+    opts.encoding = opts.encoding || 'binary';
+    if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
       throw new Error(`Invalid encoding type "${opts.encoding}"`);
     }
     var ret;
@@ -2746,9 +3026,9 @@ export var FS = {
     var length = stat.size;
     var buf = new Uint8Array(length);
     FS.read(stream, buf, 0, length, 0);
-    if (opts.encoding === "utf8") {
+    if (opts.encoding === 'utf8') {
       ret = UTF8ArrayToString(buf, 0);
-    } else if (opts.encoding === "binary") {
+    } else if (opts.encoding === 'binary') {
       ret = buf;
     }
     FS.close(stream);
@@ -2757,21 +3037,21 @@ export var FS = {
   writeFile(path, data, opts = {}) {
     opts.flags = opts.flags || 577;
     var stream = FS.open(path, opts.flags, opts.mode);
-    if (typeof data == "string") {
+    if (typeof data == 'string') {
       var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
       var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
       FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
     } else if (ArrayBuffer.isView(data)) {
       FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
     } else {
-      throw new Error("Unsupported data type");
+      throw new Error('Unsupported data type');
     }
     FS.close(stream);
   },
   cwd: () => FS.currentPath,
   chdir(path) {
     var lookup = FS.lookupPath(path, {
-      follow: true
+      follow: true,
     });
     if (lookup.node === null) {
       throw new FS.ErrnoError(44);
@@ -2779,111 +3059,119 @@ export var FS = {
     if (!FS.isDir(lookup.node.mode)) {
       throw new FS.ErrnoError(54);
     }
-    var errCode = FS.nodePermissions(lookup.node, "x");
+    var errCode = FS.nodePermissions(lookup.node, 'x');
     if (errCode) {
       throw new FS.ErrnoError(errCode);
     }
     FS.currentPath = lookup.path;
   },
   createDefaultDirectories() {
-    FS.mkdir("/tmp");
-    FS.mkdir("/home");
-    FS.mkdir("/home/web_user");
+    FS.mkdir('/tmp');
+    FS.mkdir('/home');
+    FS.mkdir('/home/web_user');
   },
   createDefaultDevices() {
-    FS.mkdir("/dev");
+    FS.mkdir('/dev');
     FS.registerDevice(FS.makedev(1, 3), {
       read: () => 0,
-      write: (stream, buffer, offset, length, pos) => length
+      write: (stream, buffer, offset, length, pos) => length,
     });
-    FS.mkdev("/dev/null", FS.makedev(1, 3));
+    FS.mkdev('/dev/null', FS.makedev(1, 3));
     TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
     TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
-    FS.mkdev("/dev/tty", FS.makedev(5, 0));
-    FS.mkdev("/dev/tty1", FS.makedev(6, 0));
-    var randomBuffer = new Uint8Array(1024), randomLeft = 0;
+    FS.mkdev('/dev/tty', FS.makedev(5, 0));
+    FS.mkdev('/dev/tty1', FS.makedev(6, 0));
+    var randomBuffer = new Uint8Array(1024),
+      randomLeft = 0;
     var randomByte = () => {
       if (randomLeft === 0) {
         randomLeft = randomFill(randomBuffer).byteLength;
       }
       return randomBuffer[--randomLeft];
     };
-    FS.createDevice("/dev", "random", randomByte);
-    FS.createDevice("/dev", "urandom", randomByte);
-    FS.mkdir("/dev/shm");
-    FS.mkdir("/dev/shm/tmp");
+    FS.createDevice('/dev', 'random', randomByte);
+    FS.createDevice('/dev', 'urandom', randomByte);
+    FS.mkdir('/dev/shm');
+    FS.mkdir('/dev/shm/tmp');
   },
   createSpecialDirectories() {
-    FS.mkdir("/proc");
-    var proc_self = FS.mkdir("/proc/self");
-    FS.mkdir("/proc/self/fd");
-    FS.mount({
-      mount() {
-        var node = FS.createNode(proc_self, "fd", 16384 | 511, /* 0777 */ 73);
-        node.node_ops = {
-          lookup(parent, name) {
-            var fd = +name;
-            var stream = FS.getStreamChecked(fd);
-            var ret = {
-              parent: null,
-              mount: {
-                mountpoint: "fake"
-              },
-              node_ops: {
-                readlink: () => stream.path
-              }
-            };
-            ret.parent = ret;
-            return ret;
-          }
-        };
-        return node;
-      }
-    }, {}, "/proc/self/fd");
+    FS.mkdir('/proc');
+    var proc_self = FS.mkdir('/proc/self');
+    FS.mkdir('/proc/self/fd');
+    FS.mount(
+      {
+        mount() {
+          var node = FS.createNode(proc_self, 'fd', 16384 | 511, /* 0777 */ 73);
+          node.node_ops = {
+            lookup(parent, name) {
+              var fd = +name;
+              var stream = FS.getStreamChecked(fd);
+              var ret = {
+                parent: null,
+                mount: {
+                  mountpoint: 'fake',
+                },
+                node_ops: {
+                  readlink: () => stream.path,
+                },
+              };
+              ret.parent = ret;
+              return ret;
+            },
+          };
+          return node;
+        },
+      },
+      {},
+      '/proc/self/fd'
+    );
   },
   createStandardStreams() {
-    if (Module["stdin"]) {
-      FS.createDevice("/dev", "stdin", Module["stdin"]);
+    if (Module['stdin']) {
+      FS.createDevice('/dev', 'stdin', Module['stdin']);
     } else {
-      FS.symlink("/dev/tty", "/dev/stdin");
+      FS.symlink('/dev/tty', '/dev/stdin');
     }
-    if (Module["stdout"]) {
-      FS.createDevice("/dev", "stdout", null, Module["stdout"]);
+    if (Module['stdout']) {
+      FS.createDevice('/dev', 'stdout', null, Module['stdout']);
     } else {
-      FS.symlink("/dev/tty", "/dev/stdout");
+      FS.symlink('/dev/tty', '/dev/stdout');
     }
-    if (Module["stderr"]) {
-      FS.createDevice("/dev", "stderr", null, Module["stderr"]);
+    if (Module['stderr']) {
+      FS.createDevice('/dev', 'stderr', null, Module['stderr']);
     } else {
-      FS.symlink("/dev/tty1", "/dev/stderr");
+      FS.symlink('/dev/tty1', '/dev/stderr');
     }
-    var stdin = FS.open("/dev/stdin", 0);
-    var stdout = FS.open("/dev/stdout", 1);
-    var stderr = FS.open("/dev/stderr", 1);
+    var stdin = FS.open('/dev/stdin', 0);
+    var stdout = FS.open('/dev/stdout', 1);
+    var stderr = FS.open('/dev/stderr', 1);
     assert(stdin.fd === 0, `invalid handle for stdin (${stdin.fd})`);
     assert(stdout.fd === 1, `invalid handle for stdout (${stdout.fd})`);
     assert(stderr.fd === 2, `invalid handle for stderr (${stderr.fd})`);
   },
   staticInit() {
-    [ 44 ].forEach(code => {
+    [44].forEach((code) => {
       FS.genericErrors[code] = new FS.ErrnoError(code);
-      FS.genericErrors[code].stack = "<generic error, no stack>";
+      FS.genericErrors[code].stack = '<generic error, no stack>';
     });
     FS.nameTable = new Array(4096);
-    FS.mount(MEMFS, {}, "/");
+    FS.mount(MEMFS, {}, '/');
     FS.createDefaultDirectories();
     FS.createDefaultDevices();
     FS.createSpecialDirectories();
     FS.filesystems = {
-      "MEMFS": MEMFS
+      MEMFS: MEMFS,
     };
   },
   init(input, output, error) {
-    assert(!FS.init.initialized, "FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)");
+    assert(
+      !FS.init.initialized,
+      'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)'
+    );
     FS.init.initialized = true;
-    Module["stdin"] = input || Module["stdin"];
-    Module["stdout"] = output || Module["stdout"];
-    Module["stderr"] = error || Module["stderr"];
+    Module['stdin'] = input || Module['stdin'];
+    Module['stdout'] = output || Module['stdout'];
+    Module['stderr'] = error || Module['stderr'];
     FS.createStandardStreams();
   },
   quit() {
@@ -2907,7 +3195,7 @@ export var FS = {
   analyzePath(path, dontResolveLastLink) {
     try {
       var lookup = FS.lookupPath(path, {
-        follow: !dontResolveLastLink
+        follow: !dontResolveLastLink,
       });
       path = lookup.path;
     } catch (e) {}
@@ -2920,32 +3208,32 @@ export var FS = {
       object: null,
       parentExists: false,
       parentPath: null,
-      parentObject: null
+      parentObject: null,
     };
     try {
       var lookup = FS.lookupPath(path, {
-        parent: true
+        parent: true,
       });
       ret.parentExists = true;
       ret.parentPath = lookup.path;
       ret.parentObject = lookup.node;
       ret.name = PATH.basename(path);
       lookup = FS.lookupPath(path, {
-        follow: !dontResolveLastLink
+        follow: !dontResolveLastLink,
       });
       ret.exists = true;
       ret.path = lookup.path;
       ret.object = lookup.node;
       ret.name = lookup.node.name;
-      ret.isRoot = lookup.path === "/";
+      ret.isRoot = lookup.path === '/';
     } catch (e) {
       ret.error = e.errno;
     }
     return ret;
   },
   createPath(parent, path, canRead, canWrite) {
-    parent = typeof parent == "string" ? parent : FS.getPath(parent);
-    var parts = path.split("/").reverse();
+    parent = typeof parent == 'string' ? parent : FS.getPath(parent);
+    var parts = path.split('/').reverse();
     while (parts.length) {
       var part = parts.pop();
       if (!part) continue;
@@ -2958,22 +3246,26 @@ export var FS = {
     return current;
   },
   createFile(parent, name, properties, canRead, canWrite) {
-    var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
+    var path = PATH.join2(
+      typeof parent == 'string' ? parent : FS.getPath(parent),
+      name
+    );
     var mode = FS_getMode(canRead, canWrite);
     return FS.create(path, mode);
   },
   createDataFile(parent, name, data, canRead, canWrite, canOwn) {
     var path = name;
     if (parent) {
-      parent = typeof parent == "string" ? parent : FS.getPath(parent);
+      parent = typeof parent == 'string' ? parent : FS.getPath(parent);
       path = name ? PATH.join2(parent, name) : parent;
     }
     var mode = FS_getMode(canRead, canWrite);
     var node = FS.create(path, mode);
     if (data) {
-      if (typeof data == "string") {
+      if (typeof data == 'string') {
         var arr = new Array(data.length);
-        for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
+        for (var i = 0, len = data.length; i < len; ++i)
+          arr[i] = data.charCodeAt(i);
         data = arr;
       }
       FS.chmod(node, mode | 146);
@@ -2984,7 +3276,10 @@ export var FS = {
     }
   },
   createDevice(parent, name, input, output) {
-    var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
+    var path = PATH.join2(
+      typeof parent == 'string' ? parent : FS.getPath(parent),
+      name
+    );
     var mode = FS_getMode(!!input, !!output);
     if (!FS.createDevice.major) FS.createDevice.major = 64;
     var dev = FS.makedev(FS.createDevice.major++, 0);
@@ -3030,14 +3325,16 @@ export var FS = {
           stream.node.timestamp = Date.now();
         }
         return i;
-      }
+      },
     });
     return FS.mkdev(path, mode, dev);
   },
   forceLoadFile(obj) {
     if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
-    if (typeof XMLHttpRequest != "undefined") {
-      throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
+    if (typeof XMLHttpRequest != 'undefined') {
+      throw new Error(
+        'Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.'
+      );
     } else if (read_) {
       try {
         obj.contents = intArrayFromString(read_(obj.url), true);
@@ -3046,7 +3343,7 @@ export var FS = {
         throw new FS.ErrnoError(29);
       }
     } else {
-      throw new Error("Cannot load without read() or XMLHttpRequest.");
+      throw new Error('Cannot load without read() or XMLHttpRequest.');
     }
   },
   createLazyFile(parent, name, url, canRead, canWrite) {
@@ -3067,49 +3364,67 @@ export var FS = {
         this.getter = getter;
       }
       cacheLength() {
-        var xhr = new XMLHttpRequest;
-        xhr.open("HEAD", url, false);
+        var xhr = new XMLHttpRequest();
+        xhr.open('HEAD', url, false);
         xhr.send(null);
-        if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
-        var datalength = Number(xhr.getResponseHeader("Content-length"));
+        if (!((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304))
+          throw new Error("Couldn't load " + url + '. Status: ' + xhr.status);
+        var datalength = Number(xhr.getResponseHeader('Content-length'));
         var header;
-        var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
-        var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
+        var hasByteServing =
+          (header = xhr.getResponseHeader('Accept-Ranges')) &&
+          header === 'bytes';
+        var usesGzip =
+          (header = xhr.getResponseHeader('Content-Encoding')) &&
+          header === 'gzip';
         var chunkSize = 1024 * 1024;
         if (!hasByteServing) chunkSize = datalength;
         var doXHR = (from, to) => {
-          if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
-          if (to > datalength - 1) throw new Error("only " + datalength + " bytes available! programmer error!");
-          var xhr = new XMLHttpRequest;
-          xhr.open("GET", url, false);
-          if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
-          xhr.responseType = "arraybuffer";
+          if (from > to)
+            throw new Error(
+              'invalid range (' + from + ', ' + to + ') or no bytes requested!'
+            );
+          if (to > datalength - 1)
+            throw new Error(
+              'only ' + datalength + ' bytes available! programmer error!'
+            );
+          var xhr = new XMLHttpRequest();
+          xhr.open('GET', url, false);
+          if (datalength !== chunkSize)
+            xhr.setRequestHeader('Range', 'bytes=' + from + '-' + to);
+          xhr.responseType = 'arraybuffer';
           if (xhr.overrideMimeType) {
-            xhr.overrideMimeType("text/plain; charset=x-user-defined");
+            xhr.overrideMimeType('text/plain; charset=x-user-defined');
           }
           xhr.send(null);
-          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
+          if (!((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304))
+            throw new Error("Couldn't load " + url + '. Status: ' + xhr.status);
           if (xhr.response !== undefined) {
-            return new Uint8Array(/** @type{Array<number>} */ (xhr.response || []));
+            return new Uint8Array(
+              /** @type{Array<number>} */ (xhr.response || [])
+            );
           }
-          return intArrayFromString(xhr.responseText || "", true);
+          return intArrayFromString(xhr.responseText || '', true);
         };
         var lazyArray = this;
-        lazyArray.setDataGetter(chunkNum => {
+        lazyArray.setDataGetter((chunkNum) => {
           var start = chunkNum * chunkSize;
           var end = (chunkNum + 1) * chunkSize - 1;
           end = Math.min(end, datalength - 1);
-          if (typeof lazyArray.chunks[chunkNum] == "undefined") {
+          if (typeof lazyArray.chunks[chunkNum] == 'undefined') {
             lazyArray.chunks[chunkNum] = doXHR(start, end);
           }
-          if (typeof lazyArray.chunks[chunkNum] == "undefined") throw new Error("doXHR failed!");
+          if (typeof lazyArray.chunks[chunkNum] == 'undefined')
+            throw new Error('doXHR failed!');
           return lazyArray.chunks[chunkNum];
         });
         if (usesGzip || !datalength) {
           chunkSize = datalength = 1;
           datalength = this.getter(0).length;
           chunkSize = datalength;
-          out("LazyFiles on gzip forces download of the whole file when length is accessed");
+          out(
+            'LazyFiles on gzip forces download of the whole file when length is accessed'
+          );
         }
         this._length = datalength;
         this._chunkSize = chunkSize;
@@ -3128,17 +3443,18 @@ export var FS = {
         return this._chunkSize;
       }
     }
-    if (typeof XMLHttpRequest != "undefined") {
-      if (!ENVIRONMENT_IS_WORKER) throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
-      var lazyArray = new LazyUint8Array;
+    if (typeof XMLHttpRequest != 'undefined') {
+      if (!ENVIRONMENT_IS_WORKER)
+        throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
+      var lazyArray = new LazyUint8Array();
       var properties = {
         isDevice: false,
-        contents: lazyArray
+        contents: lazyArray,
       };
     } else {
       var properties = {
         isDevice: false,
-        url: url
+        url: url,
       };
     }
     var node = FS.createFile(parent, name, properties, canRead, canWrite);
@@ -3150,14 +3466,14 @@ export var FS = {
     }
     Object.defineProperties(node, {
       usedBytes: {
-        get: function() {
+        get: function () {
           return this.contents.length;
-        }
-      }
+        },
+      },
     });
     var stream_ops = {};
     var keys = Object.keys(node.stream_ops);
-    keys.forEach(key => {
+    keys.forEach((key) => {
       var fn = node.stream_ops[key];
       stream_ops[key] = (...args) => {
         FS.forceLoadFile(node);
@@ -3193,50 +3509,53 @@ export var FS = {
       writeChunks(stream, HEAP8, ptr, length, position);
       return {
         ptr: ptr,
-        allocated: true
+        allocated: true,
       };
     };
     node.stream_ops = stream_ops;
     return node;
   },
   absolutePath() {
-    abort("FS.absolutePath has been removed; use PATH_FS.resolve instead");
+    abort('FS.absolutePath has been removed; use PATH_FS.resolve instead');
   },
   createFolder() {
-    abort("FS.createFolder has been removed; use FS.mkdir instead");
+    abort('FS.createFolder has been removed; use FS.mkdir instead');
   },
   createLink() {
-    abort("FS.createLink has been removed; use FS.symlink instead");
+    abort('FS.createLink has been removed; use FS.symlink instead');
   },
   joinPath() {
-    abort("FS.joinPath has been removed; use PATH.join instead");
+    abort('FS.joinPath has been removed; use PATH.join instead');
   },
   mmapAlloc() {
-    abort("FS.mmapAlloc has been replaced by the top level function mmapAlloc");
+    abort('FS.mmapAlloc has been replaced by the top level function mmapAlloc');
   },
   standardizePath() {
-    abort("FS.standardizePath has been removed; use PATH.normalize instead");
-  }
+    abort('FS.standardizePath has been removed; use PATH.normalize instead');
+  },
 };
 
 /**
-     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the
-     * emscripten HEAP, returns a copy of that string as a Javascript String object.
-     *
-     * @param {number} ptr
-     * @param {number=} maxBytesToRead - An optional length that specifies the
-     *   maximum number of bytes to read. You can omit this parameter to scan the
-     *   string until the first 0 byte. If maxBytesToRead is passed, and the string
-     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the
-     *   string will cut short at that byte index (i.e. maxBytesToRead will not
-     *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing
-     *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw
-     *   JS JIT optimizations off, so it is worth to consider consistently using one
-     * @return {string}
-     */ var UTF8ToString = (ptr, maxBytesToRead) => {
-  assert(typeof ptr == "number", `UTF8ToString expects a number (got ${typeof ptr})`);
+ * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the
+ * emscripten HEAP, returns a copy of that string as a Javascript String object.
+ *
+ * @param {number} ptr
+ * @param {number=} maxBytesToRead - An optional length that specifies the
+ *   maximum number of bytes to read. You can omit this parameter to scan the
+ *   string until the first 0 byte. If maxBytesToRead is passed, and the string
+ *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the
+ *   string will cut short at that byte index (i.e. maxBytesToRead will not
+ *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing
+ *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw
+ *   JS JIT optimizations off, so it is worth to consider consistently using one
+ * @return {string}
+ */ var UTF8ToString = (ptr, maxBytesToRead) => {
+  assert(
+    typeof ptr == 'number',
+    `UTF8ToString expects a number (got ${typeof ptr})`
+  );
   ptr >>>= 0;
-  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
+  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
 };
 
 var SYSCALLS = {
@@ -3262,33 +3581,80 @@ var SYSCALLS = {
   },
   doStat(func, path, buf) {
     var stat = func(path);
-    HEAP32[((buf) >>> 2) >>> 0] = stat.dev;
-    HEAP32[(((buf) + (4)) >>> 2) >>> 0] = stat.mode;
-    HEAPU32[(((buf) + (8)) >>> 2) >>> 0] = stat.nlink;
-    HEAP32[(((buf) + (12)) >>> 2) >>> 0] = stat.uid;
-    HEAP32[(((buf) + (16)) >>> 2) >>> 0] = stat.gid;
-    HEAP32[(((buf) + (20)) >>> 2) >>> 0] = stat.rdev;
-    (tempI64 = [ stat.size >>> 0, (tempDouble = stat.size, (+(Math.abs(tempDouble))) >= 1 ? (tempDouble > 0 ? (+(Math.floor((tempDouble) / 4294967296))) >>> 0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble))) >>> 0)) / 4294967296))))) >>> 0) : 0) ], 
-    HEAP32[(((buf) + (24)) >>> 2) >>> 0] = tempI64[0], HEAP32[(((buf) + (28)) >>> 2) >>> 0] = tempI64[1]);
-    HEAP32[(((buf) + (32)) >>> 2) >>> 0] = 4096;
-    HEAP32[(((buf) + (36)) >>> 2) >>> 0] = stat.blocks;
+    HEAP32[(buf >>> 2) >>> 0] = stat.dev;
+    HEAP32[((buf + 4) >>> 2) >>> 0] = stat.mode;
+    HEAPU32[((buf + 8) >>> 2) >>> 0] = stat.nlink;
+    HEAP32[((buf + 12) >>> 2) >>> 0] = stat.uid;
+    HEAP32[((buf + 16) >>> 2) >>> 0] = stat.gid;
+    HEAP32[((buf + 20) >>> 2) >>> 0] = stat.rdev;
+    (tempI64 = [
+      stat.size >>> 0,
+      ((tempDouble = stat.size),
+      +Math.abs(tempDouble) >= 1
+        ? tempDouble > 0
+          ? +Math.floor(tempDouble / 4294967296) >>> 0
+          : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>>
+            0
+        : 0),
+    ]),
+      (HEAP32[((buf + 24) >>> 2) >>> 0] = tempI64[0]),
+      (HEAP32[((buf + 28) >>> 2) >>> 0] = tempI64[1]);
+    HEAP32[((buf + 32) >>> 2) >>> 0] = 4096;
+    HEAP32[((buf + 36) >>> 2) >>> 0] = stat.blocks;
     var atime = stat.atime.getTime();
     var mtime = stat.mtime.getTime();
     var ctime = stat.ctime.getTime();
-    (tempI64 = [ Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), 
-    (+(Math.abs(tempDouble))) >= 1 ? (tempDouble > 0 ? (+(Math.floor((tempDouble) / 4294967296))) >>> 0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble))) >>> 0)) / 4294967296))))) >>> 0) : 0) ], 
-    HEAP32[(((buf) + (40)) >>> 2) >>> 0] = tempI64[0], HEAP32[(((buf) + (44)) >>> 2) >>> 0] = tempI64[1]);
-    HEAPU32[(((buf) + (48)) >>> 2) >>> 0] = (atime % 1e3) * 1e3;
-    (tempI64 = [ Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), 
-    (+(Math.abs(tempDouble))) >= 1 ? (tempDouble > 0 ? (+(Math.floor((tempDouble) / 4294967296))) >>> 0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble))) >>> 0)) / 4294967296))))) >>> 0) : 0) ], 
-    HEAP32[(((buf) + (56)) >>> 2) >>> 0] = tempI64[0], HEAP32[(((buf) + (60)) >>> 2) >>> 0] = tempI64[1]);
-    HEAPU32[(((buf) + (64)) >>> 2) >>> 0] = (mtime % 1e3) * 1e3;
-    (tempI64 = [ Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), 
-    (+(Math.abs(tempDouble))) >= 1 ? (tempDouble > 0 ? (+(Math.floor((tempDouble) / 4294967296))) >>> 0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble))) >>> 0)) / 4294967296))))) >>> 0) : 0) ], 
-    HEAP32[(((buf) + (72)) >>> 2) >>> 0] = tempI64[0], HEAP32[(((buf) + (76)) >>> 2) >>> 0] = tempI64[1]);
-    HEAPU32[(((buf) + (80)) >>> 2) >>> 0] = (ctime % 1e3) * 1e3;
-    (tempI64 = [ stat.ino >>> 0, (tempDouble = stat.ino, (+(Math.abs(tempDouble))) >= 1 ? (tempDouble > 0 ? (+(Math.floor((tempDouble) / 4294967296))) >>> 0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble))) >>> 0)) / 4294967296))))) >>> 0) : 0) ], 
-    HEAP32[(((buf) + (88)) >>> 2) >>> 0] = tempI64[0], HEAP32[(((buf) + (92)) >>> 2) >>> 0] = tempI64[1]);
+    (tempI64 = [
+      Math.floor(atime / 1e3) >>> 0,
+      ((tempDouble = Math.floor(atime / 1e3)),
+      +Math.abs(tempDouble) >= 1
+        ? tempDouble > 0
+          ? +Math.floor(tempDouble / 4294967296) >>> 0
+          : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>>
+            0
+        : 0),
+    ]),
+      (HEAP32[((buf + 40) >>> 2) >>> 0] = tempI64[0]),
+      (HEAP32[((buf + 44) >>> 2) >>> 0] = tempI64[1]);
+    HEAPU32[((buf + 48) >>> 2) >>> 0] = (atime % 1e3) * 1e3;
+    (tempI64 = [
+      Math.floor(mtime / 1e3) >>> 0,
+      ((tempDouble = Math.floor(mtime / 1e3)),
+      +Math.abs(tempDouble) >= 1
+        ? tempDouble > 0
+          ? +Math.floor(tempDouble / 4294967296) >>> 0
+          : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>>
+            0
+        : 0),
+    ]),
+      (HEAP32[((buf + 56) >>> 2) >>> 0] = tempI64[0]),
+      (HEAP32[((buf + 60) >>> 2) >>> 0] = tempI64[1]);
+    HEAPU32[((buf + 64) >>> 2) >>> 0] = (mtime % 1e3) * 1e3;
+    (tempI64 = [
+      Math.floor(ctime / 1e3) >>> 0,
+      ((tempDouble = Math.floor(ctime / 1e3)),
+      +Math.abs(tempDouble) >= 1
+        ? tempDouble > 0
+          ? +Math.floor(tempDouble / 4294967296) >>> 0
+          : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>>
+            0
+        : 0),
+    ]),
+      (HEAP32[((buf + 72) >>> 2) >>> 0] = tempI64[0]),
+      (HEAP32[((buf + 76) >>> 2) >>> 0] = tempI64[1]);
+    HEAPU32[((buf + 80) >>> 2) >>> 0] = (ctime % 1e3) * 1e3;
+    (tempI64 = [
+      stat.ino >>> 0,
+      ((tempDouble = stat.ino),
+      +Math.abs(tempDouble) >= 1
+        ? tempDouble > 0
+          ? +Math.floor(tempDouble / 4294967296) >>> 0
+          : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>>
+            0
+        : 0),
+    ]),
+      (HEAP32[((buf + 88) >>> 2) >>> 0] = tempI64[0]),
+      (HEAP32[((buf + 92) >>> 2) >>> 0] = tempI64[1]);
     return 0;
   },
   doMsync(addr, stream, len, flags, offset) {
@@ -3309,13 +3675,15 @@ var SYSCALLS = {
   getStr(ptr) {
     var ret = UTF8ToString(ptr);
     return ret;
-  }
+  },
 };
 
 var convertI32PairToI53Checked = (lo, hi) => {
-  assert(lo == (lo >>> 0) || lo == (lo | 0));
+  assert(lo == lo >>> 0 || lo == (lo | 0));
   assert(hi === (hi | 0));
-  return ((hi + 2097152) >>> 0 < 4194305 - !!lo) ? (lo >>> 0) + hi * 4294967296 : NaN;
+  return (hi + 2097152) >>> 0 < 4194305 - !!lo
+    ? (lo >>> 0) + hi * 4294967296
+    : NaN;
 };
 
 function ___syscall_fcntl64(fd, cmd, varargs) {
@@ -3324,8 +3692,7 @@ function ___syscall_fcntl64(fd, cmd, varargs) {
   try {
     var stream = SYSCALLS.getStreamFromFD(fd);
     switch (cmd) {
-     case 0:
-      {
+      case 0: {
         var arg = syscallGetVarargI();
         if (arg < 0) {
           return -28;
@@ -3338,35 +3705,33 @@ function ___syscall_fcntl64(fd, cmd, varargs) {
         return newStream.fd;
       }
 
-     case 1:
-     case 2:
-      return 0;
+      case 1:
+      case 2:
+        return 0;
 
-     case 3:
-      return stream.flags;
+      case 3:
+        return stream.flags;
 
-     case 4:
-      {
+      case 4: {
         var arg = syscallGetVarargI();
         stream.flags |= arg;
         return 0;
       }
 
-     case 12:
-      {
+      case 12: {
         var arg = syscallGetVarargP();
         var offset = 0;
-        HEAP16[(((arg) + (offset)) >>> 1) >>> 0] = 2;
+        HEAP16[((arg + offset) >>> 1) >>> 0] = 2;
         return 0;
       }
 
-     case 13:
-     case 14:
-      return 0;
+      case 13:
+      case 14:
+        return 0;
     }
     return -28;
   } catch (e) {
-    if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
+    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
     return -e.errno;
   }
 }
@@ -3378,7 +3743,7 @@ function ___syscall_ftruncate64(fd, length_low, length_high) {
     FS.ftruncate(fd, length);
     return 0;
   } catch (e) {
-    if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
+    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
     return -e.errno;
   }
 }
@@ -3389,113 +3754,103 @@ function ___syscall_ioctl(fd, op, varargs) {
   try {
     var stream = SYSCALLS.getStreamFromFD(fd);
     switch (op) {
-     case 21509:
-      {
+      case 21509: {
         if (!stream.tty) return -59;
         return 0;
       }
 
-     case 21505:
-      {
+      case 21505: {
         if (!stream.tty) return -59;
         if (stream.tty.ops.ioctl_tcgets) {
           var termios = stream.tty.ops.ioctl_tcgets(stream);
           var argp = syscallGetVarargP();
-          HEAP32[((argp) >>> 2) >>> 0] = termios.c_iflag || 0;
-          HEAP32[(((argp) + (4)) >>> 2) >>> 0] = termios.c_oflag || 0;
-          HEAP32[(((argp) + (8)) >>> 2) >>> 0] = termios.c_cflag || 0;
-          HEAP32[(((argp) + (12)) >>> 2) >>> 0] = termios.c_lflag || 0;
+          HEAP32[(argp >>> 2) >>> 0] = termios.c_iflag || 0;
+          HEAP32[((argp + 4) >>> 2) >>> 0] = termios.c_oflag || 0;
+          HEAP32[((argp + 8) >>> 2) >>> 0] = termios.c_cflag || 0;
+          HEAP32[((argp + 12) >>> 2) >>> 0] = termios.c_lflag || 0;
           for (var i = 0; i < 32; i++) {
-            HEAP8[(argp + i) + (17) >>> 0] = termios.c_cc[i] || 0;
+            HEAP8[(argp + i + 17) >>> 0] = termios.c_cc[i] || 0;
           }
           return 0;
         }
         return 0;
       }
 
-     case 21510:
-     case 21511:
-     case 21512:
-      {
+      case 21510:
+      case 21511:
+      case 21512: {
         if (!stream.tty) return -59;
         return 0;
       }
 
-     case 21506:
-     case 21507:
-     case 21508:
-      {
+      case 21506:
+      case 21507:
+      case 21508: {
         if (!stream.tty) return -59;
         if (stream.tty.ops.ioctl_tcsets) {
           var argp = syscallGetVarargP();
-          var c_iflag = HEAP32[((argp) >>> 2) >>> 0];
-          var c_oflag = HEAP32[(((argp) + (4)) >>> 2) >>> 0];
-          var c_cflag = HEAP32[(((argp) + (8)) >>> 2) >>> 0];
-          var c_lflag = HEAP32[(((argp) + (12)) >>> 2) >>> 0];
+          var c_iflag = HEAP32[(argp >>> 2) >>> 0];
+          var c_oflag = HEAP32[((argp + 4) >>> 2) >>> 0];
+          var c_cflag = HEAP32[((argp + 8) >>> 2) >>> 0];
+          var c_lflag = HEAP32[((argp + 12) >>> 2) >>> 0];
           var c_cc = [];
           for (var i = 0; i < 32; i++) {
-            c_cc.push(HEAP8[(argp + i) + (17) >>> 0]);
+            c_cc.push(HEAP8[(argp + i + 17) >>> 0]);
           }
           return stream.tty.ops.ioctl_tcsets(stream.tty, op, {
             c_iflag: c_iflag,
             c_oflag: c_oflag,
             c_cflag: c_cflag,
             c_lflag: c_lflag,
-            c_cc: c_cc
+            c_cc: c_cc,
           });
         }
         return 0;
       }
 
-     case 21519:
-      {
+      case 21519: {
         if (!stream.tty) return -59;
         var argp = syscallGetVarargP();
-        HEAP32[((argp) >>> 2) >>> 0] = 0;
+        HEAP32[(argp >>> 2) >>> 0] = 0;
         return 0;
       }
 
-     case 21520:
-      {
+      case 21520: {
         if (!stream.tty) return -59;
         return -28;
       }
 
-     case 21531:
-      {
+      case 21531: {
         var argp = syscallGetVarargP();
         return FS.ioctl(stream, op, argp);
       }
 
-     case 21523:
-      {
+      case 21523: {
         if (!stream.tty) return -59;
         if (stream.tty.ops.ioctl_tiocgwinsz) {
           var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
           var argp = syscallGetVarargP();
-          HEAP16[((argp) >>> 1) >>> 0] = winsize[0];
-          HEAP16[(((argp) + (2)) >>> 1) >>> 0] = winsize[1];
+          HEAP16[(argp >>> 1) >>> 0] = winsize[0];
+          HEAP16[((argp + 2) >>> 1) >>> 0] = winsize[1];
         }
         return 0;
       }
 
-     case 21524:
-      {
+      case 21524: {
         if (!stream.tty) return -59;
         return 0;
       }
 
-     case 21515:
-      {
+      case 21515: {
         if (!stream.tty) return -59;
         return 0;
       }
 
-     default:
-      return -28;
+      default:
+        return -28;
     }
   } catch (e) {
-    if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
+    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
     return -e.errno;
   }
 }
@@ -3510,7 +3865,7 @@ function ___syscall_openat(dirfd, path, flags, varargs) {
     var mode = varargs ? syscallGetVarargI() : 0;
     return FS.open(path, flags, mode).fd;
   } catch (e) {
-    if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
+    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
     return -e.errno;
   }
 }
@@ -3522,7 +3877,7 @@ function ___syscall_rmdir(path) {
     FS.rmdir(path);
     return 0;
   } catch (e) {
-    if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
+    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
     return -e.errno;
   }
 }
@@ -3537,11 +3892,11 @@ function ___syscall_unlinkat(dirfd, path, flags) {
     } else if (flags === 512) {
       FS.rmdir(path);
     } else {
-      abort("Invalid flags passed to unlinkat");
+      abort('Invalid flags passed to unlinkat');
     }
     return 0;
   } catch (e) {
-    if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
+    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
     return -e.errno;
   }
 }
@@ -3550,7 +3905,7 @@ function __emscripten_memcpy_js(dest, src, num) {
   dest >>>= 0;
   src >>>= 0;
   num >>>= 0;
-  return HEAPU8.copyWithin(dest >>> 0, src >>> 0, src + num >>> 0);
+  return HEAPU8.copyWithin(dest >>> 0, src >>> 0, (src + num) >>> 0);
 }
 
 var __emscripten_throw_longjmp = () => {
@@ -3561,63 +3916,94 @@ function __gmtime_js(time_low, time_high, tmPtr) {
   var time = convertI32PairToI53Checked(time_low, time_high);
   tmPtr >>>= 0;
   var date = new Date(time * 1e3);
-  HEAP32[((tmPtr) >>> 2) >>> 0] = date.getUTCSeconds();
-  HEAP32[(((tmPtr) + (4)) >>> 2) >>> 0] = date.getUTCMinutes();
-  HEAP32[(((tmPtr) + (8)) >>> 2) >>> 0] = date.getUTCHours();
-  HEAP32[(((tmPtr) + (12)) >>> 2) >>> 0] = date.getUTCDate();
-  HEAP32[(((tmPtr) + (16)) >>> 2) >>> 0] = date.getUTCMonth();
-  HEAP32[(((tmPtr) + (20)) >>> 2) >>> 0] = date.getUTCFullYear() - 1900;
-  HEAP32[(((tmPtr) + (24)) >>> 2) >>> 0] = date.getUTCDay();
+  HEAP32[(tmPtr >>> 2) >>> 0] = date.getUTCSeconds();
+  HEAP32[((tmPtr + 4) >>> 2) >>> 0] = date.getUTCMinutes();
+  HEAP32[((tmPtr + 8) >>> 2) >>> 0] = date.getUTCHours();
+  HEAP32[((tmPtr + 12) >>> 2) >>> 0] = date.getUTCDate();
+  HEAP32[((tmPtr + 16) >>> 2) >>> 0] = date.getUTCMonth();
+  HEAP32[((tmPtr + 20) >>> 2) >>> 0] = date.getUTCFullYear() - 1900;
+  HEAP32[((tmPtr + 24) >>> 2) >>> 0] = date.getUTCDay();
   var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
   var yday = ((date.getTime() - start) / (1e3 * 60 * 60 * 24)) | 0;
-  HEAP32[(((tmPtr) + (28)) >>> 2) >>> 0] = yday;
+  HEAP32[((tmPtr + 28) >>> 2) >>> 0] = yday;
 }
 
-/** @suppress {duplicate } */ var setTempRet0 = val => __emscripten_tempret_set(val);
+/** @suppress {duplicate } */ var setTempRet0 = (val) =>
+  __emscripten_tempret_set(val);
 
-var __timegm_js = function(tmPtr) {
+var __timegm_js = function (tmPtr) {
   tmPtr >>>= 0;
   var ret = (() => {
-    var time = Date.UTC(HEAP32[(((tmPtr) + (20)) >>> 2) >>> 0] + 1900, HEAP32[(((tmPtr) + (16)) >>> 2) >>> 0], HEAP32[(((tmPtr) + (12)) >>> 2) >>> 0], HEAP32[(((tmPtr) + (8)) >>> 2) >>> 0], HEAP32[(((tmPtr) + (4)) >>> 2) >>> 0], HEAP32[((tmPtr) >>> 2) >>> 0], 0);
+    var time = Date.UTC(
+      HEAP32[((tmPtr + 20) >>> 2) >>> 0] + 1900,
+      HEAP32[((tmPtr + 16) >>> 2) >>> 0],
+      HEAP32[((tmPtr + 12) >>> 2) >>> 0],
+      HEAP32[((tmPtr + 8) >>> 2) >>> 0],
+      HEAP32[((tmPtr + 4) >>> 2) >>> 0],
+      HEAP32[(tmPtr >>> 2) >>> 0],
+      0
+    );
     var date = new Date(time);
-    HEAP32[(((tmPtr) + (24)) >>> 2) >>> 0] = date.getUTCDay();
+    HEAP32[((tmPtr + 24) >>> 2) >>> 0] = date.getUTCDay();
     var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
     var yday = ((date.getTime() - start) / (1e3 * 60 * 60 * 24)) | 0;
-    HEAP32[(((tmPtr) + (28)) >>> 2) >>> 0] = yday;
+    HEAP32[((tmPtr + 28) >>> 2) >>> 0] = yday;
     return date.getTime() / 1e3;
   })();
-  return (setTempRet0((tempDouble = ret, (+(Math.abs(tempDouble))) >= 1 ? (tempDouble > 0 ? (+(Math.floor((tempDouble) / 4294967296))) >>> 0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble))) >>> 0)) / 4294967296))))) >>> 0) : 0)), 
-  ret >>> 0);
+  return (
+    setTempRet0(
+      ((tempDouble = ret),
+      +Math.abs(tempDouble) >= 1
+        ? tempDouble > 0
+          ? +Math.floor(tempDouble / 4294967296) >>> 0
+          : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>>
+            0
+        : 0)
+    ),
+    ret >>> 0
+  );
 };
 
 var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {
-  assert(typeof maxBytesToWrite == "number", "stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!");
+  assert(
+    typeof maxBytesToWrite == 'number',
+    'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!'
+  );
   return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
 };
 
-var __tzset_js = function(timezone, daylight, std_name, dst_name) {
+var __tzset_js = function (timezone, daylight, std_name, dst_name) {
   timezone >>>= 0;
   daylight >>>= 0;
   std_name >>>= 0;
   dst_name >>>= 0;
-  var currentYear = (new Date).getFullYear();
+  var currentYear = new Date().getFullYear();
   var winter = new Date(currentYear, 0, 1);
   var summer = new Date(currentYear, 6, 1);
   var winterOffset = winter.getTimezoneOffset();
   var summerOffset = summer.getTimezoneOffset();
   var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
-  HEAPU32[((timezone) >>> 2) >>> 0] = stdTimezoneOffset * 60;
-  HEAP32[((daylight) >>> 2) >>> 0] = Number(winterOffset != summerOffset);
-  var extractZone = date => date.toLocaleTimeString(undefined, {
-    hour12: false,
-    timeZoneName: "short"
-  }).split(" ")[1];
+  HEAPU32[(timezone >>> 2) >>> 0] = stdTimezoneOffset * 60;
+  HEAP32[(daylight >>> 2) >>> 0] = Number(winterOffset != summerOffset);
+  var extractZone = (date) =>
+    date
+      .toLocaleTimeString(undefined, {
+        hour12: false,
+        timeZoneName: 'short',
+      })
+      .split(' ')[1];
   var winterName = extractZone(winter);
   var summerName = extractZone(summer);
   assert(winterName);
   assert(summerName);
-  assert(lengthBytesUTF8(winterName) <= 16, `timezone name truncated to fit in TZNAME_MAX (${winterName})`);
-  assert(lengthBytesUTF8(summerName) <= 16, `timezone name truncated to fit in TZNAME_MAX (${summerName})`);
+  assert(
+    lengthBytesUTF8(winterName) <= 16,
+    `timezone name truncated to fit in TZNAME_MAX (${winterName})`
+  );
+  assert(
+    lengthBytesUTF8(summerName) <= 16,
+    `timezone name truncated to fit in TZNAME_MAX (${summerName})`
+  );
   if (summerOffset < winterOffset) {
     stringToUTF8(winterName, std_name, 17);
     stringToUTF8(summerName, dst_name, 17);
@@ -3634,14 +4020,23 @@ var readEmAsmArgs = (sigPtr, buf) => {
   assert(buf % 16 == 0);
   readEmAsmArgsArray.length = 0;
   var ch;
-  while (ch = HEAPU8[sigPtr++ >>> 0]) {
+  while ((ch = HEAPU8[sigPtr++ >>> 0])) {
     var chr = String.fromCharCode(ch);
-    var validChars = [ "d", "f", "i", "p" ];
-    assert(validChars.includes(chr), `Invalid character ${ch}("${chr}") in readEmAsmArgs! Use only [${validChars}], and do not specify "v" for void return argument.`);
-    var wide = (ch != 105);
-    wide &= (ch != 112);
-    buf += wide && (buf % 8) ? 4 : 0;
-    readEmAsmArgsArray.push(ch == 112 ? HEAPU32[((buf) >>> 2) >>> 0] : ch == 105 ? HEAP32[((buf) >>> 2) >>> 0] : HEAPF64[((buf) >>> 3) >>> 0]);
+    var validChars = ['d', 'f', 'i', 'p'];
+    assert(
+      validChars.includes(chr),
+      `Invalid character ${ch}("${chr}") in readEmAsmArgs! Use only [${validChars}], and do not specify "v" for void return argument.`
+    );
+    var wide = ch != 105;
+    wide &= ch != 112;
+    buf += wide && buf % 8 ? 4 : 0;
+    readEmAsmArgsArray.push(
+      ch == 112
+        ? HEAPU32[(buf >>> 2) >>> 0]
+        : ch == 105
+        ? HEAP32[(buf >>> 2) >>> 0]
+        : HEAPF64[(buf >>> 3) >>> 0]
+    );
     buf += wide ? 8 : 4;
   }
   return readEmAsmArgsArray;
@@ -3649,7 +4044,10 @@ var readEmAsmArgs = (sigPtr, buf) => {
 
 var runEmAsmFunction = (code, sigPtr, argbuf) => {
   var args = readEmAsmArgs(sigPtr, argbuf);
-  assert(ASM_CONSTS.hasOwnProperty(code), `No EM_ASM constant found at address ${code}.  The loaded WebAssembly file is likely out of sync with the generated JavaScript.`);
+  assert(
+    ASM_CONSTS.hasOwnProperty(code),
+    `No EM_ASM constant found at address ${code}.  The loaded WebAssembly file is likely out of sync with the generated JavaScript.`
+  );
   return ASM_CONSTS[code](...args);
 };
 
@@ -3664,7 +4062,7 @@ var _emscripten_date_now = () => Date.now();
 
 var getHeapMax = () => 4294901760;
 
-var growMemory = size => {
+var growMemory = (size) => {
   var b = wasmMemory.buffer;
   var pages = (size - b.byteLength + 65535) / 65536;
   try {
@@ -3672,7 +4070,9 @@ var growMemory = size => {
     updateMemoryViews();
     return 1;
   } /*success*/ catch (e) {
-    err(`growMemory: Attempted to grow heap from ${b.byteLength} bytes to ${size} bytes, but got error: ${e}`);
+    err(
+      `growMemory: Attempted to grow heap from ${b.byteLength} bytes to ${size} bytes, but got error: ${e}`
+    );
   }
 };
 
@@ -3682,41 +4082,55 @@ function _emscripten_resize_heap(requestedSize) {
   assert(requestedSize > oldSize);
   var maxHeapSize = getHeapMax();
   if (requestedSize > maxHeapSize) {
-    err(`Cannot enlarge memory, requested ${requestedSize} bytes, but the limit is ${maxHeapSize} bytes!`);
+    err(
+      `Cannot enlarge memory, requested ${requestedSize} bytes, but the limit is ${maxHeapSize} bytes!`
+    );
     return false;
   }
-  var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
+  var alignUp = (x, multiple) => x + ((multiple - (x % multiple)) % multiple);
   for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
-    var overGrownHeapSize = oldSize * (1 + .2 / cutDown);
+    var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
     overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
-    var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
+    var newSize = Math.min(
+      maxHeapSize,
+      alignUp(Math.max(requestedSize, overGrownHeapSize), 65536)
+    );
     var replacement = growMemory(newSize);
     if (replacement) {
       return true;
     }
   }
-  err(`Failed to grow the heap from ${oldSize} bytes to ${newSize} bytes, not enough memory!`);
+  err(
+    `Failed to grow the heap from ${oldSize} bytes to ${newSize} bytes, not enough memory!`
+  );
   return false;
 }
 
 var ENV = {};
 
-var getExecutableName = () => thisProgram || "./this.program";
+var getExecutableName = () => thisProgram || './this.program';
 
 var getEnvStrings = () => {
   if (!getEnvStrings.strings) {
-    var lang = ((typeof navigator == "object" && navigator.languages && navigator.languages[0]) || "C").replace("-", "_") + ".UTF-8";
+    var lang =
+      (
+        (typeof navigator == 'object' &&
+          navigator.languages &&
+          navigator.languages[0]) ||
+        'C'
+      ).replace('-', '_') + '.UTF-8';
     var env = {
-      "USER": "web_user",
-      "LOGNAME": "web_user",
-      "PATH": "/",
-      "PWD": "/",
-      "HOME": "/home/web_user",
-      "LANG": lang,
-      "_": getExecutableName()
+      USER: 'web_user',
+      LOGNAME: 'web_user',
+      PATH: '/',
+      PWD: '/',
+      HOME: '/home/web_user',
+      LANG: lang,
+      _: getExecutableName(),
     };
     for (var x in ENV) {
-      if (ENV[x] === undefined) delete env[x]; else env[x] = ENV[x];
+      if (ENV[x] === undefined) delete env[x];
+      else env[x] = ENV[x];
     }
     var strings = [];
     for (var x in env) {
@@ -3735,27 +4149,27 @@ var stringToAscii = (str, buffer) => {
   HEAP8[buffer >>> 0] = 0;
 };
 
-var _environ_get = function(__environ, environ_buf) {
+var _environ_get = function (__environ, environ_buf) {
   __environ >>>= 0;
   environ_buf >>>= 0;
   var bufSize = 0;
   getEnvStrings().forEach((string, i) => {
     var ptr = environ_buf + bufSize;
-    HEAPU32[(((__environ) + (i * 4)) >>> 2) >>> 0] = ptr;
+    HEAPU32[((__environ + i * 4) >>> 2) >>> 0] = ptr;
     stringToAscii(string, ptr);
     bufSize += string.length + 1;
   });
   return 0;
 };
 
-var _environ_sizes_get = function(penviron_count, penviron_buf_size) {
+var _environ_sizes_get = function (penviron_count, penviron_buf_size) {
   penviron_count >>>= 0;
   penviron_buf_size >>>= 0;
   var strings = getEnvStrings();
-  HEAPU32[((penviron_count) >>> 2) >>> 0] = strings.length;
+  HEAPU32[(penviron_count >>> 2) >>> 0] = strings.length;
   var bufSize = 0;
-  strings.forEach(string => bufSize += string.length + 1);
-  HEAPU32[((penviron_buf_size) >>> 2) >>> 0] = bufSize;
+  strings.forEach((string) => (bufSize += string.length + 1));
+  HEAPU32[(penviron_buf_size >>> 2) >>> 0] = bufSize;
   return 0;
 };
 
@@ -3763,10 +4177,10 @@ var runtimeKeepaliveCounter = 0;
 
 var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
 
-var _proc_exit = code => {
+var _proc_exit = (code) => {
   EXITSTATUS = code;
   if (!keepRuntimeAlive()) {
-    Module["onExit"]?.(code);
+    Module['onExit']?.(code);
     ABORT = true;
   }
   quit_(code, new ExitStatus(code));
@@ -3790,7 +4204,7 @@ function _fd_close(fd) {
     FS.close(stream);
     return 0;
   } catch (e) {
-    if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
+    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
     return e.errno;
   }
 }
@@ -3798,14 +4212,14 @@ function _fd_close(fd) {
 /** @param {number=} offset */ var doReadv = (stream, iov, iovcnt, offset) => {
   var ret = 0;
   for (var i = 0; i < iovcnt; i++) {
-    var ptr = HEAPU32[((iov) >>> 2) >>> 0];
-    var len = HEAPU32[(((iov) + (4)) >>> 2) >>> 0];
+    var ptr = HEAPU32[(iov >>> 2) >>> 0];
+    var len = HEAPU32[((iov + 4) >>> 2) >>> 0];
     iov += 8;
     var curr = FS.read(stream, HEAP8, ptr, len, offset);
     if (curr < 0) return -1;
     ret += curr;
     if (curr < len) break;
-    if (typeof offset != "undefined") {
+    if (typeof offset != 'undefined') {
       offset += curr;
     }
   }
@@ -3819,10 +4233,10 @@ function _fd_read(fd, iov, iovcnt, pnum) {
   try {
     var stream = SYSCALLS.getStreamFromFD(fd);
     var num = doReadv(stream, iov, iovcnt);
-    HEAPU32[((pnum) >>> 2) >>> 0] = num;
+    HEAPU32[(pnum >>> 2) >>> 0] = num;
     return 0;
   } catch (e) {
-    if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
+    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
     return e.errno;
   }
 }
@@ -3834,12 +4248,22 @@ function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
     if (isNaN(offset)) return 61;
     var stream = SYSCALLS.getStreamFromFD(fd);
     FS.llseek(stream, offset, whence);
-    (tempI64 = [ stream.position >>> 0, (tempDouble = stream.position, (+(Math.abs(tempDouble))) >= 1 ? (tempDouble > 0 ? (+(Math.floor((tempDouble) / 4294967296))) >>> 0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble))) >>> 0)) / 4294967296))))) >>> 0) : 0) ], 
-    HEAP32[((newOffset) >>> 2) >>> 0] = tempI64[0], HEAP32[(((newOffset) + (4)) >>> 2) >>> 0] = tempI64[1]);
+    (tempI64 = [
+      stream.position >>> 0,
+      ((tempDouble = stream.position),
+      +Math.abs(tempDouble) >= 1
+        ? tempDouble > 0
+          ? +Math.floor(tempDouble / 4294967296) >>> 0
+          : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>>
+            0
+        : 0),
+    ]),
+      (HEAP32[(newOffset >>> 2) >>> 0] = tempI64[0]),
+      (HEAP32[((newOffset + 4) >>> 2) >>> 0] = tempI64[1]);
     if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;
     return 0;
   } catch (e) {
-    if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
+    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
     return e.errno;
   }
 }
@@ -3847,13 +4271,13 @@ function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
 /** @param {number=} offset */ var doWritev = (stream, iov, iovcnt, offset) => {
   var ret = 0;
   for (var i = 0; i < iovcnt; i++) {
-    var ptr = HEAPU32[((iov) >>> 2) >>> 0];
-    var len = HEAPU32[(((iov) + (4)) >>> 2) >>> 0];
+    var ptr = HEAPU32[(iov >>> 2) >>> 0];
+    var len = HEAPU32[((iov + 4) >>> 2) >>> 0];
     iov += 8;
     var curr = FS.write(stream, HEAP8, ptr, len, offset);
     if (curr < 0) return -1;
     ret += curr;
-    if (typeof offset != "undefined") {
+    if (typeof offset != 'undefined') {
       offset += curr;
     }
   }
@@ -3867,15 +4291,16 @@ function _fd_write(fd, iov, iovcnt, pnum) {
   try {
     var stream = SYSCALLS.getStreamFromFD(fd);
     var num = doWritev(stream, iov, iovcnt);
-    HEAPU32[((pnum) >>> 2) >>> 0] = num;
+    HEAPU32[(pnum >>> 2) >>> 0] = num;
     return 0;
   } catch (e) {
-    if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
+    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
     return e.errno;
   }
 }
 
-var isLeapYear = year => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
+var isLeapYear = (year) =>
+  year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
 
 var arraySum = (array, index) => {
   var sum = 0;
@@ -3883,18 +4308,20 @@ var arraySum = (array, index) => {
   return sum;
 };
 
-var MONTH_DAYS_LEAP = [ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];
+var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
 
-var MONTH_DAYS_REGULAR = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];
+var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
 
 var addDays = (date, days) => {
   var newDate = new Date(date.getTime());
   while (days > 0) {
     var leap = isLeapYear(newDate.getFullYear());
     var currentMonth = newDate.getMonth();
-    var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
+    var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[
+      currentMonth
+    ];
     if (days > daysInCurrentMonth - newDate.getDate()) {
-      days -= (daysInCurrentMonth - newDate.getDate() + 1);
+      days -= daysInCurrentMonth - newDate.getDate() + 1;
       newDate.setDate(1);
       if (currentMonth < 11) {
         newDate.setMonth(currentMonth + 1);
@@ -3911,7 +4338,10 @@ var addDays = (date, days) => {
 };
 
 var writeArrayToMemory = (array, buffer) => {
-  assert(array.length >= 0, "writeArrayToMemory array must have a length (should be an array or typed array)");
+  assert(
+    array.length >= 0,
+    'writeArrayToMemory array must have a length (should be an array or typed array)'
+  );
   HEAP8.set(array, buffer >>> 0);
 };
 
@@ -3920,69 +4350,90 @@ function _strftime(s, maxsize, format, tm) {
   maxsize >>>= 0;
   format >>>= 0;
   tm >>>= 0;
-  var tm_zone = HEAPU32[(((tm) + (40)) >>> 2) >>> 0];
+  var tm_zone = HEAPU32[((tm + 40) >>> 2) >>> 0];
   var date = {
-    tm_sec: HEAP32[((tm) >>> 2) >>> 0],
-    tm_min: HEAP32[(((tm) + (4)) >>> 2) >>> 0],
-    tm_hour: HEAP32[(((tm) + (8)) >>> 2) >>> 0],
-    tm_mday: HEAP32[(((tm) + (12)) >>> 2) >>> 0],
-    tm_mon: HEAP32[(((tm) + (16)) >>> 2) >>> 0],
-    tm_year: HEAP32[(((tm) + (20)) >>> 2) >>> 0],
-    tm_wday: HEAP32[(((tm) + (24)) >>> 2) >>> 0],
-    tm_yday: HEAP32[(((tm) + (28)) >>> 2) >>> 0],
-    tm_isdst: HEAP32[(((tm) + (32)) >>> 2) >>> 0],
-    tm_gmtoff: HEAP32[(((tm) + (36)) >>> 2) >>> 0],
-    tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""
+    tm_sec: HEAP32[(tm >>> 2) >>> 0],
+    tm_min: HEAP32[((tm + 4) >>> 2) >>> 0],
+    tm_hour: HEAP32[((tm + 8) >>> 2) >>> 0],
+    tm_mday: HEAP32[((tm + 12) >>> 2) >>> 0],
+    tm_mon: HEAP32[((tm + 16) >>> 2) >>> 0],
+    tm_year: HEAP32[((tm + 20) >>> 2) >>> 0],
+    tm_wday: HEAP32[((tm + 24) >>> 2) >>> 0],
+    tm_yday: HEAP32[((tm + 28) >>> 2) >>> 0],
+    tm_isdst: HEAP32[((tm + 32) >>> 2) >>> 0],
+    tm_gmtoff: HEAP32[((tm + 36) >>> 2) >>> 0],
+    tm_zone: tm_zone ? UTF8ToString(tm_zone) : '',
   };
   var pattern = UTF8ToString(format);
   var EXPANSION_RULES_1 = {
-    "%c": "%a %b %d %H:%M:%S %Y",
-    "%D": "%m/%d/%y",
-    "%F": "%Y-%m-%d",
-    "%h": "%b",
-    "%r": "%I:%M:%S %p",
-    "%R": "%H:%M",
-    "%T": "%H:%M:%S",
-    "%x": "%m/%d/%y",
-    "%X": "%H:%M:%S",
-    "%Ec": "%c",
-    "%EC": "%C",
-    "%Ex": "%m/%d/%y",
-    "%EX": "%H:%M:%S",
-    "%Ey": "%y",
-    "%EY": "%Y",
-    "%Od": "%d",
-    "%Oe": "%e",
-    "%OH": "%H",
-    "%OI": "%I",
-    "%Om": "%m",
-    "%OM": "%M",
-    "%OS": "%S",
-    "%Ou": "%u",
-    "%OU": "%U",
-    "%OV": "%V",
-    "%Ow": "%w",
-    "%OW": "%W",
-    "%Oy": "%y"
+    '%c': '%a %b %d %H:%M:%S %Y',
+    '%D': '%m/%d/%y',
+    '%F': '%Y-%m-%d',
+    '%h': '%b',
+    '%r': '%I:%M:%S %p',
+    '%R': '%H:%M',
+    '%T': '%H:%M:%S',
+    '%x': '%m/%d/%y',
+    '%X': '%H:%M:%S',
+    '%Ec': '%c',
+    '%EC': '%C',
+    '%Ex': '%m/%d/%y',
+    '%EX': '%H:%M:%S',
+    '%Ey': '%y',
+    '%EY': '%Y',
+    '%Od': '%d',
+    '%Oe': '%e',
+    '%OH': '%H',
+    '%OI': '%I',
+    '%Om': '%m',
+    '%OM': '%M',
+    '%OS': '%S',
+    '%Ou': '%u',
+    '%OU': '%U',
+    '%OV': '%V',
+    '%Ow': '%w',
+    '%OW': '%W',
+    '%Oy': '%y',
   };
   for (var rule in EXPANSION_RULES_1) {
-    pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
-  }
-  var WEEKDAYS = [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ];
-  var MONTHS = [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ];
+    pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_1[rule]);
+  }
+  var WEEKDAYS = [
+    'Sunday',
+    'Monday',
+    'Tuesday',
+    'Wednesday',
+    'Thursday',
+    'Friday',
+    'Saturday',
+  ];
+  var MONTHS = [
+    'January',
+    'February',
+    'March',
+    'April',
+    'May',
+    'June',
+    'July',
+    'August',
+    'September',
+    'October',
+    'November',
+    'December',
+  ];
   function leadingSomething(value, digits, character) {
-    var str = typeof value == "number" ? value.toString() : (value || "");
+    var str = typeof value == 'number' ? value.toString() : value || '';
     while (str.length < digits) {
       str = character[0] + str;
     }
     return str;
   }
   function leadingNulls(value, digits) {
-    return leadingSomething(value, digits, "0");
+    return leadingSomething(value, digits, '0');
   }
   function compareByDay(date1, date2) {
     function sgn(value) {
-      return value < 0 ? -1 : (value > 0 ? 1 : 0);
+      return value < 0 ? -1 : value > 0 ? 1 : 0;
     }
     var compare;
     if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
@@ -3994,26 +4445,26 @@ function _strftime(s, maxsize, format, tm) {
   }
   function getFirstWeekStartDate(janFourth) {
     switch (janFourth.getDay()) {
-     case 0:
-      return new Date(janFourth.getFullYear() - 1, 11, 29);
+      case 0:
+        return new Date(janFourth.getFullYear() - 1, 11, 29);
 
-     case 1:
-      return janFourth;
+      case 1:
+        return janFourth;
 
-     case 2:
-      return new Date(janFourth.getFullYear(), 0, 3);
+      case 2:
+        return new Date(janFourth.getFullYear(), 0, 3);
 
-     case 3:
-      return new Date(janFourth.getFullYear(), 0, 2);
+      case 3:
+        return new Date(janFourth.getFullYear(), 0, 2);
 
-     case 4:
-      return new Date(janFourth.getFullYear(), 0, 1);
+      case 4:
+        return new Date(janFourth.getFullYear(), 0, 1);
 
-     case 5:
-      return new Date(janFourth.getFullYear() - 1, 11, 31);
+      case 5:
+        return new Date(janFourth.getFullYear() - 1, 11, 31);
 
-     case 6:
-      return new Date(janFourth.getFullYear() - 1, 11, 30);
+      case 6:
+        return new Date(janFourth.getFullYear() - 1, 11, 30);
     }
   }
   function getWeekBasedYear(date) {
@@ -4031,50 +4482,64 @@ function _strftime(s, maxsize, format, tm) {
     return thisDate.getFullYear() - 1;
   }
   var EXPANSION_RULES_2 = {
-    "%a": date => WEEKDAYS[date.tm_wday].substring(0, 3),
-    "%A": date => WEEKDAYS[date.tm_wday],
-    "%b": date => MONTHS[date.tm_mon].substring(0, 3),
-    "%B": date => MONTHS[date.tm_mon],
-    "%C": date => {
+    '%a': (date) => WEEKDAYS[date.tm_wday].substring(0, 3),
+    '%A': (date) => WEEKDAYS[date.tm_wday],
+    '%b': (date) => MONTHS[date.tm_mon].substring(0, 3),
+    '%B': (date) => MONTHS[date.tm_mon],
+    '%C': (date) => {
       var year = date.tm_year + 1900;
       return leadingNulls((year / 100) | 0, 2);
     },
-    "%d": date => leadingNulls(date.tm_mday, 2),
-    "%e": date => leadingSomething(date.tm_mday, 2, " "),
-    "%g": date => getWeekBasedYear(date).toString().substring(2),
-    "%G": getWeekBasedYear,
-    "%H": date => leadingNulls(date.tm_hour, 2),
-    "%I": date => {
+    '%d': (date) => leadingNulls(date.tm_mday, 2),
+    '%e': (date) => leadingSomething(date.tm_mday, 2, ' '),
+    '%g': (date) => getWeekBasedYear(date).toString().substring(2),
+    '%G': getWeekBasedYear,
+    '%H': (date) => leadingNulls(date.tm_hour, 2),
+    '%I': (date) => {
       var twelveHour = date.tm_hour;
-      if (twelveHour == 0) twelveHour = 12; else if (twelveHour > 12) twelveHour -= 12;
+      if (twelveHour == 0) twelveHour = 12;
+      else if (twelveHour > 12) twelveHour -= 12;
       return leadingNulls(twelveHour, 2);
     },
-    "%j": date => leadingNulls(date.tm_mday + arraySum(isLeapYear(date.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date.tm_mon - 1), 3),
-    "%m": date => leadingNulls(date.tm_mon + 1, 2),
-    "%M": date => leadingNulls(date.tm_min, 2),
-    "%n": () => "\n",
-    "%p": date => {
+    '%j': (date) =>
+      leadingNulls(
+        date.tm_mday +
+          arraySum(
+            isLeapYear(date.tm_year + 1900)
+              ? MONTH_DAYS_LEAP
+              : MONTH_DAYS_REGULAR,
+            date.tm_mon - 1
+          ),
+        3
+      ),
+    '%m': (date) => leadingNulls(date.tm_mon + 1, 2),
+    '%M': (date) => leadingNulls(date.tm_min, 2),
+    '%n': () => '\n',
+    '%p': (date) => {
       if (date.tm_hour >= 0 && date.tm_hour < 12) {
-        return "AM";
+        return 'AM';
       }
-      return "PM";
+      return 'PM';
     },
-    "%S": date => leadingNulls(date.tm_sec, 2),
-    "%t": () => "\t",
-    "%u": date => date.tm_wday || 7,
-    "%U": date => {
+    '%S': (date) => leadingNulls(date.tm_sec, 2),
+    '%t': () => '\t',
+    '%u': (date) => date.tm_wday || 7,
+    '%U': (date) => {
       var days = date.tm_yday + 7 - date.tm_wday;
       return leadingNulls(Math.floor(days / 7), 2);
     },
-    "%V": date => {
-      var val = Math.floor((date.tm_yday + 7 - (date.tm_wday + 6) % 7) / 7);
+    '%V': (date) => {
+      var val = Math.floor((date.tm_yday + 7 - ((date.tm_wday + 6) % 7)) / 7);
       if ((date.tm_wday + 371 - date.tm_yday - 2) % 7 <= 2) {
         val++;
       }
       if (!val) {
         val = 52;
         var dec31 = (date.tm_wday + 7 - date.tm_yday - 1) % 7;
-        if (dec31 == 4 || (dec31 == 5 && isLeapYear(date.tm_year % 400 - 1))) {
+        if (
+          dec31 == 4 ||
+          (dec31 == 5 && isLeapYear((date.tm_year % 400) - 1))
+        ) {
           val++;
         }
       } else if (val == 53) {
@@ -4083,30 +4548,33 @@ function _strftime(s, maxsize, format, tm) {
       }
       return leadingNulls(val, 2);
     },
-    "%w": date => date.tm_wday,
-    "%W": date => {
+    '%w': (date) => date.tm_wday,
+    '%W': (date) => {
       var days = date.tm_yday + 7 - ((date.tm_wday + 6) % 7);
       return leadingNulls(Math.floor(days / 7), 2);
     },
-    "%y": date => (date.tm_year + 1900).toString().substring(2),
-    "%Y": date => date.tm_year + 1900,
-    "%z": date => {
+    '%y': (date) => (date.tm_year + 1900).toString().substring(2),
+    '%Y': (date) => date.tm_year + 1900,
+    '%z': (date) => {
       var off = date.tm_gmtoff;
       var ahead = off >= 0;
       off = Math.abs(off) / 60;
       off = (off / 60) * 100 + (off % 60);
-      return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
+      return (ahead ? '+' : '-') + String('0000' + off).slice(-4);
     },
-    "%Z": date => date.tm_zone,
-    "%%": () => "%"
+    '%Z': (date) => date.tm_zone,
+    '%%': () => '%',
   };
-  pattern = pattern.replace(/%%/g, "\0\0");
+  pattern = pattern.replace(/%%/g, '\0\0');
   for (var rule in EXPANSION_RULES_2) {
     if (pattern.includes(rule)) {
-      pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
+      pattern = pattern.replace(
+        new RegExp(rule, 'g'),
+        EXPANSION_RULES_2[rule](date)
+      );
     }
   }
-  pattern = pattern.replace(/\0\0/g, "%");
+  pattern = pattern.replace(/\0\0/g, '%');
   var bytes = intArrayFromString(pattern, false);
   if (bytes.length > maxsize) {
     return 0;
@@ -4119,25 +4587,31 @@ var wasmTableMirror = [];
 
 /** @type {WebAssembly.Table} */ var wasmTable;
 
-var getWasmTableEntry = funcPtr => {
+var getWasmTableEntry = (funcPtr) => {
   var func = wasmTableMirror[funcPtr];
   if (!func) {
     if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;
     wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
   }
-  assert(wasmTable.get(funcPtr) == func, "JavaScript-side Wasm function table mirror is out of date!");
+  assert(
+    wasmTable.get(funcPtr) == func,
+    'JavaScript-side Wasm function table mirror is out of date!'
+  );
   return func;
 };
 
-var getCFunc = ident => {
-  var func = Module["_" + ident];
-  assert(func, "Cannot call unknown function " + ident + ", make sure it is exported");
+var getCFunc = (ident) => {
+  var func = Module['_' + ident];
+  assert(
+    func,
+    'Cannot call unknown function ' + ident + ', make sure it is exported'
+  );
   return func;
 };
 
-var stackAlloc = sz => __emscripten_stack_alloc(sz);
+var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
 
-var stringToUTF8OnStack = str => {
+var stringToUTF8OnStack = (str) => {
   var size = lengthBytesUTF8(str) + 1;
   var ret = stackAlloc(size);
   stringToUTF8(str, ret, size);
@@ -4145,36 +4619,36 @@ var stringToUTF8OnStack = str => {
 };
 
 /**
-     * @param {string|null=} returnType
-     * @param {Array=} argTypes
-     * @param {Arguments|Array=} args
-     * @param {Object=} opts
-     */ var ccall = (ident, returnType, argTypes, args, opts) => {
+ * @param {string|null=} returnType
+ * @param {Array=} argTypes
+ * @param {Arguments|Array=} args
+ * @param {Object=} opts
+ */ var ccall = (ident, returnType, argTypes, args, opts) => {
   var toC = {
-    "string": str => {
+    string: (str) => {
       var ret = 0;
       if (str !== null && str !== undefined && str !== 0) {
         ret = stringToUTF8OnStack(str);
       }
       return ret;
     },
-    "array": arr => {
+    array: (arr) => {
       var ret = stackAlloc(arr.length);
       writeArrayToMemory(arr, ret);
       return ret;
-    }
+    },
   };
   function convertReturnValue(ret) {
-    if (returnType === "string") {
+    if (returnType === 'string') {
       return UTF8ToString(ret);
     }
-    if (returnType === "boolean") return Boolean(ret);
+    if (returnType === 'boolean') return Boolean(ret);
     return ret;
   }
   var func = getCFunc(ident);
   var cArgs = [];
   var stack = 0;
-  assert(returnType !== "array", 'Return type should not be "array".');
+  assert(returnType !== 'array', 'Return type should not be "array".');
   if (args) {
     for (var i = 0; i < args.length; i++) {
       var converter = toC[argTypes[i]];
@@ -4196,14 +4670,17 @@ var stringToUTF8OnStack = str => {
 };
 
 /**
-     * @param {string=} returnType
-     * @param {Array=} argTypes
-     * @param {Object=} opts
-     */ var cwrap = (ident, returnType, argTypes, opts) => (...args) => ccall(ident, returnType, argTypes, args, opts);
+ * @param {string=} returnType
+ * @param {Array=} argTypes
+ * @param {Object=} opts
+ */ var cwrap =
+  (ident, returnType, argTypes, opts) =>
+  (...args) =>
+    ccall(ident, returnType, argTypes, args, opts);
 
 var FS_createPath = FS.createPath;
 
-var FS_unlink = path => FS.unlink(path);
+var FS_unlink = (path) => FS.unlink(path);
 
 var FS_createLazyFile = FS.createLazyFile;
 
@@ -4213,20 +4690,20 @@ FS.createPreloadedFile = FS_createPreloadedFile;
 
 FS.staticInit();
 
-Module["FS_createPath"] = FS.createPath;
+Module['FS_createPath'] = FS.createPath;
 
-Module["FS_createDataFile"] = FS.createDataFile;
+Module['FS_createDataFile'] = FS.createDataFile;
 
-Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
+Module['FS_createPreloadedFile'] = FS.createPreloadedFile;
 
-Module["FS_unlink"] = FS.unlink;
+Module['FS_unlink'] = FS.unlink;
 
-Module["FS_createLazyFile"] = FS.createLazyFile;
+Module['FS_createLazyFile'] = FS.createLazyFile;
 
-Module["FS_createDevice"] = FS.createDevice;
+Module['FS_createDevice'] = FS.createDevice;
 
 function checkIncomingModuleAPI() {
-  ignoredModuleProp("fetchSettings");
+  ignoredModuleProp('fetchSettings');
 }
 
 var wasmImports = {
@@ -4334,138 +4811,274 @@ var wasmImports = {
   /** @export */ invoke_viij: invoke_viij,
   /** @export */ invoke_viiji: invoke_viiji,
   /** @export */ invoke_vij: invoke_vij,
-  /** @export */ strftime: _strftime
+  /** @export */ strftime: _strftime,
 };
 
 var wasmExports = createWasm();
 
-var ___wasm_call_ctors = createExportWrapper("__wasm_call_ctors", 0);
-
-var _initContext = Module["_initContext"] = createExportWrapper("initContext", 0);
-
-var _openDocumentFromBuffer = Module["_openDocumentFromBuffer"] = createExportWrapper("openDocumentFromBuffer", 3);
+var ___wasm_call_ctors = createExportWrapper('__wasm_call_ctors', 0);
 
-var _writeDocument = Module["_writeDocument"] = createExportWrapper("writeDocument", 0);
+var _initContext = (Module['_initContext'] = createExportWrapper(
+  'initContext',
+  0
+));
 
-var _freeDocument = Module["_freeDocument"] = createExportWrapper("freeDocument", 1);
+var _openDocumentFromBuffer = (Module['_openDocumentFromBuffer'] =
+  createExportWrapper('openDocumentFromBuffer', 3));
 
-var _countPages = Module["_countPages"] = createExportWrapper("countPages", 1);
+var _writeDocument = (Module['_writeDocument'] = createExportWrapper(
+  'writeDocument',
+  0
+));
 
-var _checkNativeText = Module["_checkNativeText"] = createExportWrapper("checkNativeText", 2);
+var _freeDocument = (Module['_freeDocument'] = createExportWrapper(
+  'freeDocument',
+  1
+));
 
-var _pdfOverlayDocuments = Module["_pdfOverlayDocuments"] = createExportWrapper("pdfOverlayDocuments", 2);
+var _countPages = (Module['_countPages'] = createExportWrapper(
+  'countPages',
+  1
+));
 
-var _pageText = Module["_pageText"] = createExportWrapper("pageText", 7);
+var _checkNativeText = (Module['_checkNativeText'] = createExportWrapper(
+  'checkNativeText',
+  2
+));
 
-var _doDrawPageAsPNG = Module["_doDrawPageAsPNG"] = createExportWrapper("doDrawPageAsPNG", 4);
+var _pdfOverlayDocuments = (Module['_pdfOverlayDocuments'] =
+  createExportWrapper('pdfOverlayDocuments', 2));
 
-var _doDrawPageAsPNGGray = Module["_doDrawPageAsPNGGray"] = createExportWrapper("doDrawPageAsPNGGray", 4);
+var _pageText = (Module['_pageText'] = createExportWrapper('pageText', 7));
 
-var _convertImageStart = Module["_convertImageStart"] = createExportWrapper("convertImageStart", 1);
+var _doDrawPageAsPNG = (Module['_doDrawPageAsPNG'] = createExportWrapper(
+  'doDrawPageAsPNG',
+  4
+));
 
-var _convertImageAddPage = Module["_convertImageAddPage"] = createExportWrapper("convertImageAddPage", 4);
+var _doDrawPageAsPNGGray = (Module['_doDrawPageAsPNGGray'] =
+  createExportWrapper('doDrawPageAsPNGGray', 4));
 
-var _convertImageEnd = Module["_convertImageEnd"] = createExportWrapper("convertImageEnd", 0);
+var _convertImageStart = (Module['_convertImageStart'] = createExportWrapper(
+  'convertImageStart',
+  1
+));
 
-var _runPDF = Module["_runPDF"] = createExportWrapper("runPDF", 6);
+var _convertImageAddPage = (Module['_convertImageAddPage'] =
+  createExportWrapper('convertImageAddPage', 4));
 
-var _pdfSubsetPages = Module["_pdfSubsetPages"] = createExportWrapper("pdfSubsetPages", 3);
+var _convertImageEnd = (Module['_convertImageEnd'] = createExportWrapper(
+  'convertImageEnd',
+  0
+));
 
-var _pdfSaveDocument = Module["_pdfSaveDocument"] = createExportWrapper("pdfSaveDocument", 8);
+var _runPDF = (Module['_runPDF'] = createExportWrapper('runPDF', 6));
 
-var _getLastDrawData = Module["_getLastDrawData"] = createExportWrapper("getLastDrawData", 0);
+var _pdfSubsetPages = (Module['_pdfSubsetPages'] = createExportWrapper(
+  'pdfSubsetPages',
+  3
+));
 
-var _getLastDrawSize = Module["_getLastDrawSize"] = createExportWrapper("getLastDrawSize", 0);
+var _pdfSaveDocument = (Module['_pdfSaveDocument'] = createExportWrapper(
+  'pdfSaveDocument',
+  8
+));
 
-var _pageWidth = Module["_pageWidth"] = createExportWrapper("pageWidth", 3);
+var _getLastDrawData = (Module['_getLastDrawData'] = createExportWrapper(
+  'getLastDrawData',
+  0
+));
 
-var _pageHeight = Module["_pageHeight"] = createExportWrapper("pageHeight", 3);
+var _getLastDrawSize = (Module['_getLastDrawSize'] = createExportWrapper(
+  'getLastDrawSize',
+  0
+));
 
-var _pageLinks = Module["_pageLinks"] = createExportWrapper("pageLinks", 3);
+var _pageWidth = (Module['_pageWidth'] = createExportWrapper('pageWidth', 3));
 
-var _search = Module["_search"] = createExportWrapper("search", 4);
+var _pageHeight = (Module['_pageHeight'] = createExportWrapper(
+  'pageHeight',
+  3
+));
 
-var _documentTitle = Module["_documentTitle"] = createExportWrapper("documentTitle", 1);
+var _pageLinks = (Module['_pageLinks'] = createExportWrapper('pageLinks', 3));
 
-var _loadOutline = Module["_loadOutline"] = createExportWrapper("loadOutline", 1);
+var _search = (Module['_search'] = createExportWrapper('search', 4));
 
-var _freeOutline = Module["_freeOutline"] = createExportWrapper("freeOutline", 1);
+var _documentTitle = (Module['_documentTitle'] = createExportWrapper(
+  'documentTitle',
+  1
+));
 
-var _outlineTitle = Module["_outlineTitle"] = createExportWrapper("outlineTitle", 1);
+var _loadOutline = (Module['_loadOutline'] = createExportWrapper(
+  'loadOutline',
+  1
+));
 
-var _outlinePage = Module["_outlinePage"] = createExportWrapper("outlinePage", 2);
+var _freeOutline = (Module['_freeOutline'] = createExportWrapper(
+  'freeOutline',
+  1
+));
 
-var _outlineDown = Module["_outlineDown"] = createExportWrapper("outlineDown", 1);
+var _outlineTitle = (Module['_outlineTitle'] = createExportWrapper(
+  'outlineTitle',
+  1
+));
 
-var _outlineNext = Module["_outlineNext"] = createExportWrapper("outlineNext", 1);
+var _outlinePage = (Module['_outlinePage'] = createExportWrapper(
+  'outlinePage',
+  2
+));
 
-var _extractAllFonts = Module["_extractAllFonts"] = createExportWrapper("extractAllFonts", 1);
+var _outlineDown = (Module['_outlineDown'] = createExportWrapper(
+  'outlineDown',
+  1
+));
 
-var _malloc = Module["_malloc"] = createExportWrapper("malloc", 1);
+var _outlineNext = (Module['_outlineNext'] = createExportWrapper(
+  'outlineNext',
+  1
+));
 
-var _free = Module["_free"] = createExportWrapper("free", 1);
+var _extractAllFonts = (Module['_extractAllFonts'] = createExportWrapper(
+  'extractAllFonts',
+  1
+));
 
-var _fflush = createExportWrapper("fflush", 1);
+var _malloc = (Module['_malloc'] = createExportWrapper('malloc', 1));
 
-var _setThrew = createExportWrapper("setThrew", 2);
+var _free = (Module['_free'] = createExportWrapper('free', 1));
 
-var __emscripten_tempret_set = createExportWrapper("_emscripten_tempret_set", 1);
+var _fflush = createExportWrapper('fflush', 1);
 
-var _emscripten_stack_init = () => (_emscripten_stack_init = wasmExports["emscripten_stack_init"])();
+var _setThrew = createExportWrapper('setThrew', 2);
+
+var __emscripten_tempret_set = createExportWrapper(
+  '_emscripten_tempret_set',
+  1
+);
+
+var _emscripten_stack_init = () =>
+  (_emscripten_stack_init = wasmExports['emscripten_stack_init'])();
+
+var _emscripten_stack_get_free = () =>
+  (_emscripten_stack_get_free = wasmExports['emscripten_stack_get_free'])();
+
+var _emscripten_stack_get_base = () =>
+  (_emscripten_stack_get_base = wasmExports['emscripten_stack_get_base'])();
+
+var _emscripten_stack_get_end = () =>
+  (_emscripten_stack_get_end = wasmExports['emscripten_stack_get_end'])();
+
+var __emscripten_stack_restore = (a0) =>
+  (__emscripten_stack_restore = wasmExports['_emscripten_stack_restore'])(a0);
+
+var __emscripten_stack_alloc = (a0) =>
+  (__emscripten_stack_alloc = wasmExports['_emscripten_stack_alloc'])(a0);
+
+var _emscripten_stack_get_current = () =>
+  (_emscripten_stack_get_current =
+    wasmExports['emscripten_stack_get_current'])();
+
+var dynCall_ji = (Module['dynCall_ji'] = createExportWrapper('dynCall_ji', 2));
+
+var dynCall_viiji = (Module['dynCall_viiji'] = createExportWrapper(
+  'dynCall_viiji',
+  6
+));
+
+var dynCall_viiijjiijjjjiiiiiiii = (Module['dynCall_viiijjiijjjjiiiiiiii'] =
+  createExportWrapper('dynCall_viiijjiijjjjiiiiiiii', 26));
+
+var dynCall_jji = (Module['dynCall_jji'] = createExportWrapper(
+  'dynCall_jji',
+  4
+));
+
+var dynCall_iji = (Module['dynCall_iji'] = createExportWrapper(
+  'dynCall_iji',
+  4
+));
+
+var dynCall_vij = (Module['dynCall_vij'] = createExportWrapper(
+  'dynCall_vij',
+  4
+));
+
+var dynCall_jii = (Module['dynCall_jii'] = createExportWrapper(
+  'dynCall_jii',
+  3
+));
+
+var dynCall_viij = (Module['dynCall_viij'] = createExportWrapper(
+  'dynCall_viij',
+  5
+));
+
+var dynCall_viiij = (Module['dynCall_viiij'] = createExportWrapper(
+  'dynCall_viiij',
+  6
+));
+
+var dynCall_iij = (Module['dynCall_iij'] = createExportWrapper(
+  'dynCall_iij',
+  4
+));
+
+var dynCall_jiii = (Module['dynCall_jiii'] = createExportWrapper(
+  'dynCall_jiii',
+  4
+));
 
-var _emscripten_stack_get_free = () => (_emscripten_stack_get_free = wasmExports["emscripten_stack_get_free"])();
+var dynCall_iiijj = (Module['dynCall_iiijj'] = createExportWrapper(
+  'dynCall_iiijj',
+  7
+));
 
-var _emscripten_stack_get_base = () => (_emscripten_stack_get_base = wasmExports["emscripten_stack_get_base"])();
+var dynCall_iiiiiiiij = (Module['dynCall_iiiiiiiij'] = createExportWrapper(
+  'dynCall_iiiiiiiij',
+  10
+));
 
-var _emscripten_stack_get_end = () => (_emscripten_stack_get_end = wasmExports["emscripten_stack_get_end"])();
+var dynCall_iiiiiijii = (Module['dynCall_iiiiiijii'] = createExportWrapper(
+  'dynCall_iiiiiijii',
+  10
+));
 
-var __emscripten_stack_restore = a0 => (__emscripten_stack_restore = wasmExports["_emscripten_stack_restore"])(a0);
-
-var __emscripten_stack_alloc = a0 => (__emscripten_stack_alloc = wasmExports["_emscripten_stack_alloc"])(a0);
-
-var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["emscripten_stack_get_current"])();
-
-var dynCall_ji = Module["dynCall_ji"] = createExportWrapper("dynCall_ji", 2);
-
-var dynCall_viiji = Module["dynCall_viiji"] = createExportWrapper("dynCall_viiji", 6);
-
-var dynCall_viiijjiijjjjiiiiiiii = Module["dynCall_viiijjiijjjjiiiiiiii"] = createExportWrapper("dynCall_viiijjiijjjjiiiiiiii", 26);
-
-var dynCall_jji = Module["dynCall_jji"] = createExportWrapper("dynCall_jji", 4);
-
-var dynCall_iji = Module["dynCall_iji"] = createExportWrapper("dynCall_iji", 4);
-
-var dynCall_vij = Module["dynCall_vij"] = createExportWrapper("dynCall_vij", 4);
-
-var dynCall_jii = Module["dynCall_jii"] = createExportWrapper("dynCall_jii", 3);
-
-var dynCall_viij = Module["dynCall_viij"] = createExportWrapper("dynCall_viij", 5);
-
-var dynCall_viiij = Module["dynCall_viiij"] = createExportWrapper("dynCall_viiij", 6);
-
-var dynCall_iij = Module["dynCall_iij"] = createExportWrapper("dynCall_iij", 4);
-
-var dynCall_jiii = Module["dynCall_jiii"] = createExportWrapper("dynCall_jiii", 4);
-
-var dynCall_iiijj = Module["dynCall_iiijj"] = createExportWrapper("dynCall_iiijj", 7);
-
-var dynCall_iiiiiiiij = Module["dynCall_iiiiiiiij"] = createExportWrapper("dynCall_iiiiiiiij", 10);
-
-var dynCall_iiiiiijii = Module["dynCall_iiiiiijii"] = createExportWrapper("dynCall_iiiiiijii", 10);
-
-var dynCall_viiiij = Module["dynCall_viiiij"] = createExportWrapper("dynCall_viiiij", 7);
-
-var dynCall_viiiiiijj = Module["dynCall_viiiiiijj"] = createExportWrapper("dynCall_viiiiiijj", 11);
-
-var dynCall_jiij = Module["dynCall_jiij"] = createExportWrapper("dynCall_jiij", 5);
-
-var dynCall_iiij = Module["dynCall_iiij"] = createExportWrapper("dynCall_iiij", 5);
-
-var dynCall_iiiiij = Module["dynCall_iiiiij"] = createExportWrapper("dynCall_iiiiij", 7);
-
-var dynCall_iiji = Module["dynCall_iiji"] = createExportWrapper("dynCall_iiji", 5);
-
-var dynCall_jiji = Module["dynCall_jiji"] = createExportWrapper("dynCall_jiji", 5);
+var dynCall_viiiij = (Module['dynCall_viiiij'] = createExportWrapper(
+  'dynCall_viiiij',
+  7
+));
+
+var dynCall_viiiiiijj = (Module['dynCall_viiiiiijj'] = createExportWrapper(
+  'dynCall_viiiiiijj',
+  11
+));
+
+var dynCall_jiij = (Module['dynCall_jiij'] = createExportWrapper(
+  'dynCall_jiij',
+  5
+));
+
+var dynCall_iiij = (Module['dynCall_iiij'] = createExportWrapper(
+  'dynCall_iiij',
+  5
+));
+
+var dynCall_iiiiij = (Module['dynCall_iiiiij'] = createExportWrapper(
+  'dynCall_iiiiij',
+  7
+));
+
+var dynCall_iiji = (Module['dynCall_iiji'] = createExportWrapper(
+  'dynCall_iiji',
+  5
+));
+
+var dynCall_jiji = (Module['dynCall_jiji'] = createExportWrapper(
+  'dynCall_jiji',
+  5
+));
 
 function invoke_vi(index, a1) {
   var sp = stackSave();
@@ -4808,10 +5421,35 @@ function invoke_fi(index, a1) {
   }
 }
 
-function invoke_iiiffiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
+function invoke_iiiffiiiiiii(
+  index,
+  a1,
+  a2,
+  a3,
+  a4,
+  a5,
+  a6,
+  a7,
+  a8,
+  a9,
+  a10,
+  a11
+) {
   var sp = stackSave();
   try {
-    return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
+    return getWasmTableEntry(index)(
+      a1,
+      a2,
+      a3,
+      a4,
+      a5,
+      a6,
+      a7,
+      a8,
+      a9,
+      a10,
+      a11
+    );
   } catch (e) {
     stackRestore(sp);
     if (e !== e + 0) throw e;
@@ -4852,10 +5490,45 @@ function invoke_v(index) {
   }
 }
 
-function invoke_iiiiiiiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) {
+function invoke_iiiiiiiiiiiiiiiii(
+  index,
+  a1,
+  a2,
+  a3,
+  a4,
+  a5,
+  a6,
+  a7,
+  a8,
+  a9,
+  a10,
+  a11,
+  a12,
+  a13,
+  a14,
+  a15,
+  a16
+) {
   var sp = stackSave();
   try {
-    return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
+    return getWasmTableEntry(index)(
+      a1,
+      a2,
+      a3,
+      a4,
+      a5,
+      a6,
+      a7,
+      a8,
+      a9,
+      a10,
+      a11,
+      a12,
+      a13,
+      a14,
+      a15,
+      a16
+    );
   } catch (e) {
     stackRestore(sp);
     if (e !== e + 0) throw e;
@@ -4874,10 +5547,39 @@ function invoke_iiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
   }
 }
 
-function invoke_iiiiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) {
+function invoke_iiiiiiiiiiiiii(
+  index,
+  a1,
+  a2,
+  a3,
+  a4,
+  a5,
+  a6,
+  a7,
+  a8,
+  a9,
+  a10,
+  a11,
+  a12,
+  a13
+) {
   var sp = stackSave();
   try {
-    return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
+    return getWasmTableEntry(index)(
+      a1,
+      a2,
+      a3,
+      a4,
+      a5,
+      a6,
+      a7,
+      a8,
+      a9,
+      a10,
+      a11,
+      a12,
+      a13
+    );
   } catch (e) {
     stackRestore(sp);
     if (e !== e + 0) throw e;
@@ -4896,7 +5598,20 @@ function invoke_fii(index, a1, a2) {
   }
 }
 
-function invoke_viiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
+function invoke_viiiiiiiiiii(
+  index,
+  a1,
+  a2,
+  a3,
+  a4,
+  a5,
+  a6,
+  a7,
+  a8,
+  a9,
+  a10,
+  a11
+) {
   var sp = stackSave();
   try {
     getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
@@ -5072,10 +5787,51 @@ function invoke_viiffff(index, a1, a2, a3, a4, a5, a6) {
   }
 }
 
-function invoke_viiiiiiifiiifffffiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19) {
+function invoke_viiiiiiifiiifffffiii(
+  index,
+  a1,
+  a2,
+  a3,
+  a4,
+  a5,
+  a6,
+  a7,
+  a8,
+  a9,
+  a10,
+  a11,
+  a12,
+  a13,
+  a14,
+  a15,
+  a16,
+  a17,
+  a18,
+  a19
+) {
   var sp = stackSave();
   try {
-    getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
+    getWasmTableEntry(index)(
+      a1,
+      a2,
+      a3,
+      a4,
+      a5,
+      a6,
+      a7,
+      a8,
+      a9,
+      a10,
+      a11,
+      a12,
+      a13,
+      a14,
+      a15,
+      a16,
+      a17,
+      a18,
+      a19
+    );
   } catch (e) {
     stackRestore(sp);
     if (e !== e + 0) throw e;
@@ -5083,7 +5839,20 @@ function invoke_viiiiiiifiiifffffiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9,
   }
 }
 
-function invoke_viiifffffiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
+function invoke_viiifffffiii(
+  index,
+  a1,
+  a2,
+  a3,
+  a4,
+  a5,
+  a6,
+  a7,
+  a8,
+  a9,
+  a10,
+  a11
+) {
   var sp = stackSave();
   try {
     getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
@@ -5094,10 +5863,37 @@ function invoke_viiifffffiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11
   }
 }
 
-function invoke_iiiiiffiifiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
+function invoke_iiiiiffiifiii(
+  index,
+  a1,
+  a2,
+  a3,
+  a4,
+  a5,
+  a6,
+  a7,
+  a8,
+  a9,
+  a10,
+  a11,
+  a12
+) {
   var sp = stackSave();
   try {
-    return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
+    return getWasmTableEntry(index)(
+      a1,
+      a2,
+      a3,
+      a4,
+      a5,
+      a6,
+      a7,
+      a8,
+      a9,
+      a10,
+      a11,
+      a12
+    );
   } catch (e) {
     stackRestore(sp);
     if (e !== e + 0) throw e;
@@ -5138,10 +5934,35 @@ function invoke_viiiiff(index, a1, a2, a3, a4, a5, a6) {
   }
 }
 
-function invoke_iiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
+function invoke_iiiiiiiiiiii(
+  index,
+  a1,
+  a2,
+  a3,
+  a4,
+  a5,
+  a6,
+  a7,
+  a8,
+  a9,
+  a10,
+  a11
+) {
   var sp = stackSave();
   try {
-    return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
+    return getWasmTableEntry(index)(
+      a1,
+      a2,
+      a3,
+      a4,
+      a5,
+      a6,
+      a7,
+      a8,
+      a9,
+      a10,
+      a11
+    );
   } catch (e) {
     stackRestore(sp);
     if (e !== e + 0) throw e;
@@ -5382,45 +6203,318 @@ function invoke_iiiiij(index, a1, a2, a3, a4, a5, a6) {
 
 function applySignatureConversions(wasmExports) {
   wasmExports = Object.assign({}, wasmExports);
-  var makeWrapper_pp = f => a0 => f(a0) >>> 0;
-  var makeWrapper_p = f => () => f() >>> 0;
-  wasmExports["malloc"] = makeWrapper_pp(wasmExports["malloc"]);
-  wasmExports["emscripten_stack_get_base"] = makeWrapper_p(wasmExports["emscripten_stack_get_base"]);
-  wasmExports["emscripten_stack_get_end"] = makeWrapper_p(wasmExports["emscripten_stack_get_end"]);
-  wasmExports["_emscripten_stack_alloc"] = makeWrapper_pp(wasmExports["_emscripten_stack_alloc"]);
-  wasmExports["emscripten_stack_get_current"] = makeWrapper_p(wasmExports["emscripten_stack_get_current"]);
+  var makeWrapper_pp = (f) => (a0) => f(a0) >>> 0;
+  var makeWrapper_p = (f) => () => f() >>> 0;
+  wasmExports['malloc'] = makeWrapper_pp(wasmExports['malloc']);
+  wasmExports['emscripten_stack_get_base'] = makeWrapper_p(
+    wasmExports['emscripten_stack_get_base']
+  );
+  wasmExports['emscripten_stack_get_end'] = makeWrapper_p(
+    wasmExports['emscripten_stack_get_end']
+  );
+  wasmExports['_emscripten_stack_alloc'] = makeWrapper_pp(
+    wasmExports['_emscripten_stack_alloc']
+  );
+  wasmExports['emscripten_stack_get_current'] = makeWrapper_p(
+    wasmExports['emscripten_stack_get_current']
+  );
   return wasmExports;
 }
 
-Module["addRunDependency"] = addRunDependency;
-
-Module["removeRunDependency"] = removeRunDependency;
-
-Module["ccall"] = ccall;
-
-Module["cwrap"] = cwrap;
-
-Module["getValue"] = getValue;
-
-Module["UTF8ToString"] = UTF8ToString;
-
-Module["FS_createPreloadedFile"] = FS_createPreloadedFile;
-
-Module["FS_unlink"] = FS_unlink;
-
-Module["FS_createPath"] = FS_createPath;
-
-Module["FS_createDevice"] = FS_createDevice;
-
-Module["FS_createDataFile"] = FS_createDataFile;
-
-Module["FS_createLazyFile"] = FS_createLazyFile;
-
-var missingLibrarySymbols = [ "writeI53ToI64", "writeI53ToI64Clamped", "writeI53ToI64Signaling", "writeI53ToU64Clamped", "writeI53ToU64Signaling", "readI53FromI64", "readI53FromU64", "convertI32PairToI53", "convertU32PairToI53", "getTempRet0", "ydayFromDate", "inetPton4", "inetNtop4", "inetPton6", "inetNtop6", "readSockaddr", "writeSockaddr", "emscriptenLog", "runMainThreadEmAsm", "jstoi_q", "listenOnce", "autoResumeAudioContext", "dynCallLegacy", "getDynCaller", "dynCall", "handleException", "runtimeKeepalivePush", "runtimeKeepalivePop", "callUserCallback", "maybeExit", "asmjsMangle", "HandleAllocator", "getNativeTypeSize", "STACK_SIZE", "STACK_ALIGN", "POINTER_SIZE", "ASSERTIONS", "uleb128Encode", "sigToWasmTypes", "generateFuncType", "convertJsFunctionToWasm", "getEmptyTableSlot", "updateTableMap", "getFunctionAddress", "addFunction", "removeFunction", "reallyNegative", "unSign", "strLen", "reSign", "formatString", "intArrayToString", "AsciiToString", "UTF16ToString", "stringToUTF16", "lengthBytesUTF16", "UTF32ToString", "stringToUTF32", "lengthBytesUTF32", "stringToNewUTF8", "registerKeyEventCallback", "maybeCStringToJsString", "findEventTarget", "getBoundingClientRect", "fillMouseEventData", "registerMouseEventCallback", "registerWheelEventCallback", "registerUiEventCallback", "registerFocusEventCallback", "fillDeviceOrientationEventData", "registerDeviceOrientationEventCallback", "fillDeviceMotionEventData", "registerDeviceMotionEventCallback", "screenOrientation", "fillOrientationChangeEventData", "registerOrientationChangeEventCallback", "fillFullscreenChangeEventData", "registerFullscreenChangeEventCallback", "JSEvents_requestFullscreen", "JSEvents_resizeCanvasForFullscreen", "registerRestoreOldStyle", "hideEverythingExceptGivenElement", "restoreHiddenElements", "setLetterbox", "softFullscreenResizeWebGLRenderTarget", "doRequestFullscreen", "fillPointerlockChangeEventData", "registerPointerlockChangeEventCallback", "registerPointerlockErrorEventCallback", "requestPointerLock", "fillVisibilityChangeEventData", "registerVisibilityChangeEventCallback", "registerTouchEventCallback", "fillGamepadEventData", "registerGamepadEventCallback", "registerBeforeUnloadEventCallback", "fillBatteryEventData", "battery", "registerBatteryEventCallback", "setCanvasElementSize", "getCanvasElementSize", "jsStackTrace", "getCallstack", "convertPCtoSourceLocation", "checkWasiClock", "wasiRightsToMuslOFlags", "wasiOFlagsToMuslOFlags", "createDyncallWrapper", "safeSetTimeout", "setImmediateWrapped", "clearImmediateWrapped", "polyfillSetImmediate", "getPromise", "makePromise", "idsToPromises", "makePromiseCallback", "ExceptionInfo", "findMatchingCatch", "Browser_asyncPrepareDataCounter", "setMainLoop", "getSocketFromFD", "getSocketAddress", "FS_mkdirTree", "_setNetworkCallback", "heapObjectForWebGLType", "toTypedArrayIndex", "webgl_enable_ANGLE_instanced_arrays", "webgl_enable_OES_vertex_array_object", "webgl_enable_WEBGL_draw_buffers", "webgl_enable_WEBGL_multi_draw", "emscriptenWebGLGet", "computeUnpackAlignedImageSize", "colorChannelsInGlTextureFormat", "emscriptenWebGLGetTexPixelData", "emscriptenWebGLGetUniform", "webglGetUniformLocation", "webglPrepareUniformLocationsBeforeFirstUse", "webglGetLeftBracePos", "emscriptenWebGLGetVertexAttrib", "__glGetActiveAttribOrUniform", "writeGLArray", "registerWebGlEventCallback", "runAndAbortIfError", "ALLOC_NORMAL", "ALLOC_STACK", "allocate", "writeStringToMemory", "writeAsciiToMemory", "setErrNo", "demangle", "stackTrace" ];
+Module['addRunDependency'] = addRunDependency;
+
+Module['removeRunDependency'] = removeRunDependency;
+
+Module['ccall'] = ccall;
+
+Module['cwrap'] = cwrap;
+
+Module['getValue'] = getValue;
+
+Module['UTF8ToString'] = UTF8ToString;
+
+Module['FS_createPreloadedFile'] = FS_createPreloadedFile;
+
+Module['FS_unlink'] = FS_unlink;
+
+Module['FS_createPath'] = FS_createPath;
+
+Module['FS_createDevice'] = FS_createDevice;
+
+Module['FS_createDataFile'] = FS_createDataFile;
+
+Module['FS_createLazyFile'] = FS_createLazyFile;
+
+var missingLibrarySymbols = [
+  'writeI53ToI64',
+  'writeI53ToI64Clamped',
+  'writeI53ToI64Signaling',
+  'writeI53ToU64Clamped',
+  'writeI53ToU64Signaling',
+  'readI53FromI64',
+  'readI53FromU64',
+  'convertI32PairToI53',
+  'convertU32PairToI53',
+  'getTempRet0',
+  'ydayFromDate',
+  'inetPton4',
+  'inetNtop4',
+  'inetPton6',
+  'inetNtop6',
+  'readSockaddr',
+  'writeSockaddr',
+  'emscriptenLog',
+  'runMainThreadEmAsm',
+  'jstoi_q',
+  'listenOnce',
+  'autoResumeAudioContext',
+  'dynCallLegacy',
+  'getDynCaller',
+  'dynCall',
+  'handleException',
+  'runtimeKeepalivePush',
+  'runtimeKeepalivePop',
+  'callUserCallback',
+  'maybeExit',
+  'asmjsMangle',
+  'HandleAllocator',
+  'getNativeTypeSize',
+  'STACK_SIZE',
+  'STACK_ALIGN',
+  'POINTER_SIZE',
+  'ASSERTIONS',
+  'uleb128Encode',
+  'sigToWasmTypes',
+  'generateFuncType',
+  'convertJsFunctionToWasm',
+  'getEmptyTableSlot',
+  'updateTableMap',
+  'getFunctionAddress',
+  'addFunction',
+  'removeFunction',
+  'reallyNegative',
+  'unSign',
+  'strLen',
+  'reSign',
+  'formatString',
+  'intArrayToString',
+  'AsciiToString',
+  'UTF16ToString',
+  'stringToUTF16',
+  'lengthBytesUTF16',
+  'UTF32ToString',
+  'stringToUTF32',
+  'lengthBytesUTF32',
+  'stringToNewUTF8',
+  'registerKeyEventCallback',
+  'maybeCStringToJsString',
+  'findEventTarget',
+  'getBoundingClientRect',
+  'fillMouseEventData',
+  'registerMouseEventCallback',
+  'registerWheelEventCallback',
+  'registerUiEventCallback',
+  'registerFocusEventCallback',
+  'fillDeviceOrientationEventData',
+  'registerDeviceOrientationEventCallback',
+  'fillDeviceMotionEventData',
+  'registerDeviceMotionEventCallback',
+  'screenOrientation',
+  'fillOrientationChangeEventData',
+  'registerOrientationChangeEventCallback',
+  'fillFullscreenChangeEventData',
+  'registerFullscreenChangeEventCallback',
+  'JSEvents_requestFullscreen',
+  'JSEvents_resizeCanvasForFullscreen',
+  'registerRestoreOldStyle',
+  'hideEverythingExceptGivenElement',
+  'restoreHiddenElements',
+  'setLetterbox',
+  'softFullscreenResizeWebGLRenderTarget',
+  'doRequestFullscreen',
+  'fillPointerlockChangeEventData',
+  'registerPointerlockChangeEventCallback',
+  'registerPointerlockErrorEventCallback',
+  'requestPointerLock',
+  'fillVisibilityChangeEventData',
+  'registerVisibilityChangeEventCallback',
+  'registerTouchEventCallback',
+  'fillGamepadEventData',
+  'registerGamepadEventCallback',
+  'registerBeforeUnloadEventCallback',
+  'fillBatteryEventData',
+  'battery',
+  'registerBatteryEventCallback',
+  'setCanvasElementSize',
+  'getCanvasElementSize',
+  'jsStackTrace',
+  'getCallstack',
+  'convertPCtoSourceLocation',
+  'checkWasiClock',
+  'wasiRightsToMuslOFlags',
+  'wasiOFlagsToMuslOFlags',
+  'createDyncallWrapper',
+  'safeSetTimeout',
+  'setImmediateWrapped',
+  'clearImmediateWrapped',
+  'polyfillSetImmediate',
+  'getPromise',
+  'makePromise',
+  'idsToPromises',
+  'makePromiseCallback',
+  'ExceptionInfo',
+  'findMatchingCatch',
+  'Browser_asyncPrepareDataCounter',
+  'setMainLoop',
+  'getSocketFromFD',
+  'getSocketAddress',
+  'FS_mkdirTree',
+  '_setNetworkCallback',
+  'heapObjectForWebGLType',
+  'toTypedArrayIndex',
+  'webgl_enable_ANGLE_instanced_arrays',
+  'webgl_enable_OES_vertex_array_object',
+  'webgl_enable_WEBGL_draw_buffers',
+  'webgl_enable_WEBGL_multi_draw',
+  'emscriptenWebGLGet',
+  'computeUnpackAlignedImageSize',
+  'colorChannelsInGlTextureFormat',
+  'emscriptenWebGLGetTexPixelData',
+  'emscriptenWebGLGetUniform',
+  'webglGetUniformLocation',
+  'webglPrepareUniformLocationsBeforeFirstUse',
+  'webglGetLeftBracePos',
+  'emscriptenWebGLGetVertexAttrib',
+  '__glGetActiveAttribOrUniform',
+  'writeGLArray',
+  'registerWebGlEventCallback',
+  'runAndAbortIfError',
+  'ALLOC_NORMAL',
+  'ALLOC_STACK',
+  'allocate',
+  'writeStringToMemory',
+  'writeAsciiToMemory',
+  'setErrNo',
+  'demangle',
+  'stackTrace',
+];
 
 missingLibrarySymbols.forEach(missingLibrarySymbol);
 
-var unexportedSymbols = [ "run", "addOnPreRun", "addOnInit", "addOnPreMain", "addOnExit", "addOnPostRun", "out", "err", "callMain", "abort", "wasmMemory", "wasmExports", "writeStackCookie", "checkStackCookie", "convertI32PairToI53Checked", "stackSave", "stackRestore", "stackAlloc", "setTempRet0", "ptrToString", "zeroMemory", "exitJS", "getHeapMax", "growMemory", "ENV", "MONTH_DAYS_REGULAR", "MONTH_DAYS_LEAP", "MONTH_DAYS_REGULAR_CUMULATIVE", "MONTH_DAYS_LEAP_CUMULATIVE", "isLeapYear", "arraySum", "addDays", "ERRNO_CODES", "ERRNO_MESSAGES", "DNS", "Protocols", "Sockets", "initRandomFill", "randomFill", "timers", "warnOnce", "readEmAsmArgsArray", "readEmAsmArgs", "runEmAsmFunction", "jstoi_s", "getExecutableName", "keepRuntimeAlive", "asyncLoad", "alignMemory", "mmapAlloc", "wasmTable", "noExitRuntime", "getCFunc", "freeTableIndexes", "functionsInTableMap", "setValue", "PATH", "PATH_FS", "UTF8Decoder", "UTF8ArrayToString", "stringToUTF8Array", "stringToUTF8", "lengthBytesUTF8", "intArrayFromString", "stringToAscii", "UTF16Decoder", "stringToUTF8OnStack", "writeArrayToMemory", "JSEvents", "specialHTMLTargets", "findCanvasEventTarget", "currentFullscreenStrategy", "restoreOldWindowedStyle", "UNWIND_CACHE", "ExitStatus", "getEnvStrings", "doReadv", "doWritev", "promiseMap", "uncaughtExceptionCount", "exceptionLast", "exceptionCaught", "Browser", "getPreloadedImageData__data", "wget", "SYSCALLS", "preloadPlugins", "FS_modeStringToFlags", "FS_getMode", "FS_stdin_getChar_buffer", "FS_stdin_getChar", "FS_readFile", "FS", "MEMFS", "TTY", "PIPEFS", "SOCKFS", "tempFixedLengthArray", "miniTempWebGLFloatBuffers", "miniTempWebGLIntBuffers", "GL", "AL", "GLUT", "EGL", "GLEW", "IDBStore", "SDL", "SDL_gfx", "allocateUTF8", "allocateUTF8OnStack", "print", "printErr" ];
+var unexportedSymbols = [
+  'run',
+  'addOnPreRun',
+  'addOnInit',
+  'addOnPreMain',
+  'addOnExit',
+  'addOnPostRun',
+  'out',
+  'err',
+  'callMain',
+  'abort',
+  'wasmMemory',
+  'wasmExports',
+  'writeStackCookie',
+  'checkStackCookie',
+  'convertI32PairToI53Checked',
+  'stackSave',
+  'stackRestore',
+  'stackAlloc',
+  'setTempRet0',
+  'ptrToString',
+  'zeroMemory',
+  'exitJS',
+  'getHeapMax',
+  'growMemory',
+  'ENV',
+  'MONTH_DAYS_REGULAR',
+  'MONTH_DAYS_LEAP',
+  'MONTH_DAYS_REGULAR_CUMULATIVE',
+  'MONTH_DAYS_LEAP_CUMULATIVE',
+  'isLeapYear',
+  'arraySum',
+  'addDays',
+  'ERRNO_CODES',
+  'ERRNO_MESSAGES',
+  'DNS',
+  'Protocols',
+  'Sockets',
+  'initRandomFill',
+  'randomFill',
+  'timers',
+  'warnOnce',
+  'readEmAsmArgsArray',
+  'readEmAsmArgs',
+  'runEmAsmFunction',
+  'jstoi_s',
+  'getExecutableName',
+  'keepRuntimeAlive',
+  'asyncLoad',
+  'alignMemory',
+  'mmapAlloc',
+  'wasmTable',
+  'noExitRuntime',
+  'getCFunc',
+  'freeTableIndexes',
+  'functionsInTableMap',
+  'setValue',
+  'PATH',
+  'PATH_FS',
+  'UTF8Decoder',
+  'UTF8ArrayToString',
+  'stringToUTF8Array',
+  'stringToUTF8',
+  'lengthBytesUTF8',
+  'intArrayFromString',
+  'stringToAscii',
+  'UTF16Decoder',
+  'stringToUTF8OnStack',
+  'writeArrayToMemory',
+  'JSEvents',
+  'specialHTMLTargets',
+  'findCanvasEventTarget',
+  'currentFullscreenStrategy',
+  'restoreOldWindowedStyle',
+  'UNWIND_CACHE',
+  'ExitStatus',
+  'getEnvStrings',
+  'doReadv',
+  'doWritev',
+  'promiseMap',
+  'uncaughtExceptionCount',
+  'exceptionLast',
+  'exceptionCaught',
+  'Browser',
+  'getPreloadedImageData__data',
+  'wget',
+  'SYSCALLS',
+  'preloadPlugins',
+  'FS_modeStringToFlags',
+  'FS_getMode',
+  'FS_stdin_getChar_buffer',
+  'FS_stdin_getChar',
+  'FS_readFile',
+  'FS',
+  'MEMFS',
+  'TTY',
+  'PIPEFS',
+  'SOCKFS',
+  'tempFixedLengthArray',
+  'miniTempWebGLFloatBuffers',
+  'miniTempWebGLIntBuffers',
+  'GL',
+  'AL',
+  'GLUT',
+  'EGL',
+  'GLEW',
+  'IDBStore',
+  'SDL',
+  'SDL_gfx',
+  'allocateUTF8',
+  'allocateUTF8OnStack',
+  'print',
+  'printErr',
+];
 
 unexportedSymbols.forEach(unexportedRuntimeSymbol);
 
@@ -5448,18 +6542,21 @@ function run() {
   function doRun() {
     if (calledRun) return;
     calledRun = true;
-    Module["calledRun"] = true;
+    Module['calledRun'] = true;
     if (ABORT) return;
     initRuntime();
-    if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();
-    assert(!Module["_main"], 'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]');
+    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();
+    assert(
+      !Module['_main'],
+      'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]'
+    );
     postRun();
   }
-  if (Module["setStatus"]) {
-    Module["setStatus"]("Running...");
-    setTimeout(function() {
-      setTimeout(function() {
-        Module["setStatus"]("");
+  if (Module['setStatus']) {
+    Module['setStatus']('Running...');
+    setTimeout(function () {
+      setTimeout(function () {
+        Module['setStatus']('');
       }, 1);
       doRun();
     }, 1);
@@ -5473,13 +6570,13 @@ function checkUnflushedContent() {
   var oldOut = out;
   var oldErr = err;
   var has = false;
-  out = err = x => {
+  out = err = (x) => {
     has = true;
   };
   try {
     _fflush(0);
-    [ "stdout", "stderr" ].forEach(function(name) {
-      var info = FS.analyzePath("/dev/" + name);
+    ['stdout', 'stderr'].forEach(function (name) {
+      var info = FS.analyzePath('/dev/' + name);
       if (!info) return;
       var stream = info.object;
       var rdev = stream.rdev;
@@ -5492,14 +6589,17 @@ function checkUnflushedContent() {
   out = oldOut;
   err = oldErr;
   if (has) {
-    warnOnce("stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the Emscripten FAQ), or make sure to emit a newline when you printf etc.");
+    warnOnce(
+      'stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the Emscripten FAQ), or make sure to emit a newline when you printf etc.'
+    );
   }
 }
 
-if (Module["preInit"]) {
-  if (typeof Module["preInit"] == "function") Module["preInit"] = [ Module["preInit"] ];
-  while (Module["preInit"].length > 0) {
-    Module["preInit"].pop()();
+if (Module['preInit']) {
+  if (typeof Module['preInit'] == 'function')
+    Module['preInit'] = [Module['preInit']];
+  while (Module['preInit'].length > 0) {
+    Module['preInit'].pop()();
   }
 }
 
diff --git a/mupdf/mupdf-async.js b/mupdf/mupdf-async.js
index 149e1605e48fe1b99edaa9b47a57bfea5b9a9226..8898a0f9649823809d508498260635344b916ce9 100644
--- a/mupdf/mupdf-async.js
+++ b/mupdf/mupdf-async.js
@@ -28,8 +28,10 @@ export async function initMuPDFWorker() {
   // Do not change without confirming compatibility with all three.
   const mupdf = {};
   let worker;
-  if (typeof process === 'undefined') {
-    worker = new Worker(new URL('./mupdf-worker.js', import.meta.url), { type: 'module' });
+  if (true) {
+    worker = new Worker(new URL('./mupdf-worker.js', import.meta.url), {
+      type: 'module',
+    });
   } else {
     const WorkerNode = (await import('worker_threads')).Worker;
     worker = new WorkerNode(new URL('./mupdf-worker.js', import.meta.url));
@@ -39,7 +41,7 @@ export async function initMuPDFWorker() {
     console.error(err);
   };
 
-  if (typeof process === 'undefined') {
+  if (true) {
     // @ts-ignore
     worker.onerror = errorHandler;
   } else {
@@ -78,7 +80,7 @@ export async function initMuPDFWorker() {
     }
   };
 
-  if (typeof process === 'undefined') {
+  if (true) {
     // @ts-ignore
     worker.onmessage = (event) => messageHandler(event.data);
   } else {
@@ -90,7 +92,15 @@ export async function initMuPDFWorker() {
     return function (...args) {
       return new Promise((resolve, reject) => {
         // Add the PDF as the first argument for most functions
-        if (!['openDocument', 'cleanFile', 'freeDocument', 'overlayDocuments', 'subsetPages'].includes(func)) {
+        if (
+          ![
+            'openDocument',
+            'cleanFile',
+            'freeDocument',
+            'overlayDocuments',
+            'subsetPages',
+          ].includes(func)
+        ) {
           // Remove job number (appended by Tesseract scheduler function)
           // args = args.slice(0,-1)
 
@@ -103,7 +113,10 @@ export async function initMuPDFWorker() {
         const id = worker.promiseId++;
         const page = ['drawPageAsPNG'].includes(func) ? args[1] : null;
         worker.promises[id] = {
-          resolve, reject, func, page,
+          resolve,
+          reject,
+          func,
+          page,
         };
 
         if (args[0] instanceof ArrayBuffer) {
@@ -142,7 +155,9 @@ export async function initMuPDFWorker() {
   mupdf.cleanFile = wrap('cleanFile');
   mupdf.overlayDocuments = wrap('overlayDocuments');
   mupdf.subsetPages = wrap('subsetPages');
-  mupdf.terminate = function () { worker.terminate(); };
+  mupdf.terminate = function () {
+    worker.terminate();
+  };
 
   await readyPromise;
 
diff --git a/mupdf/mupdf-worker.js b/mupdf/mupdf-worker.js
index a2017db542a0e71eb80f7e3d38f1cefb6f881f8b..5df2f267ea569dcdeb714b06dc68f33f59b017ed 100644
--- a/mupdf/mupdf-worker.js
+++ b/mupdf/mupdf-worker.js
@@ -20,13 +20,16 @@
 // Artifex Software, Inc., 1305 Grant Avenue - Suite 200, Novato,
 // CA 94945, U.S.A., +1(415)492-9861, for further information.
 
-const parentPort = typeof process === 'undefined' ? globalThis : (await import('worker_threads')).parentPort;
+const parentPort = true
+  ? globalThis
+  : (await import('worker_threads')).parentPort;
 if (!parentPort) throw new Error('This file must be run in a worker');
 
 // Copied from https://gist.github.com/jonleighton/958841
 function arrayBufferToBase64(arrayBuffer) {
   let base64 = '';
-  const encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
+  const encodings =
+    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
 
   const bytes = new Uint8Array(arrayBuffer);
   const byteLength = bytes.byteLength;
@@ -82,16 +85,16 @@ function arrayBufferToBase64(arrayBuffer) {
 export const mupdf = {};
 let ready = false;
 
-if (typeof process === 'object') {
-  // @ts-ignore
-  globalThis.self = globalThis;
-  // @ts-ignore
-  const { createRequire } = await import('module');
-  globalThis.require = createRequire(import.meta.url);
-  const { fileURLToPath } = await import('url');
-  const { dirname } = await import('path');
-  globalThis.__dirname = dirname(fileURLToPath(import.meta.url));
-}
+// if (typeof process === 'object') {
+//   // @ts-ignore
+//   globalThis.self = globalThis;
+//   // @ts-ignore
+//   const { createRequire } = await import('module');
+//   globalThis.require = createRequire(import.meta.url);
+//   const { fileURLToPath } = await import('url');
+//   const { dirname } = await import('path');
+//   globalThis.__dirname = dirname(fileURLToPath(import.meta.url));
+// }
 
 const { Module, FS } = await import('./libmupdf.js');
 
@@ -109,34 +112,111 @@ let wasm_convertImageEnd;
 
 Module.onRuntimeInitialized = function () {
   Module.ccall('initContext');
-  mupdf.openDocumentFromBuffer = Module.cwrap('openDocumentFromBuffer', 'number', ['string', 'number', 'number']);
+  mupdf.openDocumentFromBuffer = Module.cwrap(
+    'openDocumentFromBuffer',
+    'number',
+    ['string', 'number', 'number']
+  );
   mupdf.freeDocument = Module.cwrap('freeDocument', 'null', ['number']);
   mupdf.documentTitle = Module.cwrap('documentTitle', 'string', ['number']);
   mupdf.countPages = Module.cwrap('countPages', 'number', ['number']);
-  mupdf.pageWidth = Module.cwrap('pageWidth', 'number', ['number', 'number', 'number']);
-  mupdf.pageHeight = Module.cwrap('pageHeight', 'number', ['number', 'number', 'number']);
-  mupdf.pageLinksJSON = Module.cwrap('pageLinks', 'string', ['number', 'number', 'number']);
-  mupdf.doDrawPageAsPNG = Module.cwrap('doDrawPageAsPNG', 'null', ['number', 'number', 'number', 'number']);
-  mupdf.doDrawPageAsPNGGray = Module.cwrap('doDrawPageAsPNGGray', 'null', ['number', 'number', 'number', 'number']);
-  wasm_convertImageStart = Module.cwrap('convertImageStart', 'null', ['number']);
-  wasm_convertImageAddPage = Module.cwrap('convertImageAddPage', 'null', ['number', 'number', 'number', 'number', 'number']);
+  mupdf.pageWidth = Module.cwrap('pageWidth', 'number', [
+    'number',
+    'number',
+    'number',
+  ]);
+  mupdf.pageHeight = Module.cwrap('pageHeight', 'number', [
+    'number',
+    'number',
+    'number',
+  ]);
+  mupdf.pageLinksJSON = Module.cwrap('pageLinks', 'string', [
+    'number',
+    'number',
+    'number',
+  ]);
+  mupdf.doDrawPageAsPNG = Module.cwrap('doDrawPageAsPNG', 'null', [
+    'number',
+    'number',
+    'number',
+    'number',
+  ]);
+  mupdf.doDrawPageAsPNGGray = Module.cwrap('doDrawPageAsPNGGray', 'null', [
+    'number',
+    'number',
+    'number',
+    'number',
+  ]);
+  wasm_convertImageStart = Module.cwrap('convertImageStart', 'null', [
+    'number',
+  ]);
+  wasm_convertImageAddPage = Module.cwrap('convertImageAddPage', 'null', [
+    'number',
+    'number',
+    'number',
+    'number',
+    'number',
+  ]);
   wasm_convertImageEnd = Module.cwrap('convertImageEnd', 'null', ['number']);
-  wasm_runPDF = Module.cwrap('runPDF', 'null', ['number', 'number', 'number', 'number', 'number', 'number', 'number']);
-  wasm_pdfSaveDocument = Module.cwrap('pdfSaveDocument', 'null', ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number']);
+  wasm_runPDF = Module.cwrap('runPDF', 'null', [
+    'number',
+    'number',
+    'number',
+    'number',
+    'number',
+    'number',
+    'number',
+  ]);
+  wasm_pdfSaveDocument = Module.cwrap('pdfSaveDocument', 'null', [
+    'number',
+    'number',
+    'number',
+    'number',
+    'number',
+    'number',
+    'number',
+    'number',
+  ]);
   mupdf.getLastDrawData = Module.cwrap('getLastDrawData', 'number', []);
   mupdf.getLastDrawSize = Module.cwrap('getLastDrawSize', 'number', []);
   wasm_extractAllFonts = Module.cwrap('extractAllFonts', 'number', ['number']);
-  wasm_pageText0 = Module.cwrap('pageText', 'PageTextResults', ['number', 'number', 'number', 'number', 'number', 'number', 'number']);
-  mupdf.overlayDocuments = Module.cwrap('pdfOverlayDocuments', 'null', ['number', 'number']);
-  mupdf.subsetPages = Module.cwrap('pdfSubsetPages', 'null', ['number', 'number', 'number']);
-  mupdf.searchJSON = Module.cwrap('search', 'string', ['number', 'number', 'number', 'string']);
+  wasm_pageText0 = Module.cwrap('pageText', 'PageTextResults', [
+    'number',
+    'number',
+    'number',
+    'number',
+    'number',
+    'number',
+    'number',
+  ]);
+  mupdf.overlayDocuments = Module.cwrap('pdfOverlayDocuments', 'null', [
+    'number',
+    'number',
+  ]);
+  mupdf.subsetPages = Module.cwrap('pdfSubsetPages', 'null', [
+    'number',
+    'number',
+    'number',
+  ]);
+  mupdf.searchJSON = Module.cwrap('search', 'string', [
+    'number',
+    'number',
+    'number',
+    'string',
+  ]);
   mupdf.loadOutline = Module.cwrap('loadOutline', 'number', ['number']);
   mupdf.freeOutline = Module.cwrap('freeOutline', null, ['number']);
   mupdf.outlineTitle = Module.cwrap('outlineTitle', 'string', ['number']);
-  mupdf.outlinePage = Module.cwrap('outlinePage', 'number', ['number', 'number']);
+  mupdf.outlinePage = Module.cwrap('outlinePage', 'number', [
+    'number',
+    'number',
+  ]);
   mupdf.outlineDown = Module.cwrap('outlineDown', 'number', ['number']);
   mupdf.outlineNext = Module.cwrap('outlineNext', 'number', ['number']);
-  wasm_checkNativeText = Module.cwrap('checkNativeText', 'number', ['number', 'number']);
+  wasm_checkNativeText = Module.cwrap('checkNativeText', 'number', [
+    'number',
+    'number',
+  ]);
   mupdf.writeDocument = Module.cwrap('writeDocument', 'null', []);
   parentPort.postMessage('READY');
   ready = true;
@@ -156,10 +236,29 @@ Module.onRuntimeInitialized = function () {
  * @param {Boolean} [args.delGarbage=true]
  * @returns
  */
-mupdf.save = function (doc, {
-  doc1, minpage = 0, maxpage = -1, pagewidth = -1, pageheight = -1, humanReadable = false, skipTextInvis = false, delGarbage = true,
-}) {
-  wasm_pdfSaveDocument(doc1, minpage, maxpage, pagewidth, pageheight, humanReadable, skipTextInvis, delGarbage);
+mupdf.save = function (
+  doc,
+  {
+    doc1,
+    minpage = 0,
+    maxpage = -1,
+    pagewidth = -1,
+    pageheight = -1,
+    humanReadable = false,
+    skipTextInvis = false,
+    delGarbage = true,
+  }
+) {
+  wasm_pdfSaveDocument(
+    doc1,
+    minpage,
+    maxpage,
+    pagewidth,
+    pageheight,
+    humanReadable,
+    skipTextInvis,
+    delGarbage
+  );
   const content = FS.readFile('/download.pdf');
 
   FS.unlink('/download.pdf');
@@ -177,9 +276,10 @@ mupdf.save = function (doc, {
  * @param {boolean} [args.calcStats=false]
  * @returns {{letterCountTotal: number, letterCountVis: number, content: string}}
  */
-mupdf.pageText = function (doc, {
-  page, dpi = 72, format = 'text', skipTextInvis = false, calcStats = false,
-}) {
+mupdf.pageText = function (
+  doc,
+  { page, dpi = 72, format = 'text', skipTextInvis = false, calcStats = false }
+) {
   const formatCode = {
     txt: 0,
     text: 0,
@@ -189,7 +289,15 @@ mupdf.pageText = function (doc, {
     json: 4,
   }[format];
 
-  const structPtr = wasm_pageText0(doc, page, dpi, formatCode, skipTextInvis, calcStats, true);
+  const structPtr = wasm_pageText0(
+    doc,
+    page,
+    dpi,
+    formatCode,
+    skipTextInvis,
+    calcStats,
+    true
+  );
 
   const letterCountTotal = Module.getValue(structPtr, 'i32');
   const letterCountVis = Module.getValue(structPtr + 4, 'i32');
@@ -285,12 +393,15 @@ mupdf.convertImageStart = function (doc, { humanReadable = false }) {
  * @param {number} args.pageheight
  * @param {number} [args.angle=0] - Angle in degrees to rotate the image counter-clockwise.
  */
-mupdf.convertImageAddPage = function (doc, {
-  image, i, pagewidth, pageheight, angle = 0,
-}) {
-  const imgData = new Uint8Array(atob(image.split(',')[1])
-    .split('')
-    .map((c) => c.charCodeAt(0)));
+mupdf.convertImageAddPage = function (
+  doc,
+  { image, i, pagewidth, pageheight, angle = 0 }
+) {
+  const imgData = new Uint8Array(
+    atob(image.split(',')[1])
+      .split('')
+      .map((c) => c.charCodeAt(0))
+  );
 
   // Despite the images being named as PNG, they can be any format supported by mupdf.
   Module.FS_createDataFile('/', `${String(i)}.png`, imgData, 1, 1, 1);
@@ -319,9 +430,17 @@ mupdf.convertImageEnd = function () {
  * @param {Boolean} [args.humanReadable=false]
  * @returns
  */
-mupdf.run = function (doc, {
-  doc1, minpage = 0, maxpage = -1, pagewidth = -1, pageheight = -1, humanReadable = false,
-}) {
+mupdf.run = function (
+  doc,
+  {
+    doc1,
+    minpage = 0,
+    maxpage = -1,
+    pagewidth = -1,
+    pageheight = -1,
+    humanReadable = false,
+  }
+) {
   wasm_runPDF(doc1, minpage, maxpage, pagewidth, pageheight, humanReadable);
   const content = FS.readFile('/download.pdf');
 
@@ -347,9 +466,10 @@ mupdf.openDocument = function (data, magic) {
  * @param {boolean} [args.skipText=false]
  * @returns
  */
-mupdf.drawPageAsPNG = function (doc, {
-  page, dpi, color = true, skipText = false,
-}) {
+mupdf.drawPageAsPNG = function (
+  doc,
+  { page, dpi, color = true, skipText = false }
+) {
   if (color) {
     mupdf.doDrawPageAsPNG(doc, page, dpi, skipText);
   } else {
@@ -358,7 +478,9 @@ mupdf.drawPageAsPNG = function (doc, {
 
   const n = mupdf.getLastDrawSize();
   const p = mupdf.getLastDrawData();
-  return `data:image/png;base64,${arrayBufferToBase64(Module.HEAPU8.buffer.slice(p, p + n))}`;
+  return `data:image/png;base64,${arrayBufferToBase64(
+    Module.HEAPU8.buffer.slice(p, p + n)
+  )}`;
 };
 
 mupdf.documentOutline = function (doc) {
@@ -411,21 +533,30 @@ mupdf.search = function (doc, page, dpi, needle) {
 const handleMessage = (data) => {
   const [func, args, id] = data;
   if (!ready) {
-    parentPort.postMessage(['ERROR', id, { name: 'NotReadyError', message: 'WASM module is not ready yet' }]);
+    parentPort.postMessage([
+      'ERROR',
+      id,
+      { name: 'NotReadyError', message: 'WASM module is not ready yet' },
+    ]);
     return;
   }
   try {
     const result = mupdf[func](...args);
-    if (result instanceof ArrayBuffer) parentPort.postMessage(['RESULT', id, result], [result]);
+    if (result instanceof ArrayBuffer)
+      parentPort.postMessage(['RESULT', id, result], [result]);
     else if (result?.buffer instanceof ArrayBuffer) {
       parentPort.postMessage(['RESULT', id, result], [result.buffer]);
     } else parentPort.postMessage(['RESULT', id, result]);
   } catch (error) {
-    parentPort.postMessage(['ERROR', id, { name: error.name, message: error.message }]);
+    parentPort.postMessage([
+      'ERROR',
+      id,
+      { name: error.name, message: error.message },
+    ]);
   }
 };
 
-if (typeof process === 'undefined') {
+if (true) {
   onmessage = (event) => handleMessage(event.data);
 } else {
   parentPort.on('message', handleMessage);
diff --git a/scribe.js b/scribe.js
index 36d2ab16c101bb3504e5ea5e7b9ab01746ad4284..d397bb28d3c6177554ea62e83830a27c017e9766 100644
--- a/scribe.js
+++ b/scribe.js
@@ -4,7 +4,9 @@ import {
   DebugData,
   layoutDataTables,
   layoutRegions,
-  ocrAll, pageMetricsArr, visInstructions,
+  ocrAll,
+  pageMetricsArr,
+  visInstructions,
 } from './js/containers/dataContainer.js';
 import { FontCont } from './js/containers/fontContainer.js';
 import { ImageCache } from './js/containers/imageContainer.js';
@@ -22,7 +24,10 @@ import { gs } from './js/generalWorkerMain.js';
 import { importFiles, importFilesSupp } from './js/import/import.js';
 import { combineOCRPage } from './js/modifyOCR.js';
 import {
-  calcBoxOverlap, countSubstringOccurrences, getRandomAlphanum, replaceSmartQuotes,
+  calcBoxOverlap,
+  countSubstringOccurrences,
+  getRandomAlphanum,
+  replaceSmartQuotes,
   saveAs,
 } from './js/utils/miscUtils.js';
 import layout, { calcTableBbox } from './js/objects/layoutObjects.js';
@@ -32,16 +37,24 @@ import {
   compareOCR,
   convertOCRPage,
   evalOCRPage,
-  recognize, recognizePageImp,
+  recognize,
+  recognizePageImp,
 } from './js/recognizeConvert.js';
 import { calcWordMetrics } from './js/utils/fontUtils.js';
 import { imageStrToBlob } from './js/utils/imageUtils.js';
 import {
-  calcConf, checkOcrWordsAdjacent, mergeOcrWords, splitOcrWord,
+  calcConf,
+  checkOcrWordsAdjacent,
+  mergeOcrWords,
+  splitOcrWord,
 } from './js/utils/ocrUtils.js';
 import { assignParagraphs } from './js/utils/reflowPars.js';
 import { writeXlsx } from './js/export/writeTabular.js';
-import { calcColumnBounds, detectTablesInPage, makeTableFromBbox } from './js/utils/detectTables.js';
+import {
+  calcColumnBounds,
+  detectTablesInPage,
+  makeTableFromBbox,
+} from './js/utils/detectTables.js';
 import { ca } from './js/canvasAdapter.js';
 
 /**
@@ -88,14 +101,24 @@ const init = async (params) => {
  * @param {Array<string>} [langs=['eng']]
  * @param {Parameters<typeof exportData>[0]} [outputFormat='txt']
  */
-const extractText = async (files, langs = ['eng'], outputFormat = 'txt', options = {}) => {
+const extractText = async (
+  files,
+  langs = ['eng'],
+  outputFormat = 'txt',
+  options = {}
+) => {
   const skipRecPDFTextNative = options?.skipRecPDFTextNative ?? true;
   const skipRecPDFTextOCR = options?.skipRecPDFTextOCR ?? false;
   init({ ocr: true, font: true });
   await importFiles(files);
-  if (!inputData.xmlMode[0] && !inputData.imageMode && !inputData.pdfMode) throw new Error('No relevant files to process.');
-  const skipRecPDF = inputData.pdfMode && (inputData.pdfType === 'text' && skipRecPDFTextNative || inputData.pdfType === 'ocr' && skipRecPDFTextOCR);
-  const skipRecOCR = inputData.xmlMode[0] && !inputData.imageMode && !inputData.pdfMode;
+  if (!inputData.xmlMode[0] && !inputData.imageMode && !inputData.pdfMode)
+    throw new Error('No relevant files to process.');
+  const skipRecPDF =
+    inputData.pdfMode &&
+    ((inputData.pdfType === 'text' && skipRecPDFTextNative) ||
+      (inputData.pdfType === 'ocr' && skipRecPDFTextOCR));
+  const skipRecOCR =
+    inputData.xmlMode[0] && !inputData.imageMode && !inputData.pdfMode;
   if (!skipRecPDF && !skipRecOCR) await recognize({ langs });
   return exportData(outputFormat);
 };
@@ -108,18 +131,7 @@ const extractText = async (files, langs = ['eng'], outputFormat = 'txt', options
  * @public
  */
 async function writeDebugImages(canvas, compDebugArrArr, filePath) {
-  if (typeof process === 'undefined') {
-    throw new Error('This function is only available in Node.js.');
-  } else {
-    const canvas = await drawDebugImages({ compDebugArrArr, context: 'node' });
-
-    const imgURL = canvas.toDataURL();
-    const imgData = new Uint8Array(atob(imgURL.split(',')[1])
-      .split('')
-      .map((c) => c.charCodeAt(0)));
-    const fs = await import('fs');
-    fs.writeFileSync(filePath, imgData);
-  }
+  throw new Error('This function is only available in Node.js.');
 }
 
 /**
@@ -129,42 +141,11 @@ async function writeDebugImages(canvas, compDebugArrArr, filePath) {
  * @returns
  */
 async function dumpDebugImages(dir) {
-  if (typeof process === 'undefined') {
-    throw new Error('This function is only available in Node.js.');
-  } else {
-    if (!DebugData.debugImg.Combined || DebugData.debugImg.Combined.length === 0) {
-      console.log('No debug images to dump.');
-      return;
-    }
-
-    const canvasAlt = await ca.createCanvas(200, 200);
-    const ctxDebug = canvasAlt.getContext('2d');
-
-    for (const [name, imgArr] of Object.entries(DebugData.debugImg)) {
-      if (!imgArr || imgArr.length === 0) continue;
-      for (let i = 0; i < imgArr.length; i++) {
-        const filePath = `${dir}/${name}_${i}.png`;
-        await writeDebugImages(canvasAlt, [imgArr[i]], filePath);
-      }
-    }
-  }
+  throw new Error('This function is only available in Node.js.');
 }
 
 async function dumpHOCR(dir) {
-  if (typeof process === 'undefined') {
-    throw new Error('This function is only available in Node.js.');
-  } else {
-    const activeCurrent = ocrAll.active;
-
-    const fs = await import('fs');
-    for (const [name, pages] of Object.entries(ocrAll)) {
-      ocrAll.active = pages;
-      const hocrStr = await exportData('hocr');
-      fs.writeFileSync(`${dir}/${name}.hocr`, hocrStr);
-    }
-
-    ocrAll.active = activeCurrent;
-  }
+  throw new Error('This function is only available in Node.js.');
 }
 
 class data {
@@ -267,7 +248,11 @@ const clear = async () => {
  */
 const terminate = async () => {
   clearData();
-  await Promise.allSettled([gs.terminate(), ImageCache.terminate(), FontCont.terminate()]);
+  await Promise.allSettled([
+    gs.terminate(),
+    ImageCache.terminate(),
+    FontCont.terminate(),
+  ]);
 };
 
 export default {
diff --git a/scrollview-web/scrollview/ScrollView.js b/scrollview-web/scrollview/ScrollView.js
index 94509c1496854d5d18509602dd84646730b59f2f..405526f4d071d47fc6a4ad7796fc2bce8ce1f818 100644
--- a/scrollview-web/scrollview/ScrollView.js
+++ b/scrollview-web/scrollview/ScrollView.js
@@ -15,18 +15,21 @@ export class ScrollView {
    * @param {boolean} [param.lightTheme=false]
    * @param {import('canvaskit-wasm').CanvasKit} [param.CanvasKit] - CanvasKit module. Must be defined if running in Node.js.
    */
-  constructor({
-    lightTheme = false,
-    CanvasKit,
-  }) {
+  constructor({ lightTheme = false, CanvasKit }) {
     if (typeof OffscreenCanvas === 'undefined' && !CanvasKit) {
-      throw new Error('CanvasKit module must be provided in environments that do not support OffscreenCanvas natively (i.e. Node.js).');
+      throw new Error(
+        'CanvasKit module must be provided in environments that do not support OffscreenCanvas natively (i.e. Node.js).'
+      );
     }
 
     /** @type {import('canvaskit-wasm').CanvasKit} */
-    this.CanvasKit = /** @type {import('canvaskit-wasm').CanvasKit} */ (CanvasKit);
+    this.CanvasKit = /** @type {import('canvaskit-wasm').CanvasKit} */ (
+      CanvasKit
+    );
 
-    this.createCanvas = typeof process === 'undefined' ? (width, height) => (new OffscreenCanvas(width, height)) : (width, height) => this.CanvasKit.MakeCanvas(width, height);
+    this.createCanvas = true
+      ? (width, height) => new OffscreenCanvas(width, height)
+      : (width, height) => this.CanvasKit.MakeCanvas(width, height);
     this.lightTheme = lightTheme;
     this.svId = getRandomAlphanum(10);
   }
@@ -66,7 +69,13 @@ export class ScrollView {
       let nonemptyLegend = false;
       if (createLegend) {
         canvasLegend = this.createCanvas(200, 200);
-        nonemptyLegend = drawColorLegend(canvasLegend, nameFull, this.windows[key].penColorsRect, this.windows[key].penColorsLine, this.lightTheme);
+        nonemptyLegend = drawColorLegend(
+          canvasLegend,
+          nameFull,
+          this.windows[key].penColorsRect,
+          this.windows[key].penColorsLine,
+          this.lightTheme
+        );
       }
 
       outputObj[nameFull] = {
@@ -98,7 +107,7 @@ export class ScrollView {
         return;
       } else {
         const quote = argStr.charAt(0);
-        if (quote === '\'' || quote === '"') {
+        if (quote === "'" || quote === '"') {
           str = argStr;
         }
       }
@@ -142,7 +151,9 @@ export class ScrollView {
 
     if (idStrs.length > limit) {
       // If there are more elements than the limit, concatenate the rest back into the last element
-      idStrs = idStrs.slice(0, limit - 1).concat(idStrs.slice(limit - 1).join(' '));
+      idStrs = idStrs
+        .slice(0, limit - 1)
+        .concat(idStrs.slice(limit - 1).join(' '));
     }
     return idStrs;
   }
@@ -162,23 +173,35 @@ export class ScrollView {
   async IOLoop(inputLine) {
     if (!inputLine) return;
 
-    if (this.windows[this.windowID] && this.windows[this.windowID].polylineSize > this.windows[this.windowID].polylineScanned) {
+    if (
+      this.windows[this.windowID] &&
+      this.windows[this.windowID].polylineSize >
+        this.windows[this.windowID].polylineScanned
+    ) {
       // We are processing a polyline.
       // Read pairs of coordinates separated by commas.
       let first = true;
       for (const coordStr of inputLine.replace(/[,\s]+$/, '').split(',')) {
         const coord = Number.parseInt(coordStr);
         if (first) {
-          this.windows[this.windowID].polylineXCoords[this.windows[this.windowID].polylineScanned] = coord;
+          this.windows[this.windowID].polylineXCoords[
+            this.windows[this.windowID].polylineScanned
+          ] = coord;
         } else {
-          this.windows[this.windowID].polylineYCoords[this.windows[this.windowID].polylineScanned++] = coord;
+          this.windows[this.windowID].polylineYCoords[
+            this.windows[this.windowID].polylineScanned++
+          ] = coord;
         }
         first = !first;
       }
       console.assert(first);
     } else if (this.imageWaiting) {
       const image = await SVImageHandler.readImage(inputLine, this.CanvasKit);
-      this.windows[this.windowID].drawImageInternal(image, this.imageXPos, this.imageYPos);
+      this.windows[this.windowID].drawImageInternal(
+        image,
+        this.imageXPos,
+        this.imageYPos
+      );
       this.imageWaiting = false;
     } else {
       // Process this normally.
@@ -196,7 +219,9 @@ export class ScrollView {
     }
 
     if (!this.createCanvas) {
-      throw new Error('createCanvas method must be defined prior to running processInput.');
+      throw new Error(
+        'createCanvas method must be defined prior to running processInput.'
+      );
     }
 
     // Check if the command starts with 'w', indicating a window operation
@@ -217,7 +242,13 @@ export class ScrollView {
       const boolList = [];
 
       // Assuming parseArguments is already defined and adapted to JavaScript
-      this.constructor.parseArguments(inputLine.substring(start + 1, end), intList, floatList, stringList, boolList);
+      this.constructor.parseArguments(
+        inputLine.substring(start + 1, end),
+        intList,
+        floatList,
+        stringList,
+        boolList
+      );
 
       const colon = inputLine.indexOf(':');
       if (colon > 1 && colon < start) {
@@ -228,7 +259,12 @@ export class ScrollView {
         // Assuming this.windows is an array of objects with methods as defined in Java
         switch (func) {
           case 'drawLine':
-            this.windows[this.windowID].drawLine(intList[0], intList[1], intList[2], intList[3]);
+            this.windows[this.windowID].drawLine(
+              intList[0],
+              intList[1],
+              intList[2],
+              intList[3]
+            );
             break;
           case 'createPolyline':
             this.windows[this.windowID].createPolyline(intList[0]);
@@ -237,7 +273,12 @@ export class ScrollView {
             this.windows[this.windowID].drawPolyline();
             break;
           case 'drawRectangle':
-            this.windows[this.windowID].drawRectangle(intList[0], intList[1], intList[2], intList[3]);
+            this.windows[this.windowID].drawRectangle(
+              intList[0],
+              intList[1],
+              intList[2],
+              intList[3]
+            );
             break;
           case 'setVisible':
             this.windows[this.windowID].setVisible(boolList[0]);
@@ -258,42 +299,96 @@ export class ScrollView {
             this.windows[this.windowID].setStrokeWidth(floatList[0]);
             break;
           case 'drawEllipse':
-            this.windows[this.windowID].drawEllipse(intList[0], intList[1], intList[2], intList[3]);
+            this.windows[this.windowID].drawEllipse(
+              intList[0],
+              intList[1],
+              intList[2],
+              intList[3]
+            );
             break;
           case 'pen':
             if (intList.length === 4) {
-              this.windows[this.windowID].pen(intList[0], intList[1], intList[2], intList[3]);
+              this.windows[this.windowID].pen(
+                intList[0],
+                intList[1],
+                intList[2],
+                intList[3]
+              );
             } else {
-              this.windows[this.windowID].pen(intList[0], intList[1], intList[2]);
+              this.windows[this.windowID].pen(
+                intList[0],
+                intList[1],
+                intList[2]
+              );
             }
             break;
           case 'brush':
             if (intList.length === 4) {
-              this.windows[this.windowID].brush(intList[0], intList[1], intList[2], intList[3]);
+              this.windows[this.windowID].brush(
+                intList[0],
+                intList[1],
+                intList[2],
+                intList[3]
+              );
             } else {
-              this.windows[this.windowID].brush(intList[0], intList[1], intList[2]);
+              this.windows[this.windowID].brush(
+                intList[0],
+                intList[1],
+                intList[2]
+              );
             }
             break;
           case 'textAttributes':
-            this.windows[this.windowID].textAttributes(stringList[0], intList[0], boolList[0], boolList[1], boolList[2]);
+            this.windows[this.windowID].textAttributes(
+              stringList[0],
+              intList[0],
+              boolList[0],
+              boolList[1],
+              boolList[2]
+            );
             break;
           case 'drawText':
-            this.windows[this.windowID].drawText(intList[0], intList[1], stringList[0]);
+            this.windows[this.windowID].drawText(
+              intList[0],
+              intList[1],
+              stringList[0]
+            );
             break;
           case 'addMenuBarItem':
             if (boolList.length > 0) {
-              this.windows[this.windowID].addMenuBarItem(stringList[0], stringList[1], intList[0], boolList[0]);
+              this.windows[this.windowID].addMenuBarItem(
+                stringList[0],
+                stringList[1],
+                intList[0],
+                boolList[0]
+              );
             } else if (intList.length > 0) {
-              this.windows[this.windowID].addMenuBarItem(stringList[0], stringList[1], intList[0]);
+              this.windows[this.windowID].addMenuBarItem(
+                stringList[0],
+                stringList[1],
+                intList[0]
+              );
             } else {
-              this.windows[this.windowID].addMenuBarItem(stringList[0], stringList[1]);
+              this.windows[this.windowID].addMenuBarItem(
+                stringList[0],
+                stringList[1]
+              );
             }
             break;
           case 'addPopupMenuItem':
             if (stringList.length === 4) {
-              this.windows[this.windowID].addPopupMenuItem(stringList[0], stringList[1], intList[0], stringList[2], stringList[3]);
+              this.windows[this.windowID].addPopupMenuItem(
+                stringList[0],
+                stringList[1],
+                intList[0],
+                stringList[2],
+                stringList[3]
+              );
             } else {
-              this.windows[this.windowID].addPopupMenuItem(stringList[0], stringList[1]);
+              this.windows[this.windowID].addPopupMenuItem(
+                stringList[0],
+                stringList[1]
+              );
             }
             break;
           case 'update':
@@ -306,7 +401,12 @@ export class ScrollView {
             this.windows[this.windowID].showYesNoDialog(stringList[0]);
             break;
           case 'zoomRectangle':
-            this.windows[this.windowID].zoomRectangle(intList[0], intList[1], intList[2], intList[3]);
+            this.windows[this.windowID].zoomRectangle(
+              intList[0],
+              intList[1],
+              intList[2],
+              intList[3]
+            );
             break;
           case 'readImage':
             this.imageWaiting = true;
@@ -329,11 +429,18 @@ export class ScrollView {
         }
       } else if (idStrs[1].startsWith('= luajava.newInstance')) {
         // No colon. Check for create window.
-        this.windows[this.windowID] = new SVWindow(stringList[1],
-          intList[0], intList[1],
-          intList[2], intList[3],
-          intList[4], intList[5],
-          intList[6], this.createCanvas, this.lightTheme);
+        this.windows[this.windowID] = new SVWindow(
+          stringList[1],
+          intList[0],
+          intList[1],
+          intList[2],
+          intList[3],
+          intList[4],
+          intList[5],
+          intList[6],
+          this.createCanvas,
+          this.lightTheme
+        );
       }
     }
   }
diff --git a/scrollview-web/scrollview/ui/SVImageHandler.js b/scrollview-web/scrollview/ui/SVImageHandler.js
index 5ef09e63f5dcb633943a92aa2dad5c69449f6f4a..fd0680e1d27b54a21e3c1bcc04f6db4a158ad780 100644
--- a/scrollview-web/scrollview/ui/SVImageHandler.js
+++ b/scrollview-web/scrollview/ui/SVImageHandler.js
@@ -1,15 +1,17 @@
 // Disabling eslint rules that would increase differences between Java/JavaScript versions.
 /* eslint-disable no-param-reassign */
-const browserMode = typeof process === 'undefined';
+const browserMode = true;
 
 export class SVImageHandler {
   /**
    * @param {string} imgStr
    */
   static imageStrToBlob(imgStr) {
-    const imgData = new Uint8Array(atob(imgStr)
-      .split('')
-      .map((c) => c.charCodeAt(0)));
+    const imgData = new Uint8Array(
+      atob(imgStr)
+        .split('')
+        .map((c) => c.charCodeAt(0))
+    );
 
     const imgBlob = new Blob([imgData], { type: 'application/octet-stream' });
 
@@ -17,8 +19,8 @@ export class SVImageHandler {
   }
 
   /**
-  * @param {string} imgStr
-  */
+   * @param {string} imgStr
+   */
   static imageStrToBuffer(imgStr) {
     const imageBuffer = Buffer.from(imgStr, 'base64');
 
@@ -41,7 +43,10 @@ export class SVImageHandler {
       return imgBit;
     }
 
-    if (CanvasKit === undefined) throw new Error('CanvasKit module must be provided in environments that do not support OffscreenCanvas natively (i.e. Node.js).');
+    if (CanvasKit === undefined)
+      throw new Error(
+        'CanvasKit module must be provided in environments that do not support OffscreenCanvas natively (i.e. Node.js).'
+      );
 
     const imgBuffer = this.imageStrToBuffer(img);
     const imgBit = CanvasKit.MakeImageFromEncoded(imgBuffer);
